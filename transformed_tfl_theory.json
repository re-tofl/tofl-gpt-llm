[
    {
        "question": "Что такое язык Лукасевича",
        "answer": "Языком Лукасевича над n + 1 буквами называется контекстно-свободный язык над алфавитом {a0, a1,...,an}, порождаемый грамматикой S -> a0, S -> a1S, S -> a2SS, ..., S -> anSn. Замечание: При любом n ∈ N грамматика является однозначной."
    },
    {
        "question": "Что такое язык Лукасевича?",
        "answer": "Язык Лукасевича над n + 1 буквой — это контекстно-свободный язык над алфавитом {a0, a1,...,an}, порождённый грамматикой S -> a0, S -> a1S, S -> a2SS, ..., S -> anSn. Примечание: Для любого n ∈ N грамматика однозначна."
    },
    {
        "question": "Какой язык у Лукасевича?",
        "answer": "Язык Лукасевича на n + 1 букве — это контекстно-свободный язык на алфавите {a0, a1,...,an}, порожденный грамматикой S -> a0, S -> a1S, S -> a2SS, .. ., S ->anSn. Примечание. Для всех n ∈ N грамматика однозначна."
    },
    {
        "question": "Какой язык у Лукасевича?",
        "answer": "Язык Лукасевича на n + 1 букве — это контекстно-свободный язык на алфавите {a0, a1,...,an}, порожденный грамматикой S -> a0, S -> a1S, S -> a2SS, .. , S -> anSn. Примечание. Для всех n ∈ N грамматика однозначна."
    },
    {
        "question": "На каком языке говорит Лукасевич?",
        "answer": "Язык Лукасевича на n + 1 букве — это контекстно-свободный язык на алфавите {a0, a1,...,an}, порождённый грамматикой S -> a0, S -> a1S, S -> a2SS, .. , S -> anSn. Примечание: Для всех n ∈ N грамматика однозначна."
    },
    {
        "question": "Что такое язык Дика",
        "answer": "Языком Дика над 2n\nбуквами называется контекстно-свободный язык над алфавитом\n{a1, b1, a2, b2,...,an, bn}, порождаемый грамматикой S → ε,\nS → a1Sb1S, ..., S → anSbnS.\nЗамечание: Словами этого языка являются последовательности правильно вложенных скобок n типов.\nЗамечание: При любом n ∈ N грамматика является однозначной."
    },
    {
        "question": "На каком языке говорит Дик?",
        "answer": "Язык Дик над 2n\nбуквами — это контекстно-свободный язык над алфавитом\n{a1, b1, a2, b2,...,an, bn}, порожденный грамматикой S → ε,\nS → a1Sb1S, ..., S → anSbnS.\nПримечание: Слова этого языка представляют собой последовательности правильно вложенных скобок n типов.\nПримечание: Для любого n ∈ N грамматика однозначна."
    },
    {
        "question": "На каком языке говорит Дик?",
        "answer": "Член с языком на 2n\nбуквы - это язык без контекста в алфавите\n{a1, b1, a2, b2,...,an, bn}, порожденный грамматикой S → ε,\nS → a1Sb1S, ..., S → anSbnS.\nПримечание. Слова в этом языке представляют собой последовательность правильно вложенных круглых скобок n типов.\nПримечание. Для всех n ∈ N грамматика однозначна."
    },
    {
        "question": "Что такое язык Дика?",
        "answer": "Язык Дика за 2н.\nбуквы называются контекстно-свободным языком по сравнению с алфавитом\n{a1, b1, a2, b2,...,an, bn}, порожденный грамматикой S → ε,\nS → a1Sb1S, ..., S → anSbnS.\nПримечание. Слова в этом языке представляют собой последовательность правильно вложенных круглых скобок n типов.\nПримечание. Для всех n ∈ N грамматика однозначна."
    },
    {
        "question": "На каком языке говорит Дик?",
        "answer": "Язык Дика из 2n.\nбукв называется контекстно-свободным языком по сравнению с алфавитом\n{a1, b1, a2, b2,...,an, bn}, порожденным грамматикой S → ε,\nS → a1Sb1S, ..., S → anSbnS.\nПримечание: Слова в этом языке представляют собой последовательности регулярно вложенных скобок n типов.\nПримечание: Для всех n ∈ N грамматика однозначна."
    },
    {
        "question": "Что такое автомат Мили",
        "answer": "Автомат Мили - это 6-ка (Q, Σ, Λ, δ, λ, q₀), где:\nQ - множество состояний автомата\nΣ - конечный входной алфавит\nΛ - конечный выходной алфавит\nδ - функция перехода, которая принимает текущее состояние и входной символ, и возвращает следующее состояние\nλ - функция вывода, которая принимает текущее состояние и входной символ, и возвращает выходной символ\nq₀ - начальное состояние"
    },
    {
        "question": "Что такое машина Мили?",
        "answer": "Автомат Мили — это 6-кортеж (Q, Σ, Λ, δ, λ, q₀), где:\nQ — множество состояний автомата\nΣ — конечный входной алфавит\nΛ — конечный выходной алфавит\nδ — функция перехода, которая принимает текущее состояние и входной символ и возвращает следующее состояние\nλ — выходная функция, которая принимает текущее состояние и входной символ и возвращает выходной символ\nq₀ — начальное состояние"
    },
    {
        "question": "Что такое машина Мили?",
        "answer": "Машина Мили — это набор из 6 элементов (Q, Σ, Λ, δ, λ, q₀), где:\nQ - набор состояний машины\nΣ — последний входной алфавит\nΛ — конечный выходной алфавит\nδ — функция перехода, которая принимает текущее состояние и входной символ и возвращает следующее состояние.\nλ — выходная функция, которая принимает текущее состояние и входной символ и возвращает выходной символ.\nq₀ - исходное состояние"
    },
    {
        "question": "Что такое машина Мили?",
        "answer": "Машина Мили — это 6 (Q, Σ, Λ, δ, λ, q₀), где:\nQ - множество состояний автомата\nΣ - последний входной алфавит\nΛ - окончательный выходной алфавит\nδ — функция перехода, которая принимает текущее состояние и входной символ и возвращает следующее состояние.\nλ — выходная функция, которая принимает текущее состояние и входной символ и возвращает выходной символ.\nq₀ - исходное состояние"
    },
    {
        "question": "Что такое автомат Miles?",
        "answer": "Автомат Мили — это 6(Q, Σ, Λ, δ, λ, q₀), где:\nQ — множество состояний автомата\nΣ — конечный входной алфавит\nΛ — конечный выходной алфавит\nδ — функция перехода, которая принимает текущее состояние и входной символ и возвращает следующее состояние.\nλ — выходная функция, которая принимает текущее состояние и входной символ и возвращает выходной символ.\nq₀ — начальное состояние"
    },
    {
        "question": "Какие есть свойства у класса детерминнированых контекстно-свободных языков",
        "answer": "Теорема: Каждый автоматный язык является детерминированным контекстно-свободным языком.\nТеорема: Язык L ⊆ Σ∗ является детерминированным\nконтекстно-свободным языком тогда и только тогда, когда\nнайдётся такой детерминированный МП-автомат M' = <Q', Σ, Γ', ∆', I', F'>, что\nL={w∈Σ∗ | <s,w,ε> |*-- <q,ε,α> для некоторых s∈I', q∈F', α∈Γ'∗}.\nТеорема: Пусть L — детерминированный контекстно-свободный язык. Тогда язык L не является существенно\nнеоднозначным.\nТеорема: Дополнение каждого детерминированного\nконтекстно-свободного языка является детерминированным\nконтекстно-свободным языком.\nПример 12.10. Язык L = {a^kb^mc^n | k != m или m != n}\nнад алфавитом {a, b, c} не является детерминированным контекстно-свободнымязыком, так как его дополнение не является\nконтекстно-свободным\nТеорема: Неверно, что для любых детерминированных контекстно-свободных языков L1 и L2 язык L1 ∩ L2\nтоже является детерминированным контекстно-свободным\nязыком.\nТеорема: Неверно, что для любых детерминированных контекстно-свободных языков L1 и L2 язык L1 ∪ L2\nтоже является детерминированным контекстно-свободным языком."
    },
    {
        "question": "Каковы свойства класса детерминированных контекстно-свободных языков?",
        "answer": "Теорема: Каждый автоматный язык является детерминированным контекстно-свободным языком.\nТеорема: Язык L ⊆ Σ∗ является детерминированным контекстно-свободным языком тогда и только тогда,\nкогда существует детерминированный MP-автомат M' = <Q', Σ, Γ', ∆', I', F'> такой, что\nL={w∈Σ∗ | <s,w,ε> |*-- <q,ε,α> для некоторых s∈I', q∈F', α∈Γ'∗}.\nТеорема: Пусть L — детерминированный контекстно-свободный язык. Тогда L по существу не является\nнеоднозначным.\nТеорема: Дополнение каждого детерминированного контекстно-свободного языка является детерминированным контекстно-свободным языком.\nПример 12.10. Язык L = {a^kb^mc^n | k != m или m != n}\nнад алфавитом {a, b, c} не является детерминированным контекстно-свободным языком, поскольку его дополнение не является\nконтекстно-свободным\nТеорема: Неверно, что для любых детерминированных контекстно-свободных языков ​​L1 и L2 язык L1 ∩ L2\nтакже является детерминированным контекстно-свободным\nязыком.\nТеорема: Неверно, что для любых детерминированных контекстно-свободных языков ​​L1 и L2 язык L1 ∪ L2\nтакже является детерминированным контекстно-свободным\nязыком."
    },
    {
        "question": "Каковы свойства класса контекстно-свободных детерминированных языков?",
        "answer": "Теорема: Любой автоматный язык является контекстно-свободным детерминированным языком.\nТеорема: Язык L ⊆ Σ∗ является контекстно-свободным детерминированным языком тогда и только тогда, когда\nкогда существует детерминированный МП-автомат M' = <Q', Σ, Γ', ∆', I', F'> такой, что\nL={wεΣ∗ | <s,w,ε> |*-- <q,ε,α> для некоторых sεI', qεF', αεΓ'∗}.\nТеорема: Пусть L — детерминированный язык вне контекста. Тогда L по существу не является\nдвусмысленный.\nТеорема: Дополнением к любому контекстно-свободному детерминированному языку является контекстно-свободный детерминированный язык.\nПример 12.10. Язык L = {a^kb^mc^n | k != m или m != n}\nв алфавите {a, b, c} не является детерминированным языком вне контекста, поскольку его дополнение не является\nбез контекста\nТеорема: Неверно, что для любого детерминированного языка вне контекста L1 и L2 язык L1 ∩ L2\nтакже детерминирован без контекста\nязык.\nТеорема: Неверно, что для любого детерминированного языка без контекста L1 и L2 язык L1 ∪ L2\nтакже детерминирован без контекста\nязык."
    },
    {
        "question": "Какими свойствами обладает класс контекстно-свободных детерминированных языков?",
        "answer": "Теорема: Любой автоматный язык является контекстно-свободным детерминированным языком.\nТеорема: Язык L ⊆ Σ∗ детерминирован.\nконтекстно-свободный язык тогда и только тогда, когда\nсуществует детерминированный автомат МП M' = <Q', Σ, Γ', ∆', I', F'> такой, что\nL={wεΣ∗ | <s,w,ε> |*-- <q,ε,α> для некоторых sεI', qεF', αεΓ'∗}.\nТеорема: Пусть L — детерминированный язык вне контекста. Таким образом, язык L по существу не является\nдвусмысленный.\nТеорема: дополнение каждого детерминиста\nконтекстно-свободный язык детерминирован\nязык без контекста.\nПример 12.10. Язык L = {a^kb^mc^n | k != m или m != n}\nв алфавите {a, b, c} не является детерминированным языком вне контекста, поскольку его дополнение не является\nбез контекста\nТеорема: Неверно, что для любого детерминированного языка вне контекста L1 и L2 язык L1 ∩ L2\nтакже детерминирован без контекста\nязык.\nТеорема: Неверно, что для любого детерминированного языка без контекста L1 и L2 язык L1 ∪ L2\nтакже является детерминированным контекстно-свободным языком."
    },
    {
        "question": "Какими свойствами обладает класс контекстно-свободных детерминированных языков?",
        "answer": "Теорема: Каждый автоматный язык является контекстно-свободным детерминированным языком.\nТеорема: Язык L ⊆ Σ∗ является детерминированным.\nКонтекстно-свободный язык является контекстно-свободным языком тогда и только тогда, когда\nсуществует детерминированный MP-автомат M' = <Q', Σ, Γ', ∆', I', F'> такой, что\nL={wεΣ∗ | <s,w,ε> |*-- <q,ε,α> для некоторых sεI', qεF', αεΓ'∗}.\nТеорема: Пусть L — контекстно-свободный детерминированный язык. Таким образом, L по существу однозначен.\nТеорема: Дополнение каждого детерминированного\nКонтекстно-свободный язык является детерминированным\nЯзык без контекста.\nПример 12.10. Язык L = {a^kb^mc^n | k != m или m != n}\nнад алфавитом {a, b, c} не является контекстно-свободным детерминированным языком, поскольку его дополнение не является\nконтекстно-свободным\nТеорема: Неверно, что для любого контекстно-свободного детерминированного языка L1 и L2 язык L1 ∩ L2\nтакже является контекстно-свободным детерминированным\nязыком.\nТеорема: Неверно, что для любого контекстно-свободного детерминированного языка L1 и L2 язык L1 ∪ L2\nтакже является контекстно-свободным детерминированным языком."
    },
    {
        "question": "Сформулируй теорему Клини",
        "answer": "Теорема Клини: Язык L является регулярным тогда и только тогда, когда он является автоматным\nЯзык L называется автоматным, если существует конечный автомат, распознающий этот язык."
    },
    {
        "question": "Теорема Клини",
        "answer": "Теорема Клини: Язык L регулярен тогда и только тогда, когда он является автоматом\nЯзык L называется автоматом, если существует конечный автомат, распознающий этот язык."
    },
    {
        "question": "Теорема Клини",
        "answer": "Теорема Клини: язык L регулярен тогда и только тогда, когда он является автоматом.\nЯзык L называется автоматом, если существует конечный автомат, распознающий этот язык."
    },
    {
        "question": "Государственная теорема Клини",
        "answer": "Теорема Клини: язык L регулярен тогда и только тогда, когда он автоматен.\nЯзык L называется автоматом, если существует конечный автомат, распознающий этот язык."
    },
    {
        "question": "Теорема Клини о состоянии",
        "answer": "Теорема Клини: Язык L регулярен тогда и только тогда, когда он является автоматом. Язык L называется автоматом, если существует конечный автомат, распознающий этот язык."
    },
    {
        "question": "Что такое гомоморфизм афлавитов",
        "answer": "Пусть Σ1 и Σ2 — алфавиты. Если отображение h: Σ∗1 → Σ∗2 удовлетворяет условию h(x · y) = h(x)· h(y)\nдля всех слов x ∈ Σ∗1 и y ∈ Σ∗1, то отображение h называется\nгомоморфизмом (морфизмом).\nЗамечание: Если h — гомоморфизм, то h(ε) = ε.\nПример: Пусть Σ1 = {a, b} и Σ2 = {c}. Тогда\nотображение h: Σ∗1 → Σ∗2, заданное равенством h(w) = c^(2|w|), является гомоморфизмом.\nЗамечание: Каждый гомоморфизм однозначно определяется своими значениями на однобуквенных словах.\nОпределение 1.37. Если h: Σ∗1 → Σ∗2 — гомоморфизм и L ⊆ Σ∗1, то через h(L) обозначается язык {h(w) | w ∈ L}.\nПример: Пусть Σ = {a, b} и гомоморфизм h: Σ∗ → Σ∗ задан равенствами h(a) = abba и h(b) = ε. Тогда\nh({baa, bb}) = {abbaabba, ε}.\nОпределение 1.39. Если h: Σ∗1 → Σ∗2 — гом ом орфизм и L ⊆ Σ∗2, то через h^(−1)(L) обозначается язык {w ∈ Σ∗1 | h(w) ∈ L}.\nПример: Рассмотрим алфавит Σ = {a, b}. Пусть гом оморфизм h: Σ∗ → Σ∗ задан равенствами h(a) = ab и h(b) = abb.\nТогда h^(−1)({ε, abbb, abbab, ababab}) = {ε, ba, aaa}."
    },
    {
        "question": "Что такое гомоморфизм афлавита?",
        "answer": "Пусть Σ1 и Σ2 — алфавиты. Если отображение h: Σ∗1 → Σ∗2 удовлетворяет условию h(x y) = h(x) h(y)\nдля всех слов x ∈ Σ∗1 и y ∈ Σ∗1, то h называется\nгомоморфизмом (морфизмом).\nЗамечание: Если h — гомоморфизм, то h(ε) = ε.\nПример: Пусть Σ1 = {a, b} и Σ2 = {c}. Тогда\nотображение h: Σ∗1 → Σ∗2, заданное формулой h(w) = c^(2|w|), является гомоморфизмом.\nЗамечание: Каждый гомоморфизм однозначно определяется своими значениями на однобуквенных словах.\nОпределение 1.37. Если h: Σ∗1 → Σ∗2 — гомоморфизм и L ⊆ Σ∗1, то h(L) обозначает язык {h(w) | w ∈ L}.\nПример: Пусть Σ = {a, b} и гомоморфизм h: Σ∗ → Σ∗ задан формулами h(a) = abba и h(b) = ε. Тогда h({baa, bb}) = {abbaabba, ε}.\nОпределение 1.39. Если h: Σ∗1 → Σ∗2 — однородный орфизм и L ⊆ Σ∗2, то h^(−1)(L) обозначает язык {w ∈ Σ∗1 | h(w) ∈ L}.\nПример: Рассмотрим алфавит Σ = {a, b}. Пусть гомоморфизм h: Σ∗ → Σ∗ задан равенствами h(a) = ab и h(b) = abb. Тогда h^(−1)({ε, abbb, abbab, ababab}) = {ε, ba, aaa}."
    },
    {
        "question": "Что такое гомоморфизм афлавита?",
        "answer": "Пусть Σ1 и Σ2 — алфавиты. Если отображение h: Σ∗1 → Σ∗2 удовлетворяет условию h(x y) = h(x) h(y)\nдля всех слов x ∈ Σ∗1 и y ∈ Σ∗1, h называется\nгомоморфизм (морфизм).\nПримечание. Если h — гомоморфизм, то h(ε) = ε.\nПример: Пусть Σ1 = {a, b} и Σ2 = {c}. ТАК\nотображение h : Σ∗1 → Σ∗2, заданное формулой h(w) = c^(2|w|), является гомоморфизмом.\nПримечание. Каждый гомоморфизм однозначно определяется его значением в однобуквенных словах.\nОпределение 1.37. Если h : Σ∗1 → Σ∗2 — гомоморфизм и L ⊆ Σ∗1, то h(L) обозначает язык {h(w) | w ∈ L}.\nПример: Пусть Σ = {a, b} и гомоморфизм h: Σ∗ → Σ∗ задан формулами h(a) = abba и h(b) = ε. Тогда h({baa, bb}) = {abbaabba, ε}.\nОпределение 1.39. Если h : Σ∗1 → Σ∗2 — однородный орфизм и L ⊆ Σ∗2, то h^(−1)(L) обозначает язык {w ∈ Σ∗1 | h(w) ∈L}.\nПример: рассмотрим алфавит Σ = {a, b}. Пусть гомоморфизм h: Σ∗ → Σ∗ задается равенствами h(a) = ab и h(b) = abb. Тогда h^(−1)({ε, abbb, abbab, abab}) = {ε, ba, aaa}."
    },
    {
        "question": "Что такое гомоморфизм афлавита?",
        "answer": "Пусть Σ1 и Σ2 — алфавиты. Если отображение h: Σ∗1 → Σ∗2 удовлетворяет условию h(x y) = h(x) h(y)\nдля всех слов x ∈ Σ∗1 и y ∈ Σ∗1, то отображение h называется\nгомоморфизм (морфизм).\nПримечание. Если h — гомоморфизм, то h(ε) = ε.\nПример: Пусть Σ1 = {a, b} и Σ2 = {c}. ТАК\nотображение h: Σ∗1 → Σ∗2, определяемое равенством h(w) = c^(2|w|), является гомоморфизмом.\nПримечание. Каждый гомоморфизм однозначно определяется его значением в однобуквенных словах.\nОпределение 1.37. Если h : Σ∗1 → Σ∗2 — гомоморфизм и L ⊆ Σ∗1, то h(L) обозначает язык {h(w) | w ∈ L}.\nПример. Пусть Σ = {a, b} и гомоморфизм h: Σ∗ → Σ∗, заданный формулами h(a) = abba и h(b) = ε. ТАК\nh({baa, bb}) = {abbaabba, ε}.\nОпределение 1.39. Если h : Σ∗1 → Σ∗2 — однородный орфизм и L ⊆ Σ∗2, то h^(−1)(L) обозначает язык {w ∈ Σ∗1 | h(w) ∈L}.\nПример: рассмотрим алфавит Σ = {a, b}. Пусть гомоморфизм h: Σ∗ → Σ∗ задается равенствами h(a) = ab и h(b) = abb.\nТогда h^(−1)({ε, abbb, abbab, abab}) = {ε, ba, aaa}."
    },
    {
        "question": "Что такое гомоморфизм афлавита?",
        "answer": "Пусть Σ1 и Σ2 — алфавиты. Если отображение h: Σ∗1 → Σ∗2 удовлетворяет условию h(x y) = h(x) h(y)\nдля всех слов x ∈ Σ∗1 и y ∈ Σ∗1, то отображение h называется\nгомоморфизмом (морфизмом).\nПримечание. Если h — гомоморфизм, то h(ε) = ε.\nПример: Пусть Σ1 = {a, b} и Σ2 = {c}. ТАК ЧТО\nотображение h: Σ∗1 → Σ∗2, определенное равенством h(w) = c^(2|w|), является гомоморфизмом.\nПримечание. Каждый гомоморфизм однозначно определяется своим значением в однобуквенных словах.\nОпределение 1.37. Если h : Σ∗1 → Σ∗2 — гомоморфизм и L ⊆ Σ∗1, то h(L) обозначает язык {h(w) | w ∈ L}.\nПример. Пусть Σ = {a, b} и гомоморфизм h: Σ∗ → Σ∗ задан формулами h(a) = abba и h(b) = ε. Таким образом, h({baa, bb}) = {abbaabba, ε}.\nОпределение 1.39. Если h : Σ∗1 → Σ∗2 — однородный орфизм и L ⊆ Σ∗2, то h^(−1)(L) обозначает язык {w ∈ Σ∗1 | h(w) ∈L}.\nПример: рассмотрим алфавит Σ = {a, b}. Пусть гомоморфизм h: Σ∗ → Σ∗ задан равенствами h(a) = ab и h(b) = abb. Тогда h^(−1)({ε, abbb, abbab, abab}) = {ε, ba, aaa}."
    },
    {
        "question": "Что такое алгебра контекстно-свободных языков",
        "answer": "Алгебраические свойства КС-языков:\nЕсли L — контекстно-свободный язык, то\nL∗ тоже контекстно-свободный язык.\nЕсли L1 и L2 — контекстно-свободные языки над алфавитом Σ, то L1 · L2 тоже контекстно-свободный\nязык.\nЕсли L1 и L2 — контекстно-свободные языки над алфавитом Σ, то L1 ∪ L2 тоже контекстно-свободный\nязык.\nЕсли L — контекстно-свободный язык, то\nL^R тоже контекстно-свободный язык.\nЕсли L — КС-язык, а R — регулярный язык, то L ∩ R — КС-язык.\nДополнение КС-языка в общем случае не является КС-языком."
    },
    {
        "question": "Что такое контекстно-свободная языковая алгебра?",
        "answer": "Алгебраические свойства контекстно-свободных языков:\nЕсли L — контекстно-свободный язык, то\nL∗ — также контекстно-свободный язык.\nЕсли L1 и L2 — контекстно-свободные языки над алфавитом Σ, то L1 · L2 — также контекстно-свободный\nязык.\nЕсли L1 и L2 — контекстно-свободные языки над алфавитом Σ, то L1 ∪ L2 — также контекстно-свободный\nязык.\nЕсли L — контекстно-свободный язык, то\nL^R — также контекстно-свободный язык.\nЕсли L — контекстно-свободный язык, а R — регулярный язык, то L ∩ R — контекстно-свободный язык.\nДополнение контекстно-свободного языка в общем случае не является контекстно-свободным языком."
    },
    {
        "question": "Что такое контекстно-свободная языковая алгебра?",
        "answer": "Алгебраические свойства контекстно-свободных языков:\nЕсли L — контекстно-свободный язык, то\nL∗ также является контекстно-свободным языком.\nЕсли L1 и L2 — контекстно-свободные языки на алфавите Σ, то L1 · L2 также являются контекстно-свободными.\nязык.\nЕсли L1 и L2 — контекстно-свободные языки на алфавите Σ, то L1 ∪ L2 также являются контекстно-свободными.\nязык.\nЕсли L — контекстно-свободный язык, то\nL^R также является контекстно-свободным языком.\nЕсли L — контекстно-свободный язык, а R — регулярный язык, то L ∩ R — контекстно-свободный язык.\nДополнение к контекстно-свободному языку, как правило, не является контекстно-свободным языком."
    },
    {
        "question": "Что такое алгебра контекстно-свободных языков?",
        "answer": "Алгебраические свойства языков CS:\nЕсли L — контекстно-свободный язык, то\nL∗ также является контекстно-свободным языком.\nЕсли L1 и L2 — контекстно-свободные языки на алфавите Σ, то L1 · L2 также являются контекстно-свободными.\nязык.\nЕсли L1 и L2 — контекстно-свободные языки на алфавите Σ, то L1 ∪ L2 также являются контекстно-свободными.\nязык.\nЕсли L — контекстно-свободный язык, то\nL^R также является контекстно-свободным языком.\nЕсли L — язык KS, а R — регулярный язык, то L ∩ R — язык KS.\nДобавление языка KS обычно не является языком KS."
    },
    {
        "question": "Что такое контекстно-свободная языковая алгебра?",
        "answer": "Алгебраические свойства языков CS:\nЕсли L — контекстно-свободный язык, то\nL∗ — также контекстно-свободный язык.\nЕсли L1 и L2 — контекстно-свободные языки на алфавите Σ, то L1 L2 также являются контекстно-свободными.\nязык.\nЕсли L1 и L2 — контекстно-свободные языки на алфавите Σ, то L1 ∪ L2 также являются контекстно-свободными.\nязык.\nЕсли L — контекстно-свободный язык, то\nL^R также является контекстно-свободным языком.\nЕсли L — язык KS, а R — регулярный язык, то L ∩ R — язык KS.\nДобавление языка KS обычно не является языком KS."
    },
    {
        "question": "Что такое деревья вывода",
        "answer": "Выводам в контекстно-свободной грамматике соответствуют так называемые деревья вывода (или деревья\nразбора) — некоторые упорядоченные деревья, вершины которых помечены символами алфавита N ∪Σ.\nКорень дерева отвечает начальному символу. Каждому символу слова w1, на которую заменяется начальный символ на первом\nшаге вывода, ставится в соответствие вершина дерева, и к ней\nпроводится дуга из корня. Полученные таким образом непосредственные потомки корня упорядочены согласно порядку их меток\nв слове w1. Для тех из полученных вершин, которые помечены символами из множества N, делается аналогичное построение\nи т. д. Кроной дерева вывода называется слово, записанное в\nвершинах, помеченных символами из алфавита Σ.\nПример: Рассмотрим контекстно-свободную грамматику\nS -> SS, S -> ab, S -> aSb. Выводу S -> SS -> Sab -> SSab -> abSab -> ababab соответствует следующее дерево вывода:\n        S\n       / \\\n      S   S\n     / \\  |\\\n    S   S a b\n   /|   |\\\n  a b   a b"
    },
    {
        "question": "Что такое деревья вывода?",
        "answer": "Выходы в контекстно-свободной грамматике соответствуют так называемым выходным деревьям (или деревьям разбора) — некоторым упорядоченным деревьям, вершины которых помечены символами из алфавита N ∪ Σ.\nКорень дерева соответствует начальному символу. Каждому символу слова w1, который заменяет начальный символ на первом шаге вывода, сопоставляется вершина дерева, и от корня к ней проводится дуга. Полученные таким образом непосредственные потомки корня упорядочиваются в соответствии с порядком их меток\nв слове w1. Для тех из полученных вершин, которые помечены символами из множества N, производится аналогичное построение,\nи так далее. Венцом выходного дерева является слово, записанное в вершинах, помеченных символами из алфавита Σ.\nПример: Рассмотрим контекстно-свободную грамматику\nS -> SS, S -> ab, S -> aSb. Выход S -> SS -> Sab -> SSab -> abSab -> ababab соответствует следующему выходному дереву:\nS\n/ \\\nS S\n/ \\ |\\\nS S a b\n/| |\\\na b a b"
    },
    {
        "question": "Что такое деревья вывода?",
        "answer": "Выходные данные в контекстно-свободной грамматике соответствуют так называемым выходным деревьям (или деревьям разбора) – упорядоченным деревьям, вершины которых отмечены символами алфавита N ∪ Σ.\nКорень дерева соответствует начальному персонажу. Каждому символу слова w1, заменяющему исходный символ на первом шаге вывода, ставится в соответствие вершина дерева, и от корня к ней проводится дуга. Непосредственные результирующие дочерние элементы корня упорядочены в соответствии с порядком их меток.\nв слове w1. Для тех из получившихся вершин, которые отмечены символами из множества N, проводится аналогичное построение:\nи так далее. Венцом выходного вала является слово, написанное в вершинах, отмеченных символами алфавита Σ.\nПример. Рассмотрим контекстно-свободную грамматику.\nS -> SS, S -> ab, S -> aSb. Выход S -> SS -> Sab -> SSab -> abSab -> ababab соответствует следующему выходному дереву:\nС\n/\\\nSS\n/ \\ |\\\nС С а б\n/| |\\\nа б а б"
    },
    {
        "question": "Что такое деревья вывода",
        "answer": "Выводы в контекстно-свободной грамматике соответствуют тому, что мы называем деревьями вывода (или\nсинтаксический анализ) представляют собой упорядоченные деревья, вершины которых отмечены символами алфавита N ∪Σ.\nКорень дерева соответствует начальному символу. Каждый символ слова w1, который заменяется начальным символом первого\nшаге вывода присваивается вершина дерева, а ей\nот корня рисуется дуга. Непосредственные результирующие дочерние элементы корня упорядочены в соответствии с порядком их меток.\nв слове w1. Для тех из получившихся вершин, которые отмечены символами из множества N, проводится аналогичное построение\nи т. д. Крона дерева умозаключений — это слово, написанное на\nвершины отмечены символами алфавита Σ.\nПример. Рассмотрим контекстно-свободную грамматику.\nS -> SS, S -> ab, S -> aSb. Выход S -> SS -> Sab -> SSab -> abSab -> ababab соответствует следующему выходному дереву:\n        С\n       /\\\n      SS\n     / \\ |\\\n    С С а б\n   /|   |\\\n  а б а б"
    },
    {
        "question": "Что такое деревья вывода?",
        "answer": "Выходы в контекстно-свободной грамматике соответствуют тому, что мы называем деревьями вывода (или\nразбором), — это упорядоченные деревья, узлы которых помечены символами из алфавита N ∪ Σ.\nКорень дерева соответствует начальному символу. Каждому символу слова w1, который заменяется начальным символом первого\nшага вывода, назначается узел дерева, и от корня к нему проводится дуга. Непосредственные результирующие дочерние элементы корня упорядочиваются в соответствии с порядком их меток.\nв слове w1. Для тех из результирующих узлов, которые помечены символами из множества N, выполняется аналогичное построение\nи так далее. Корона дерева вывода — это слово, записанное на\nузлы помечены символами из алфавита Σ.\nПример. Рассмотрим контекстно-свободную грамматику.\nS -> SS, S -> ab, S -> aSb. Выход S -> SS -> Sab -> SSab -> abSab -> ababab соответствует следующему выходному дереву:\nC\n/\\\nSS\n/ \\ |\\\nC C a b\n/| |\\\na b a b"
    },
    {
        "question": "Что такое неукорачивающиеся грамматики",
        "answer": "Определение: Порождающая грамматика называется\nнеукорачивающей, если для каждого правила (α -> β) ∈ P\nвыполняется неравенство |α| <= |β|.\nТеорема: Существует алгоритм, позволяющий по\nпроизвольной неукорачивающей грамматике G и по слову w\nузнать, верно ли, что w ∈ L(G).\nТеорема: Каждая контекстная грамматика является неукорачивающей. Каждая неукорачивающая грамматика\nэквивалентна некоторой контекстной грамматике.\nПример: Грамматика S -> AST A, S -> AbA, A -> a,\nbT -> bb, AT -> TA эквивалентна контекстной грамматике S -> ASTA, S -> AbA, A -> a,\nbT -> bb, AT -> UT, UT -> UV, UV -> TV, TV -> TA."
    },
    {
        "question": "Что такое неконтрактные грамматики?",
        "answer": "Определение: Генеративная грамматика называется\nнеконтрактной, если для каждого правила (α -> β) ∈ P\nвыполняется неравенство |α| <= |β|.\nТеорема: Существует алгоритм, который,\nесли задана произвольная неконтрактная грамматика G и слово w,\nнаходит, является ли w ∈ L(G).\nТеорема: Каждая контекстная грамматика является неконтрактной. Каждая неконтрактная грамматика\nэквивалентна некоторой контекстной грамматике.\nПример: Грамматика S -> AST A, S -> AbA, A -> a,\nbT -> bb, AT -> TA эквивалентна контекстной грамматике S -> ASTA, S -> AbA, A -> a,\nbT -> bb, AT -> UT, UT -> UV, UV -> TV, TV -> TA."
    },
    {
        "question": "Что такое недоговорные грамматики?",
        "answer": "Определение: Генеративной грамматикой называется\nнедоговорный, если для каждого правила (α -> β) ∈ P\nнеравенство |α| <= |β|.\nТеорема: существует алгоритм, который\nесли мы дадим ему произвольную недоговорную грамматику G и слово w,\nвыяснить, принадлежит ли w G L(G).\nТеорема: Вся контекстная грамматика является недоговорной. Любая внедоговорная грамматика\nэквивалентно контекстуальной грамматике.\nПример: Грамматика S -> AST A, S -> AbA, A -> a,\nbT -> bb, AT -> TA эквивалентно контекстной грамматике S -> ASTA, S -> AbA, A -> a,\nбТ -> бб, АТ -> УТ, УТ -> УФ, УФ -> ТВ, ТВ -> ТА."
    },
    {
        "question": "Что такое несокращенные грамматики",
        "answer": "Определение: порождающая грамматика называется\nнесокращение, если для каждого правила (α -> β) ∈ P\nнеравенство |α| <= |β|.\nТеорема: Существует алгоритм, позволяющий\nпроизвольная неусеченная грамматика G и слово w\nвыяснить, верно ли, что w ∈ L(G).\nТеорема: Вся контекстная грамматика несокращена. Вся грамматика не усечена\nэквивалентно контекстуальной грамматике.\nПример: Грамматика S -> AST A, S -> AbA, A -> a,\nbT -> bb, AT -> TA эквивалентно контекстной грамматике S -> ASTA, S -> AbA, A -> a,\nбТ -> бб, АТ -> УТ, УТ -> УФ, УФ -> ТВ, ТВ -> ТА."
    },
    {
        "question": "Что такое несокращенные грамматики?",
        "answer": "Определение: Генеративная грамматика называется\nнесводимой, если для каждого правила (α -> β) ∈ P\nвыполняется неравенство |α| <= |β|.\nТеорема: Существует алгоритм, позволяющий\nпо произвольной неусеченной грамматике G и слову w\nвыяснить, является ли w ∈ L(G).\nТеорема: Все контекстные грамматики несократимы. Все грамматики неусечены\nэквивалентны контекстным грамматикам.\nПример: Грамматика S -> AST A, S -> AbA, A -> a,\nbT -> bb, AT -> TA эквивалентна контекстной грамматике S -> ASTA, S -> AbA, A -> a,\nbT -> bb, AT -> UT, UT -> UP, UP -> TV, TV -> TA."
    },
    {
        "question": "Перечисли свойства регулярных выражений",
        "answer": "Регулярные выражения образуют ассоциативное полукольцо с операциями (0, +, 1, ·), то есть для любых\nрегулярных выражений e, f и g выполняются следующие тождества:\n1. e+f = f+e,\n2. e+0 = e,\n3. (e+f)+g = e+(f+g),\n4. e·1 = e,\n5. 1·e = e,\n6. (e·f)·g = e·(f·g),\n7. e·(f+g) = e·f+e·g,\n8. (f+g)·e = f·e+g·e,\n9. e·0=0,\n10. 0·e = 0.\nРавенство понимается как равенство языков, задаваемых\nрегулярными выражениями.\nДля любых регулярных выражений e и f\nвыполняются следующие тождества:\n1. e+e = e,\n2. (1+e+ee+ ... +e^(n−1))(e^n)∗ = e∗ для любого n >= 1,\n3. (e∗f)∗e∗ = (e+f)∗,\n4. 1+e(fe)∗f = (ef)∗.\nЛемма: Для любых регулярных выражений e, f и g,\nесли e = ef+g и ε !∈ L(f), то e = gf∗."
    },
    {
        "question": "Перечислите свойства регулярных выражений.",
        "answer": "Регулярные выражения образуют ассоциативное полукольцо с операциями (0, +, 1, ), то есть для любых\nрегулярных выражений e, f и g выполняются следующие тождества:\n1. e+f = f+e,\n2. e+0 = e,\n3. (e+f)+g = e+(f+g),\n4. e·1 = e,\n5. 1·e = e,\n6. (e·f)·g = e·(f·g),\n7. e·(f+g) = e·f+e·g,\n8. (f+g)·e = f·e+g·e,\n9. e·0=0,\n10. 0·e = 0.\nРавенство понимается как равенство языков, определяемых\nрегулярными выражениями. Для любых регулярных выражений e и f\nвыполняются следующие тождества:\n1. e+e = e,\n2. (1+e+ee+ ... +e^(n−1))(e^n)∗ = e∗ для любого n >= 1,\n3. (e∗f)∗e∗ = (e+f)∗,\n4. 1+e(fe)∗f = (ef)∗.\nЛемма: Для любых регулярных выражений e, f и g,\nесли e = ef+g и ε !∈ L(f), то e = gf∗."
    },
    {
        "question": "Перечислите свойства регулярных выражений.",
        "answer": "Регулярные выражения образуют ассоциативное полукольцо с операциями (0, +, 1, ), т.е. для всех\nрегулярные выражения e, f и g удовлетворяют следующим тождествам:\n1. е+е = е+е,\n2. е+0 = е,\n3. (е+е)+г = е+(е+г),\n4. е 1 = е,\n5. 1 е = е,\n6. (эф)г = е(ф г),\n7. е·(f+g) = е·f+e·g,\n8. (f+g)e = fe+ge,\n9. е·0=0,\n10. 0 е = 0.\nПод равенством понимается равенство определенных языков.\nрегулярные выражения. Для всех регулярных выражений e и f\nимеют место следующие личности:\n1. е+е = е,\n2. (1+e+ee+ ... +e^(n−1))(e^n)∗ = e∗ для всех n >= 1,\n3. (e∗f)∗e∗ = (e+f)∗,\n4. 1+e(fe)∗f = (ef)∗.\nЛемма: для любого регулярного выражения e, f и g\nесли e = ef+g и ε !ε L(f), то e = gf∗."
    },
    {
        "question": "Список свойств регулярных выражений",
        "answer": "Регулярные выражения образуют ассоциативное полукольцо с операциями (0, +, 1, ·), т.е. для всех\nрегулярные выражения e, f и g удовлетворяют следующим тождествам:\n1. е+е = е+е,\n2. е+0 = е,\n3. (е+е)+г = е+(е+г),\n4. е 1 = е,\n5. 1 е = е,\n6. (эф)г = е(ф г),\n7. е·(f+g) = е·f+e·g,\n8. (f+g)e = fe+ge,\n9. е·0=0,\n10. 0 е = 0.\nПод равенством понимается равенство данных языков.\nрегулярные выражения.\nДля всех регулярных выражений e и f\nимеют место следующие личности:\n1. е+е = е,\n2. (1+e+ee+ ... +e^(n−1))(e^n)∗ = e∗ для всех n >= 1,\n3. (e∗f)∗e∗ = (e+f)∗,\n4. 1+e(fe)∗f = (ef)∗.\nЛемма: для любого регулярного выражения e, f и g\nесли e = ef+g и ε !ε L(f), то e = gf∗."
    },
    {
        "question": "Список свойств регулярных выражений",
        "answer": "Регулярные выражения образуют ассоциативное полукольцо с операциями (0, +, 1, ), т. е. для всех\nрегулярных выражений e, f и g удовлетворяют следующим тождествам:\n1. e + e = e + e,\n2. e + 0 = e,\n3. (e + e) ​​​​+ g = e + (e + g),\n4. e 1 = e,\n5. 1 e = e,\n6. (eff) g = e (eff g),\n7. e (f + g) = e f + e g,\n8. (f + g) e = fe + g,\n9. e 0 = 0,\n10. 0 e = 0.\nРавенство понимается как равенство этих языков.\nрегулярные выражения.\nДля всех регулярных выражений e и f\nвыполняются следующие тождества:\n1. e + e = e,\n2. (1 + e + ee + ... + e^(n−1))(e^n)∗ = e∗ для всех n >= 1,\n3. (e∗f)∗e∗ = (e+f)∗,\n4. 1 + e(fe)∗f = (ef)∗.\nЛемма: для любых регулярных выражений e, f и g,\nесли e = ef+g и ε !ε L(f), то e = gf∗."
    },
    {
        "question": "Что такое перевод конечного автомата в регулярное выражение",
        "answer": "Определение: Регулярное выражение над алфавитом Σ определяется рекурсивно следующимобразом: 0 является регулярнымвыражением; 1 является регулярным выражением; если\na ∈ Σ, то a является регулярным выражением; если e и f являются регулярными выражениями, то (e+f), (e·f) и e∗ тоже\nявляются регулярными выражениями. Вместо e·f часто пишут просто ef.\nПример. Пусть Σ = {a, b}. Тогда ((a·b)∗·(1+a)) является\nрегулярнымвыражениемнад алфавитом Σ.\nОпределение: Конечный автомат — это пятёрка M = <Q, Σ, ∆,I,F>, где\nΣ — конечный алфавит, Q и ∆ — конечные м ножества,\n∆ ⊆ Q × Σ∗ × Q, I ⊆ Q, F ⊆ Q. Элем енты Q называются состояниями, элементы I — начальными (initial) состояниями,\nэлементы F — заключительными или допускающими состояниями. Если <p, x, q> ∈ ∆, то <p, x, q> называется\nпереходом из p в q, а слово x — меткой этого\nперехода.\nПример: Пусть Q = {1, 2}, Σ = {a, b}, I = {2},\nF = {2}, ∆ = {<1, aaa, 1>, <1, ab, 2>, <1, b, 2>, <2, ε, 1>}. Тогда\n<Q, Σ, ∆,I,F> — конечный автом автомат.\nАлгоритм Томпсона (Данный алгоритм преобразовывает НКА в эквивалентный ДКА)\nАлгоритм преобразования ДКА в РВ:\nАлгебраический метод Бжозовского\nПри преобразовании ДКА в регулярное выражение создается система регулярных выражений \nдля каждого состояния в ДКА, а затем она решается для регулярных выражений Ri, связанных \nс терминальным состояниями qi. Построение уравнения происходит следующим образом: для каждого состояния qi уравнение Ri\nявляется объединением переходов, ведущих в это состояние. Переход a из qi в qj обозначается за aRi. Если qi\n- терминальное состояние, то в Ri добавляется ε. Это приводит к системе уравнений вида:\n\nR1=a1∗R1+a2∗R2+a3∗R3+...\nR2=a1∗R1+a2∗R2+a3∗R3+...+ε\n...\nRm=a1∗R1+a2∗R2+a3∗R3+...+ε\n\nгде ax = ∅ если нет перехода от Ri к Rj. Система может быть решена с помощью простой подстановки, \nза исключением случаев, когда неизвестное появляется как в правой, так и в левой части уравнения. \nДля этого можно воспользоваться теоремой Ардена:\n\nУравнение вида R=Q+RP, где P≠ε, имеет решение R=QP∗."
    },
    {
        "question": "Что такое конечный автомат для перевода регулярных выражений?",
        "answer": "Определение: Регулярное выражение над алфавитом Σ определяется рекурсивно следующим образом: 0 — регулярное выражение; 1 — регулярное выражение; если\na ∈ Σ, то a — регулярное выражение; если e и f — регулярные выражения, то (e+f), (e f) и e∗ также являются\nрегулярными выражениями. e f часто просто записывается как ef.\nПример: Пусть Σ = {a, b}. Тогда ((a b)∗ (1+a)) — регулярное выражение над алфавитом Σ.\nОпределение: Конечный автомат — это пятерка M = <Q, Σ, ∆, I, F>, где \nΣ — конечный алфавит, Q и ∆ — конечные множества, \n∆ ⊆ Q × Σ∗ × Q, I ⊆ Q, F ⊆ Q. Элементы Q называются состояниями, элементы I называются начальными состояниями, а элементы F называются конечными или принимающими состояниями. Если <p, x, q> ∈ ∆, то <p, x, q> называется переходом от p к q, а слово x называется меткой этого перехода. Пример: Пусть Q = {1, 2}, Σ = {a, b}, I = {2},\nF = {2}, ∆ = {<1, aaa, 1>, <1, ab, 2>, <1, b, 2>, <2, ε, 1>}. Тогда\n<Q, Σ, ∆,I,F> — конечный автомат.\nАлгоритм Томпсона (Этот алгоритм преобразует НКА в эквивалентный ДКА)\nАлгоритм преобразования ДКА в регулярное выражение:\nАлгебраический метод Бжозовского\nПри преобразовании ДКА в регулярное выражение создается система регулярных выражений\nдля каждого состояния в ДКА, а затем она решается для регулярных выражений Ri, связанных\nс конечными состояниями qi. Уравнение строится следующим образом: для каждого состояния qi уравнение Ri\nявляется объединением переходов, ведущих в это состояние. Переход a из qi в qj обозначается как aRi. Если qi\nявляется конечным состоянием, то к Ri добавляется ε. Это приводит к системе уравнений вида:\n\nR1=a1∗R1+a2∗R2+a3∗R3+...\nR2=a1∗R1+a2∗R2+a3∗R3+...+ε\n...\nRm=a1∗R1+a2∗R2+a3∗R3+...+ε\n\nгде ax = ∅, если нет перехода из Ri в Rj. Систему можно решить простой подстановкой, \nза исключением случаев, когда неизвестное появляется как в правой, так и в левой части уравнения. \nДля этого можно воспользоваться теоремой Ардена:\n\nУравнение вида R=Q+RP, где P≠ε, имеет решение R=QP∗."
    },
    {
        "question": "Что такое конечный автомат для перевода регулярных выражений?",
        "answer": "Определение: Регулярное выражение в алфавите Σ определяется рекурсивно следующим образом: 0 – регулярное выражение; 1 – регулярное выражение; Если\na ∈ Σ, то a — регулярное выражение; если e и f — регулярные выражения, то (e+f), (ef) и e∗ также являются\nрегулярные выражения. e f часто пишется просто как ef.\nПример: Пусть Σ = {a, b}. Тогда ((a b)∗ (1+a)) — регулярное выражение в алфавите Σ.\nОпределение: Конечный автомат — это пятерка M = <Q, Σ, ∆, I, F>, где \nΣ — конечный алфавит, Q и ∆ — конечные множества, \n∆ ⊆ Q × Σ∗ × Q, I ⊆ Q, F ⊆ Q. Элементы Q называются состояниями, элементы I называются начальными состояниями, а элементы F называются конечными или принимающими состояниями. Если <p, x, q> ∈ ∆, то <p, x, q> называется переходом от p к q, а слово x называется меткой этого перехода. Пример: Пусть Q = {1, 2}, Σ = {a, b}, I = {2},\nF = {2}, ∆ = {<1, ааа, 1>, <1, ab, 2>, <1, b, 2>, <2, ε, 1>}. ТАК\n<Q, Σ, ∆,I,F> — конечный автомат.\nАлгоритм Томпсона (этот алгоритм преобразует NFA в эквивалентный DFA)\nАлгоритм преобразования DFA в регулярное выражение:\nАлгебраический метод Бжозовского\nПреобразование DFA в регулярное выражение создает систему регулярных выражений\nдля каждого состояния DFA, затем он решается для связанных с ним регулярных выражений Ri\nс конечными состояниями ци. Уравнение строится следующим образом: для каждого состояния qi уравнение Ri\nесть объединение переходов, приводящих к этому состоянию. Переход от a от qi к qj обозначается aRi. Если ци\nявляется конечным состоянием, то к Ri добавляется ε. Это приводит к системе уравнений вида:\n\nR1=a1∗R1+a2∗R2+a3∗R3+...\nR2=a1∗R1+a2∗R2+a3∗R3+...+ε\n...\nRm=a1∗R1+a2∗R2+a3∗R3+...+ε\n\nгде ax = ∅, если нет перехода от Ri к Rj. Система решается простой заменой: \nза исключением случаев, когда неизвестное появляется справа и слева от уравнения. \nДля этого можно воспользоваться теоремой Ардена:\n\nУравнение вида R=Q+RP, где P≠ε, имеет решение R=QP∗."
    },
    {
        "question": "Что такое преобразование конечного автомата в регулярное выражение",
        "answer": "Определение: регулярное выражение в алфавите Σ определяется рекурсивно следующим образом: 0 — регулярное выражение; 1 — регулярное выражение; Если\na ∈ Σ, то a — регулярное выражение; если e и f — регулярные выражения, то (e+f), (ef) и e∗ также являются\nявляются регулярными выражениями. Вместо e·f часто пишут просто ef.\nПример. Пусть Σ = {a, b}. Тогда ((a b)∗ (1+a)) есть\nрегулярное выражение в алфавите Σ.\nОпределение: Конечный автомат – это пятерка M = <Q, Σ, ∆,I,F>, где\nΣ — конечный алфавит, Q и ∆ — конечные множества,\n∆ ⊆ Q × Σ∗ × Q, I ⊆ Q, F ⊆ Q. Элементы Q называются состояниями, элементы I называются начальными состояниями,\nэлементы F являются окончательными или разрешающими состояниями. Если <p, x, q> ∈ ∆, то <p, x, q> называется\nпереход от p к q, а слово x является меткой этого\nпереход.\nПример: Пусть Q = {1, 2}, Σ = {a, b}, I = {2},\nF = {2}, ∆ = {<1, ааа, 1>, <1, ab, 2>, <1, b, 2>, <2, ε, 1>}. ТАК\n<Q, Σ, ∆,I,F> — конечный автомат.\nАлгоритм Томпсона (этот алгоритм преобразует NFA в эквивалентный DFA)\nАлгоритм преобразования DFA в RT:\nАлгебраический метод Бжозовского\nПреобразование DFA в регулярное выражение создает систему регулярных выражений \nдля каждого состояния DFA, затем он решается для связанных с ним регулярных выражений Ri \nс терминальными состояниями ци. Уравнение строится следующим образом: для каждого состояния qi уравнение Ri\nесть объединение переходов, приводящих к этому состоянию. Переход a от qi к qj обозначается aRi. Если ци\nявляется терминальным состоянием, то к Ri добавляется ε. Это приводит к системе уравнений вида:\n\nR1=a1∗R1+a2∗R2+a3∗R3+...\nR2=a1∗R1+a2∗R2+a3∗R3+...+ε\n...\nRm=a1∗R1+a2∗R2+a3∗R3+...+ε\n\nгде ax = ∅, если нет перехода от Ri к Rj. Эту систему можно решить простой заменой: \nза исключением случаев, когда неизвестное появляется справа и слева от уравнения. \nДля этого можно воспользоваться теоремой Ардена:\n\nУравнение вида R=Q+RP, где P≠ε, имеет решение R=QP∗."
    },
    {
        "question": "Что такое преобразование конечного автомата в регулярное выражение",
        "answer": "Определение: Регулярное выражение над алфавитом Σ определяется рекурсивно следующим образом: 0 — регулярное выражение; 1 — регулярное выражение; Если\na ∈ Σ, то a — регулярное выражение; если e и f — регулярные выражения, то (e+f), (ef) и e∗ также являются\nрегулярными выражениями. Вместо e f часто пишут просто ef.\nПример: Пусть Σ = {a, b}. Тогда ((a b)∗ (1+a)) — регулярное выражение над алфавитом Σ.\nОпределение: Конечный автомат — это пятерка M = <Q, Σ, ∆,I,F>, где\nΣ — конечный алфавит, Q и ∆ — конечные множества,\n∆ ⊆ Q × Σ∗ × Q, I ⊆ Q, F ⊆ Q. Элементы Q называются состояниями, элементы I называются начальными состояниями,\nэлементы F — конечными или разрешающими состояниями. Если <p, x, q> ∈ ∆, то <p, x, q> называется\nпереходом от p к q, а слово x — меткой этого\nперехода. Пример: Пусть Q = {1, 2}, Σ = {a, b}, I = {2},\nF = {2}, ∆ = {<1, ааа, 1>, <1, ab, 2>, <1, b, 2>, <2, ε, 1>}. SO\n<Q, Σ, ∆,I,F> — конечный автомат.\nАлгоритм Томпсона (этот алгоритм преобразует NFA в эквивалентный DFA)\nАлгоритм преобразования DFA в RT:\nАлгебраический метод Бжозовского\nПреобразование DFA в регулярное выражение создает систему регулярных выражений \nдля каждого состояния DFA, затем она решается для ее связанных регулярных выражений Ri \nс конечными состояниями qi. Уравнение строится следующим образом: для каждого состояния qi уравнение Ri\nявляется объединением переходов, ведущих в это состояние. Переход a из qi в qj обозначается как aRi. Если qi\nявляется конечным состоянием, то к Ri добавляется ε. Это приводит к системе уравнений вида:\n\nR1=a1∗R1+a2∗R2+a3∗R3+...\nR2=a1∗R1+a2∗R2+a3∗R3+...+ε\n...\nRm=a1∗R1+a2∗R2+a3∗R3+...+ε\n\nгде ax = ∅, если нет перехода из Ri в Rj. Эту систему можно решить простой подстановкой: \nза исключением случаев, когда неизвестное появляется в правой и левой частях уравнения. \nДля этого можно воспользоваться теоремой Ардена:\n\nУравнение вида R=Q+RP, где P≠ε, имеет решение R=QP∗."
    },
    {
        "question": "Контекстно-свободная (КС) грамматика это",
        "answer": "КС грамматика - это грамматика, у которой в левых частях всех правил стоят только одиночные нетерминалы.\nЯзык, задаваемый контекстно-свободной грамматикой, называется контекстно-свободным языком.\nКС-грамматика: G = <N, ∑, P, S>, где правила имеют вид: A → β, где β ∈ (N + ∑)*"
    },
    {
        "question": "Контекстно-свободная (CF) грамматика — это",
        "answer": "Контекстно-свободная грамматика — это грамматика, в которой левые части всех правил содержат только одиночные нетерминалы.\nЯзык, определенный контекстно-свободной грамматикой, называется контекстно-свободным языком.\nКонтекстно-свободная грамматика: G = <N, ∑, P, S>, где правила имеют вид: A → β, где β ∈ (N + ∑)*"
    },
    {
        "question": "Контекстно-свободная грамматика (CF) – это",
        "answer": "Контекстно-свободная грамматика — это такая грамматика, в которой левые части всех правил содержат только один нетерминал.\nЯзык, определяемый контекстно-свободной грамматикой, называется контекстно-свободным языком.\nГрамматика вне контекста: G = <N, ∑, P, S>, где правила: A → β, где β ∈ (N + ∑)*"
    },
    {
        "question": "Контекстно-свободная грамматика (CF) – это",
        "answer": "Грамматика KS — это такая грамматика, в которой левые части всех правил содержат только уникальные нетерминалы.\nЯзык, определяемый контекстно-свободной грамматикой, называется контекстно-свободным языком.\nГрамматика КС: G = <N, ∑, P, S>, где правила: A → β, где β ∈ (N + ∑)*"
    },
    {
        "question": "Контекстно-свободная грамматика (CF) — это",
        "answer": "Грамматика KS — это грамматика, в которой левые части всех правил содержат только уникальные нетерминалы.\nЯзык, определенный контекстно-свободной грамматикой, называется контекстно-свободным языком.\nГрамматика KS: G = <N, ∑, P, S>, где правила: A → β, где β ∈ (N + ∑)*"
    },
    {
        "question": "Левосторонний (Левый) вывод в КС грамматике это",
        "answer": "Вывод в КС-грамматике левосторонний (левый), если на каждом шаге вывода заменяется самое левое из всех вхождений нетерминальных символов, \nто есть каждый шаг вывода имеет вид: uAθ —> uβθ, где (A → β) ∈ P, A ∈ N и θ ∈ (N U ∑)*, u ∈ ∑*.\nЛевосторонний вывод однозначно восстанавливается по дереву вывода."
    },
    {
        "question": "Левосторонний (левый) вывод в грамматике CS — это",
        "answer": "Выход в CFG является левосторонним (левосторонним), если на каждом шаге вывода заменяется самое левое из всех вхождений нетерминальных символов, \nто есть каждый шаг вывода имеет вид: uAθ —> uβθ, где (A → β) ∈ P, A ∈ N и θ ∈ (N U ∑)*, u ∈ ∑*. \nЛевосторонний выход однозначно восстанавливается из выходного дерева."
    },
    {
        "question": "Левосторонний (левый) вывод в грамматике CS:",
        "answer": "Вывод в CFG является левым (левым), если на каждом этапе вывода заменяется самый левый из всех вхождений нетерминальных символов, \nт. е. каждый выходной шаг имеет вид: uAθ -> uβθ, где (A → β) € P, A € N и θ € (N U ∑)*, u € ∑*. \nЛевый результат однозначно восстанавливается из выходного дерева."
    },
    {
        "question": "Левосторонний (левый) вывод в грамматике CS:",
        "answer": "Вывод в грамматике KS является левым (левым), если на каждом шаге заменяется самый левый вывод всех вхождений нетерминальных символов, \nт. е. каждый выходной шаг имеет вид: uAθ -> uβθ, где (A → β) € P, A € N и θ € (N U ∑)*, u € ∑*.\nВыходные данные левой части однозначно реконструируются из дерева вывода."
    },
    {
        "question": "Левосторонний (левосторонний) вывод в грамматике CS:",
        "answer": "Вывод в грамматике KS является левосторонним (левосторонним), если на каждом шаге заменяется самый левый вывод всех вхождений нетерминальных символов, \nт. е. каждый шаг вывода имеет вид: uAθ -> uβθ, где (A → β) € P, A € N и θ € (N U ∑)*, u € ∑*. \nВывод левой части однозначно восстанавливается из выходного дерева."
    },
    {
        "question": "Леворекурсивная КС грамматика это",
        "answer": "Леворекурсивная грамматика - это грамматика, в которой есть нетерминал, который может быть заменен на себя самого в левом направлении, то есть грамматика, имеющая хотя бы один леворекурсивный нетерминал.\n"
    },
    {
        "question": "Леворекурсивная грамматика CS — это",
        "answer": "Леворекурсивная грамматика — это грамматика, в которой есть нетерминал, который может быть заменен самим собой в левом направлении, то есть грамматика, которая имеет по крайней мере один леворекурсивный нетерминал."
    },
    {
        "question": "Леворекурсивная грамматика CS:",
        "answer": "Леворекурсивная грамматика — это грамматика, имеющая нетерминал, который можно заменить на себя в левом направлении, то есть грамматика, имеющая хотя бы один леворекурсивный нетерминал."
    },
    {
        "question": "Леворекурсивная грамматика KS:",
        "answer": "Леворекурсивная грамматика — это та, в которой существует нетерминал, который можно заменить самим собой в левом направлении, то есть грамматика, имеющая хотя бы один леворекурсивный нетерминал."
    },
    {
        "question": "Леворекурсивная грамматика KS:",
        "answer": "Леворекурсивная грамматика — это грамматика, в которой существует нетерминал, который может быть заменен самим собой в левом направлении, то есть грамматика, которая имеет по крайней мере один леворекурсивный нетерминал."
    },
    {
        "question": "Праворекурсивная КС грамматика это",
        "answer": "Праворекурсивная грамматика - это грамматика, в которой есть нетерминал, который может быть заменен на себя самого в правом направлении, то есть грамматика, имеющая хотя бы один праворекурсивный нетерминал.\n"
    },
    {
        "question": "Праворекурсивная грамматика CS — это",
        "answer": "Праворекурсивная грамматика — это грамматика, в которой есть нетерминал, который может быть заменен самим собой в правильном направлении, то есть грамматика, в которой есть хотя бы один праворекурсивный нетерминал."
    },
    {
        "question": "Правильная рекурсивная грамматика CS:",
        "answer": "Праворекурсивная грамматика — это грамматика, в которой есть нетерминал, который можно заменить самим собой в правильном направлении, то есть грамматика, в которой есть хотя бы один рекурсивный нетерминал справа."
    },
    {
        "question": "Правильная рекурсивная грамматика KS:",
        "answer": "Праворекурсивная грамматика — это грамматика, в которой есть нетерминал, который можно заменить самим собой в нужном направлении, то есть грамматика, имеющая хотя бы один праворекурсивный нетерминал."
    },
    {
        "question": "Правильная рекурсивная грамматика KS:",
        "answer": "Праворекурсивная грамматика — это грамматика, в которой есть нетерминал, который может быть заменен самим собой в желаемом направлении, то есть грамматика, в которой есть хотя бы один праворекурсивный нетерминал."
    },
    {
        "question": "Рекурсивная КС грамматика это\n",
        "answer": "Рекурсивная грамматика - это грамматика,  в которой все нетерминалы рекурсивные (кроме, может быть, S).\n"
    },
    {
        "question": "Рекурсивная грамматика CS — это",
        "answer": "Рекурсивная грамматика — это грамматика, в которой все нетерминалы являются рекурсивными (за исключением, возможно, S)."
    },
    {
        "question": "Рекурсивная грамматика CS",
        "answer": "Рекурсивная грамматика — это такая грамматика, в которой все нетерминалы рекурсивны (за исключением, возможно, S)."
    },
    {
        "question": "Рекурсивная грамматика KS",
        "answer": "Рекурсивная грамматика — это такая грамматика, в которой все нетерминалы рекурсивны (за исключением, возможно, S)."
    },
    {
        "question": "Рекурсивная грамматика КС",
        "answer": "Рекурсивная грамматика — это грамматика, в которой все нетерминалы являются рекурсивными (за исключением, возможно, S)."
    },
    {
        "question": "Бесполезный символ (нетерминал) в КС грамматике это\n",
        "answer": "Символ D (нетерминал) - бесполезный, если в грамматике нет вывода вида S → *wDy → *wvy, где v, w, y ∈ ∑*\n"
    },
    {
        "question": "Бесполезный символ (нетерминал) в грамматике CS — это",
        "answer": "Символ D (нетерминал) бесполезен, если грамматика не имеет вывода вида S → *wDy → *wvy, где v, w, y ∈ ∑*"
    },
    {
        "question": "Ненужный (нетерминальный) символ в грамматике CS — это",
        "answer": "Символ D (нетерминальный) бесполезен, если грамматика не имеет вывода в виде S → *wDy → *wvy, где v, w, y ∈ ∑*"
    },
    {
        "question": "Ненужным (нетерминальным) символом в грамматике KS является",
        "answer": "Символ D (нетерминальный) бесполезен, если грамматика не имеет вывода вида S → *wDy → *wvy, где v, w, y ∈ ∑*"
    },
    {
        "question": "Ненужный (нетерминальный) символ в грамматике KS — это",
        "answer": "Символ D (нетерминальный) бесполезен, если грамматика не имеет вывода вида S → *wDy → *wvy, где v, w, y ∈ ∑*"
    },
    {
        "question": "Неукорачивающая КС грамматика это\n",
        "answer": "Неукорачивающая КС грамматика -  это грамматика, которая может производить бесконечно длинные строки, то есть грамматика без ε-правил. Пример неукорачивающей КС грамматики: S → aSb | a.\n"
    },
    {
        "question": "Неконтрактная грамматика KS — это",
        "answer": "Неконтрактующая CF-грамматика — это грамматика, которая может производить бесконечно длинные строки, т. е. грамматика без ε-правил. Пример неконтрактующей CF-грамматики: S → aSb | a."
    },
    {
        "question": "Внедоговорная грамматика KS – это",
        "answer": "Недоговорная CF-грамматика — это грамматика, которая может создавать бесконечно длинные строки, то есть грамматика без ε-правил. Пример бездоговорной грамматики CF: S → aSb | А."
    },
    {
        "question": "Неусеченная грамматика KS",
        "answer": "CS-грамматика без сокращения — это грамматика, которая может создавать бесконечно длинные строки, то есть грамматика без ε-правил. Пример грамматики CS без сокращения: S → aSb | А."
    },
    {
        "question": "Необрезанная грамматика KS",
        "answer": "Грамматика CS без сокращения — это грамматика, которая может производить бесконечно длинные строки, т. е. грамматика без ε-правил. Пример грамматики CS без сокращения: S → aSb | A."
    },
    {
        "question": "КС грамматика с цепным правилом это",
        "answer": "КС грамматика с цепным правилом - это КС грамматика, в которой есть правило вида A → B, где A, B ∈ N. Имеет правило замены, которое содержит цепочку нетерминалов.\nПример КС грамматики с цепным правилом: \nS → aBb | ε\nB → bB | a"
    },
    {
        "question": "Грамматика KS с цепным правилом",
        "answer": "Правило цепочки CFG — это CFG, которое имеет правило вида A → B, где A, B ∈ N. Оно имеет правило подстановки, которое содержит цепочку нетерминалов.\nПример правила цепочки CFG:\nS → aBb | ε\nB → bB | a"
    },
    {
        "question": "Грамматика KS с цепным правилом",
        "answer": "Цепное правило CFG — это CFG, имеющее правило вида A → B, где A, B ∈ N. Оно имеет правило подстановки, содержащее цепочку нетерминалов.\nПример правила цепочки CFG:\nS → abBb | ε\nБ → ББ | А"
    },
    {
        "question": "Грамматика KS с правилом цепочки:",
        "answer": "CS-грамматикой с цепным правилом называется CS-грамматика, в которой существует правило вида A → B, где A, B ∈ N. Она имеет правило замены, содержащее цепочку нетерминалов.\nПример грамматики CS с цепным правилом: \nS → abBb | ε\nБ → ББ | А"
    },
    {
        "question": "Грамматика KS с цепочным правилом:",
        "answer": "Грамматика CS с цепным правилом — это грамматика CS, в которой есть правило вида A → B, где A, B ∈ N. Она имеет правило подстановки, содержащее цепочку нетерминалов.\nПример грамматики CS с цепным правилом:\nS → abBb | ε\nБ → ББ | А"
    },
    {
        "question": "КС грамматика без циклов",
        "answer": "КС грамматика без циклов - это КС грамматика, в которой нет правила: A → +A. То есть грамматика, которая не содержит циклов (кроме возможных циклов в терминальных символах), то есть, нетерминалы не могут быть заменены на себя самого через любое количество шагов.\nПример КС грамматики без циклов:\nS → aAb | ε\nA → b | c"
    },
    {
        "question": "Грамматика КС без циклов",
        "answer": "Грамматика KS без циклов — это грамматика KS, в которой нет правила: A → +A. То есть грамматика, в которой нет циклов (за исключением возможных циклов в терминальных символах), то есть нетерминалы не могут быть заменены самими собой после любого количества шагов.\nПример грамматики KS без циклов:\nS → aAb | ε\nA → b | c"
    },
    {
        "question": "Грамматика КС без циклов",
        "answer": "Грамматика КС без циклов — это грамматика КС, в которой нет правила: A → +A. То есть грамматика, в которой нет циклов (за исключением возможных циклов в терминальных символах), т.е. нетерминалы не могут быть заменены самими собой после определенного количества шагов.\nПример грамматики KS без циклов:\nS → аАб | ε\nА → б | с"
    },
    {
        "question": "Грамматика КС без циклов",
        "answer": "Грамматика КС без циклов — это грамматика КС, в которой нет правила: A → +A. То есть грамматика, не содержащая циклов (за исключением возможных циклов в терминальных символах), т.е. нетерминалы не могут быть ими заменены - даже через определенное количество шагов.\nПример грамматики CS без циклов:\nS → аАб | ε\nА → б | с"
    },
    {
        "question": "Грамматика CS без циклов",
        "answer": "Грамматика CS без циклов — это грамматика CS, в которой нет правила: A → +A. То есть грамматика, в которой нет циклов (за исключением возможных циклов в терминальных символах), т. е. нетерминалы не могут быть ими заменены — даже после определенного количества шагов.\nПример грамматики CS без циклов:\nS → аАб | ε\nA → б | с"
    },
    {
        "question": "Приведённая КС грамматика это",
        "answer": "Приведённая КС грамматика - это грамматика без циклов, без бесполезных символов и без цепных правил.\n"
    },
    {
        "question": "Грамматика, данная КС, такова:",
        "answer": "Грамматика, предлагаемая КС, — это грамматика без циклов, без бесполезных символов и без цепочечных правил."
    },
    {
        "question": "Грамматика, заданная QS, такова:",
        "answer": "Грамматика, предложенная К.С., представляет собой грамматику без петель, без лишних символов и без цепных правил."
    },
    {
        "question": "Грамматика, данная KS,",
        "answer": "Грамматика, данная К.С., — это грамматика без циклов, без лишних символов и без цепных правил."
    },
    {
        "question": "Грамматика, данная КС,",
        "answer": "Грамматика, данная К.С., — это грамматика без циклов, без лишних символов и без цепочных правил."
    },
    {
        "question": "Алгоритм удаления бесполезных (непорождающих) символов в КС грамматике",
        "answer": "1. Берём все правила, в правой части которых есть хотя бы один терминал. Берём оттуда\nмножество всех терминалов и нетерминалов слева.\n2. Берём все правила, в правой части которых встречаются нетерминалы только из нашего\nмножества. Добавляем нетерминалы слева в наше множество. Повторяем.\n3. На каком то шаге множество стабилизируется (все выводимые правила будут учтены). В нашем\nмножестве остались терминалы и все небесполезные нетерминалы.\n4. Берём разность всех нетерминалов и нетерминалов из нашего построенного множества. Это\nбудут бесполезные нетерминалы.\n5. Удаляем все правила, в которых встречаются бесполезные нетерминалы"
    },
    {
        "question": "Алгоритм удаления бесполезных (негенерирующих) символов в грамматике КС",
        "answer": "1. Берем все правила, в которых есть хотя бы один терминал в правой части. Берем оттуда\nмножество всех терминалов и нетерминалов слева.\n2. Берем все правила с нетерминалами только из нашего\nмножества в правой части. Добавляем нетерминалы слева в наше множество. Повторяем.\n3. На каком-то этапе множество стабилизируется (будут учтены все выходные данные правил). Терминалы и все полезные нетерминалы остаются в нашем\nмножестве.\n4. Берем разницу между всеми нетерминалами и нетерминалами из нашего построенного множества. Это будут бесполезные нетерминалы.\n5. Удаляем все правила с бесполезными нетерминалами"
    },
    {
        "question": "Алгоритм удаления ненужных (негенерирующих) символов в грамматике CS",
        "answer": "1. Возьмите все линейки, у которых есть хотя бы одна клемма с правой стороны. Пойдем оттуда\nнабор всех терминалов и нетерминалов слева.\n2. Все правила с нетерминалами берем только свои\nставится с правой стороны. Добавляем в наш набор нетерминалы слева. Повторяем.\n3. В какой-то момент все стабилизируется (будут учтены все выходные данные правила). Терминалы и все полезные нетерминалы остаются у нас.\nмного.\n4. Берем разницу между всеми нетерминалами и всеми нетерминалами в нашем построенном множестве. Это будут бесполезные нетерминалы.\n5. Удалить все правила с ненужными нетерминалами"
    },
    {
        "question": "Алгоритм удаления ненужных (негенерирующих) символов в КС-грамматике",
        "answer": "1. Возьмите все линейки, у которых есть хотя бы одна клемма с правой стороны. Пойдем оттуда\nнабор всех терминалов и нетерминалов слева.\n2. Берём все правила, в правой части которых есть нетерминалы только нашего\nмножества. Добавляем в наш набор нетерминалы слева. Повторяем.\n3. В какой-то момент все стабилизируется (будут учтены все производные правила). В нашем\nТерминалов и всего полезного нетерминала еще полно.\n4. Возьмите разность всех нетерминалов и нетерминалов в нашем построенном множестве. Этот\nбудут ненужные нетерминалы.\n5. Удалить все правила, содержащие ненужные нетерминалы."
    },
    {
        "question": "Алгоритм удаления ненужных (негенерирующих) символов в грамматике CF",
        "answer": "1. Берем все строки, которые имеют хотя бы один терминал с правой стороны. Давайте перейдем оттуда\nк набору всех терминалов и нетерминалов слева.\n2. Берем все правила, которые имеют нетерминалы только нашего\nнабора с правой стороны. Добавляем нетерминалы слева к нашему набору. Повторяем.\n3. В какой-то момент все стабилизируется (все производные правила будут учтены). Наш\nЕсть еще много терминалов и всех полезных нетерминалов.\n4. Берем разницу между всеми нетерминалами и нетерминалами в нашем построенном наборе. Это будут ненужные нетерминалы.\n5. Удаляем все правила, содержащие ненужные нетерминалы."
    },
    {
        "question": "Алгоритм удаления недостижимых символов",
        "answer": "1. Берём множество, состоящее из S.\n2. Добавляем в наше множество все нетерминалы и терминалы, которые стоят в правой части\nправил, в левой части которых нетерминалы из нашего множества.\n3. На каком-то шаге множество стабилизируется (все выводимые правила будут учтены). В нашем\nмножестве остались только достижимые символы (терминалы и нетерминалы).\n4. Берём разность всех нетерминалов и нетерминалов из нашего построенного множества. Это\nбудут бесполезные нетерминалы. То же самое и с терминалами.\n5. Удаляем все правила, в которых встречаются бесполезные нетерминалы. То же самое и с терминалами."
    },
    {
        "question": "Алгоритм удаления недоступных символов",
        "answer": "1. Берем набор, состоящий из S.\n2. Добавляем к нашему набору все нетерминалы и терминалы, которые находятся справа от правил, которые имеют нетерминалы из нашего набора слева.\n3. На каком-то шаге набор стабилизируется (будут учтены все выводимые правила). В нашем наборе остаются только достижимые символы (терминалы и нетерминалы).\n4. Берем разницу между всеми нетерминалами и нетерминалами из нашего построенного набора. Это будут бесполезные нетерминалы. То же самое с терминалами.\n5. Удаляем все правила, которые содержат бесполезные нетерминалы. То же самое с терминалами."
    },
    {
        "question": "Алгоритм удаления недоступных символов",
        "answer": "1. Возьмем набор, состоящий из S.\n2. Добавляем в наш набор все нетерминалы и терминалы, находящиеся справа от правил, у которых есть нетерминалы из нашего набора слева.\n3. В данный момент целое стабилизируется (будут учтены все производные правила). В нашем наборе остаются только доступные символы (терминальные и нетерминальные).\n4. Берем разницу между всеми нетерминалами и всеми нетерминалами в нашем построенном множестве. Это будут бесполезные нетерминалы. То же самое и с терминалами.\n5. Удалить все правила, содержащие ненужные нетерминалы. То же самое и с терминалами."
    },
    {
        "question": "Алгоритм удаления недоступных символов",
        "answer": "1. Возьмем набор, состоящий из S.\n2. Добавляем в наш набор все неклеммы и клеммы, которые находятся с правой стороны\nправила, в левой части которых находятся нетерминалы нашего набора.\n3. В какой-то момент все стабилизируется (будут учтены все производные правила). В нашем\nВ наборе остаются только доступные символы (терминальные и нетерминальные).\n4. Возьмите разность всех нетерминалов и нетерминалов в нашем построенном множестве. Этот\nбудут ненужные нетерминалы. То же самое и с терминалами.\n5. Удалить все правила, содержащие ненужные нетерминалы. То же самое и с терминалами."
    },
    {
        "question": "Алгоритм удаления недоступных символов",
        "answer": "1. Берем набор, состоящий из S.\n2. Добавляем к нашему набору все нетерминалы и терминалы, которые находятся в правой части\nправила, которое имеет нетерминалы нашего набора в левой части.\n3. В какой-то момент все стабилизируется (будут учтены все производные правила). В нашем\nВ наборе остаются только доступные символы (терминал и нетерминал).\n4. Берем разницу между всеми нетерминалами и нетерминалами в нашем построенном наборе. Это будут ненужные нетерминалы. То же самое с терминалами.\n5. Удаляем все правила, содержащие ненужные нетерминалы. То же самое с терминалами."
    },
    {
        "question": "Алгоритм удаления ε-правил",
        "answer": "1. Нашли все ε-правила. Добавили в множество нетерминалы из левых частей этих ε-правил.\n2. Заменили во всех правилах нетерминалы из нашего множества на ε.\n3. Убрали все ε (ε^n = ε).\n4. Повторяем с шага 1, пока можем найти новые ε-правила.\n5. Для всех правил вида A → B, где для B существует ε-правило, добавим правила вида A → ε, если таких еще нет.\n6. Удаляем все изначальные ε-правила (т.е. те, которые нашли на 1-ом шаге).\n================================================================"
    },
    {
        "question": "Алгоритм удаления ε-правил",
        "answer": "1. Нашли все ε-правила. Добавили нетерминалы из левых частей этих ε-правил в набор.\n2. Заменили нетерминалы из нашего набора на ε во всех правилах.\n3. Удалили все ε (ε^n = ε).\n4. Повторяем с шага 1, пока не найдем новые ε-правила.\n5. Для всех правил вида A → B, где есть ε-правило для B, добавляем правила вида A → ε, если их еще нет.\n6. Удалили все начальные ε-правила (т. е. найденные на шаге 1).\n=============================================================================="
    },
    {
        "question": "Алгоритм удаления ε правил",
        "answer": "1. Найдены все ε правил. Мы добавили в множество нетерминалы левых частей этих правил ε.\n2. Замена нетерминалов нашего множества на ε во всех правилах.\n3. Удаление всех ε (ε^n = ε).\n4. Повторяем начиная с шага 1, пока не найдем новые ε правила.\n5. Ко всем правилам вида A → B, где существует ε-правило для B, добавить правила вида A → ε, если они еще не существуют.\n6. Удалите все исходные правила ε (т. е. те, которые были найдены на шаге 1).\n=============================================== == = === ==========================="
    },
    {
        "question": "Алгоритм удаления ε правил",
        "answer": "1. Найдены все ε правил. Мы добавили в множество нетерминалы левых частей этих правил ε.\n2. Замена нетерминалов нашего множества на ε во всех правилах.\n3. Удаление всех ε (ε^n = ε).\n4. Повторяем шаг 1, пока не найдем новые правила ε.\n5. Ко всем правилам вида A → B, где существует ε-правило для B, добавим правила вида A → ε, если они еще не существуют.\n6. Удаляем все исходные ε-правила (т.е. найденные на 1-м шаге).\n=============================================== == = === =============="
    },
    {
        "question": "Алгоритм удаления ε правил",
        "answer": "1. Найдены все правила ε. Мы добавили нетерминалы левых частей этих правил ε в набор.\n2. Заменяем нетерминалы нашего набора на ε во всех правилах.\n3. Удаляем все ε (ε^n = ε).\n4. Повторяем шаг 1, пока не найдем новые правила ε.\n5. Ко всем правилам вида A → B, где есть ε-правило для B, добавляем правила вида A → ε, если их еще нет.\n6. Удаляем все исходные ε-правила (т. е. найденные на шаге 1).\n================================================== == ================"
    },
    {
        "question": "Алгоритм удаления цепного правила",
        "answer": "Если встретилось цепное правило A → B, и в P есть правило вида B → α, α ∈ (N + ∑)*, то добавим правило A → α, а правило A → B вычеркнем.\n"
    },
    {
        "question": "Алгоритм удаления цепного правила",
        "answer": "Если мы встречаем цепочку правил A → B, а в P есть правило вида B → α, α ∈ (N + ∑)*, то мы добавляем правило A → α, а правило A → B вычеркиваем."
    },
    {
        "question": "Алгоритм удаления правил цепочки",
        "answer": "Если мы встречаем цепочку правил A → B и P содержит правило вида B → α, α ∈ (N + ∑)*, то добавляем правило A → α и вычеркиваем правило A → B."
    },
    {
        "question": "Алгоритм удаления правил цепочки",
        "answer": "Если мы встречаем цепное правило A → B и P имеет правило вида B → α, α ∈ (N + ∑)*, то мы добавляем правило A → α и удаляем правило A → B."
    },
    {
        "question": "Алгоритм удаления цепочечных правил",
        "answer": "Если мы сталкиваемся с цепочкой правил A → B и P имеет правило вида B → α, α ∈ (N + ∑)*, то мы добавляем правило A → α и удаляем правило A → B."
    },
    {
        "question": "напиши лемму Ардена",
        "answer": "Пусть X = (pX) | q, где X — неизвестное RE, а p, q —\nизвестные, причём ε /∈ L (p). Тогда X = (p)\n∗q.\nТо есть p\n∗q — наименьшая (но не единственная) неподвижная\nточка выражения px | q по отношению ⩽, и единственная, если\nε /∈ L (p)."
    },
    {
        "question": "написать лемму Ардена",
        "answer": "Пусть X = (pX) | q, где X — неизвестное РЭ, а p, q известны, причем ε /∈ L (p). Тогда X = (p)\n∗q.\nТо есть, p\n∗q — наименьшая (но не единственная) неподвижная\nточка px | q относительно ⩽, и единственная, если\nε /∈ L (p)."
    },
    {
        "question": "напиши лемму Ардена",
        "answer": "Пусть X = (pX) | q, где X — неизвестная РЭ, а p, q известны и ε /ε L (p). Тогда X = (p)\n∗q.\nТо есть п\n∗q — наименьшая (но не единственная) фиксированная\nточка пикселей | q относительно ⩽ и единственна, если\nε /ε L (p)."
    },
    {
        "question": "напиши лемму Ардена",
        "answer": "Пусть X = (pX) | q, где X — неизвестное RE, а p, q —\nизвестны и ε /ε L (p). Тогда X = (p)\n∗q.\nТо есть п\n∗q — наименьшая (но не единственная) фиксированная\nточка выражения px | q относительно ⩽ и единственна, если\nε /ε L (p)."
    },
    {
        "question": "написать лемму Ардена",
        "answer": "Пусть X = (pX) | q, где X — неизвестное RE, а p, q известны и ε /ε L (p). Тогда X = (p) ∗q. То есть, n ∗q — наименьшая (но не единственная) неподвижная точка выражения px | q относительно ⩽ и единственная, если ε /ε L (p)."
    },
    {
        "question": "Сформулируй теорему о замкнутости регулярных языыков",
        "answer": "Пусть L1,L2\n — регулярные языки над одним алфавитом Σ. Тогда следующие языки также являются регулярными:\n Языки, полученные путём применения следующих теоретико-множественных операций:\n L1∪L2,\n L1¯¯¯¯¯¯,\n L1∩L2,\n L1∖L2;\n L∗1;\n L1L2; \n L1←;"
    },
    {
        "question": "Сформулируйте теорему о закрытии регулярных языков.",
        "answer": "Пусть L1,L2\nбудут регулярными языками над одним алфавитом Σ. Тогда следующие языки также являются регулярными:\nЯзыки, полученные применением следующих теоретико-множественных операций:\nL1∪L2,\nL1¯¯¯¯¯¯¯,\nL1∩L2,\nL1∖L2;\nL∗1;\nL1L2;\nL1←;"
    },
    {
        "question": "Сформулируйте теорему замыкания для регулярных языков.",
        "answer": "Пусть L1,L2\nбудут регулярными языками на одном алфавите Σ. Тогда регулярными являются также следующие языки:\nЯзыки получены применением следующих операций теории множеств:\nЛ1∪Л2,\nL1¯¯¯¯¯¯¯¯,\nЛ1∩Л2,\nЛ1∖Л2;\nL∗1;\nЛ1Л2;\nЛ1 ←;"
    },
    {
        "question": "Сформулируйте теорему о замыкании регулярных языков.",
        "answer": "Пусть L1,L2\n — регулярные языки на алфавите Σ. Тогда регулярными являются также следующие языки:\n Языки получены применением следующих операций теории множеств:\n Л1∪Л2,\n Л1¯¯¯¯¯¯¯,\n Л1∩Л2,\n Л1∖Л2;\n L∗1;\n Л1Л2; \n Л1 ←;"
    },
    {
        "question": "Сформулируйте теорему о замкнутости регулярных языков.",
        "answer": "Пусть L1,L2\n— регулярные языки на алфавите Σ. Тогда следующие языки также регулярны:\nЯзыки получаются применением следующих операций теории множеств:\nЛ1∪Л2,\nЛ1¯¯¯¯¯¯¯¯,\nЛ1∩Л2,\nЛ1∖Л2;\nL∗1;\nЛ1Л2;\nЛ1 ←;"
    },
    {
        "question": "Сформулируй теоремы о построении LL(k) грамматики без пустых правил",
        "answer": "еорема 1 \nДля всякой LL(k)-\nграмматики существует и может быть эффективно построена LL(k + 1)-грамматика\nбез пустых правил, задающая тот же язык.\n\nТеорема 2 \nДля всякой LL(k)-грамматики без пустых правил можно построить LL(k)-грамматику в н.в.Грейбах, задающую тот же язык."
    },
    {
        "question": "Сформулировать теоремы о построении грамматик LL(k) без пустых правил.",
        "answer": "теорема 1\n\nДля каждой LL(k)-\nграмматики существует и может быть эффективно построена LL(k + 1)-грамматика\nбез пустых правил, которая определяет тот же язык. \n\nТеорема 2\n\nДля каждой LL(k)-грамматики без пустых правил можно построить LL(k)-грамматику в Н. В. Грейбахе, которая определяет тот же язык."
    },
    {
        "question": "Сформулируйте теоремы о построении LL(k)-грамматик без пустых правил.",
        "answer": "Теорема 1\n\nДля каждого LL(k)-\nграмматика существует, и грамматику LL(k + 1) можно эффективно построить\nбез пустых правил, что определяет один и тот же язык. \n\nТеорема 2\n\nДля каждой LL(k)-грамматики без пустых правил можно построить LL(k)-грамматику Н.В. Грейбаха, определяющую тот же язык."
    },
    {
        "question": "Сформулируйте теоремы о построении LL(k)-грамматики без пустых правил.",
        "answer": "Теорема 1 \nДля всех LL(k)-\nграмматика существует, и грамматику LL(k + 1) можно эффективно построить\nбез пустых правил, определяющих один и тот же язык.\n\nТеорема 2 \nДля любой LL(k)-грамматики без пустых правил можно построить LL(k)-грамматику в Н.В.Грейбахе, определяющую тот же язык."
    },
    {
        "question": "Сформулируйте теоремы о построении LL(k)-грамматики без пустых правил.",
        "answer": "Теорема 1\nДля всех LL(k)-\nграмматик существует, и LL(k + 1) грамматика может быть эффективно построена\nбез пустых правил, определяющих тот же язык.\n\nТеорема 2\nДля любой LL(k)-грамматики без пустых правил, LL(k)-грамматика в Н.В.Грейбахе может быть построена, определяющая тот же язык."
    },
    {
        "question": "Сформулируй лемму Розенкранца и Стирнса для обыкновенной грамматики",
        "answer": "Лемма 1 (Розенкранц и Стирнс [1970]). Для всякой обыкновенной грамматики G =\n(Σ, N, R, S), существует другая грамматика G0 = (Σ, N ∪ N0, R0, S0), где N0 = { A0| A ∈\nN }, удовлетворяющая следующим условиям.\n1. Всякий нетерминальный символ A ∈ N задаёт в G0 тот же язык, что и в G.\n2. Всякий нетерминальный символ A0 ∈ N в G0\nзадаёт тот же язык, что и в G, с\nисключённой пустой строкой: LG0(A0) = LG(A0) \\ {ε}. В частности, L(G0) = L(G) \\{ε}.\n3. Никакое правило из R0 не начинается с нетерминального символа из N.\n4. Если G — LL(k), то и G0 — тоже LL(k)."
    },
    {
        "question": "Сформулируйте лемму Розенкранца-Стернса для обычной грамматики.",
        "answer": "Лемма 1 (Розенкранц и Стернс [1970]). Для каждой обычной грамматики G = (Σ, N, R, S) существует другая грамматика G0 = (Σ, N ∪ N0, R0, S0), где N0 = { A0| A ∈\nN }, удовлетворяющая следующим условиям.\n1. Каждый нетерминальный символ A ∈ N определяет в G0 тот же язык, что и в G.\n2. Каждый нетерминальный символ A0 ∈ N в G0\nопределяет тот же язык, что и в G, с\nисключенной пустой строкой: LG0(A0) = LG(A0) \\ {ε}. В частности, L(G0) = L(G) \\ {ε}.\n3. Ни одно правило из R0 не начинается с нетерминального символа из N.\n4. Если G есть LL(k), то G0 также есть LL(k)."
    },
    {
        "question": "Сформулируйте лемму Розенкранца-Стернса для обычной грамматики.",
        "answer": "Лемма 1 (Розенкранц и Стернс [1970]). Для каждой обычной грамматики G = (Σ, N, R, S) существует другая грамматика G0 = (Σ, N ∪ N0, R0, S0), где N0 = { A0| А €\nN }, удовлетворяющий следующим условиям.\n1. Любой нетерминальный символ A ∈ N определяет в G0 тот же язык, что и в G.\n2. Любой нетерминальный символ A0 ∈ N в G0\nопределяет тот же язык, что и в G, с\nисключается пустой строкой: LG0(A0) = LG(A0) \\ {ε}. В частности, L(G0) = L(G) \\ {ε}.\n3. Ни одно правило R0 не начинается с нетерминального символа N.\n4. Если G — это LL(k), то G0 — это тоже LL(k)."
    },
    {
        "question": "Сформулируйте лемму Розенкранца и Стернса для обычной грамматики.",
        "answer": "Лемма 1 (Розенкранц и Стернс [1970]). Для любой обычной грамматики G =\n(Σ, N, R, S) существует другая грамматика G0 = (Σ, N ∪ N0, R0, S0), где N0 = { A0| А €\nN }, удовлетворяющий следующим условиям.\n1. Любой нетерминальный символ A ∈ N определяет в G0 тот же язык, что и в G.\n2. Любой нетерминальный символ A0 ∈ N в G0\nопределяет тот же язык, что и в G, с\nисключается пустой строкой: LG0(A0) = LG(A0) \\ {ε}. В частности, L(G0) = L(G) \\{ε}.\n3. Ни одно правило R0 не начинается с нетерминального символа N.\n4. Если G — это LL(k), то G0 — это тоже LL(k)."
    },
    {
        "question": "Сформулируйте лемму Розенкранца и Стернса для обычной грамматики.",
        "answer": "Лемма 1 (Розенкранц и Стернс [1970]). Для любой обычной грамматики G =\n(Σ, N, R, S) существует другая грамматика G0 = (Σ, N ∪ N0, R0, S0), где N0 = { A0| A €\nN }, удовлетворяющая следующим условиям.\n1. Каждый нетерминальный символ A ∈ N определяет тот же язык в G0, что и в G.\n2. Каждый нетерминальный символ A0 ∈ N в G0\nопределяет тот же язык, что и в G, за исключением\nпустой строки: LG0(A0) = LG(A0) \\ {ε}. В частности, L(G0) = L(G) \\ {ε}.\n3. Ни одно правило R0 не начинается с нетерминального символа N.\n4. Если G есть LL(k), то G0 есть LL(k)."
    },
    {
        "question": "Напиши теорему о непересекающемся объединении LL(k)-языков",
        "answer": "Теорема (О непересекающемся объединении LL(k)-языков: Розенкранц и Стирнс [1970]).\nПусть L1, . . . , Ln ⊆ Σ\n∗ — попарно непересекающиеся LL(k)-языки, и пусть их объединение\nL1 ∪ . . . ∪ Ln регулярно. Тогда все языки L1, . . . , Ln должны быть регулярны."
    },
    {
        "question": "Напишите теорему о несвязном объединении языков LL(k)",
        "answer": "Теорема (О непересекающемся объединении LL(k)-языков: Rosenkranz and Stearns [1970]).\nПусть L1, . . , Ln ⊆ Σ\n∗ — попарно непересекающиеся LL(k)-языки, и пусть их объединение\nL1 ∪ . . . ∪ Ln является регулярным. Тогда все языки ​​L1, . . . , Ln должны быть регулярными."
    },
    {
        "question": "Напишите теорему о дизъюнктном объединении LL(k) языков.",
        "answer": "Теорема (О дизъюнктном объединении языков LL(k): Розенкранц и Стернс [1970]).\nПусть L1, . . , Ln ⊆Σ\n∗ являются попарно непересекающимися языками LL(k) и оставляют их объединение\nЛ1 ∪ . . . ∪ Ln регулярен. Тогда все языки L1, . . . , Ln должен быть регулярным."
    },
    {
        "question": "Напишите теорему о дизъюнктном объединении LL(k) языков.",
        "answer": "Теорема (О дизъюнктном объединении языков LL(k): Розенкранц и Стернс [1970]).\nПусть L1, . . . , Ln ⊆Σ\n∗ являются попарно непересекающимися языками LL(k) и оставляют их объединение\nЛ1 ∪ . . . ∪ Ln регулярен. Тогда все языки L1, . . . , Ln должен быть регулярным."
    },
    {
        "question": "Напишите теорему о несвязном объединении языков LL(k).",
        "answer": "Теорема (О непересекающемся объединении языков LL(k)): Розенкранц и Стернс [1970]).\nПусть L1, . . , Ln ⊆Σ\n∗ — попарно непересекающиеся языки LL(k) и их объединение\nЛ1 ∪ . . . ∪ Ln является регулярным. Тогда все языки ​​L1, . . . , Ln должны быть регулярными."
    }
]