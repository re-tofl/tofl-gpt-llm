1) Лемма о накачке для регулярных языков.
________________________________________________________________
Пусть L регулярный язык. Тогда существует целое p ≥ 1 зависящее только от L, такое что строки w из L длины по меньшей мере p (p называется «длиной накачки») может быть записано как w = xyz, так что:
1. |y| ≥ 1
2. |xy| ≤ p
3. для всех i ≥ 0, x(y^i)z ∈ L
y — это подстрока, которую можно накачать (удалить или повторить произвольное число раз, так что результат останется в L). (1) означает, что цикл y должен быть накачан хотя бы длиной 1, (2) означает, что цикл должен быть в пределах первых p символов. На x и z ограничений не накладывается.
================================================================
2) Неформальное утверждение и пояснение леммы о накачке для регулярных языков.
________________________________________________________________

Лемма о накачке описывает существенное свойство регулярных языков. Она утверждает, что слово w языка L длины по меньшей мере m, (где m константа, называемая длиной накачки, зависит лишь от L) можно разделить на три подстроки, w = xyz, так что среднюю часть, y (непустую), можно повторить произвольное число раз (включая ноль, то есть удалить) и получить строку из L. Этот процесс повторения называется «накачкой». Более того, лемма о накачке гарантирует, что длина xy не превысит m, ограничивая способы разделения строки w. Заметим, что конечные языки удовлетворяют требованиям леммы о накачке тривиально определяя m длиной максимальной строки из языка плюс один.
================================================================
3) Использование леммы о накачке для регулярных языков.
________________________________________________________________
Лемма о накачке часто используется для доказательство того, что некоторый язык не является регулярным: доказательство от противного (предположив регулярность языка) может состоять из нахождения слова (нужной длины) языка, для которого свойство из формулировки леммы не выполняется.

Например нерегулярность языка L = {(a^n)(b^n) : n ≥ 0} над алфавитом Σ = {a, b} можно показать следующим образом. Пусть w, x, y, z, p, и i заданы соответственно формулировке леммы выше. Пусть w из L задаётся как w = (a^p)(b^p). По лемме о накачке, существует разбиение w = xyz, где |xy| ≤ p, |y| ≥ 1, такое что x(y^i)z принадлежит L для любого i ≥ 0. Если допустить, что |xy|=p, а |z|=p, то xy — это первая часть w, состоящая из p последовательных экземпляров символа a. Поскольку |y| ≥ 1, она содержит по меньшей мере одну букву a, а x(y^2)z содержит больше букв a чем b. Следовательно, x(y^2)z не в языке L (заметим, что любое значение i не равно 1 даст противоречие). Достигнуто противоречие, поскольку в этом случае накачанное слово не принадлежит языку L. Следовательно предположение о регулярности L неверно. Следовательно L — не регулярный язык.

Доказательство нерегулярности языка сбалансированных скобок проводится с той же идеей. Если дано p, существует строка сбалансированных скобочек, начинающихся с более чем p левых скобок, так что y будет содержать только левые скобки. Повторяя y, можно сконструировать строку, в которой не содержится равное количество левых и правых скобок, которая не может быть сбалансированной.
================================================================
4) Доказательство леммы о накачке
________________________________________________________________
Пусть L — регулярный язык. Тогда по определению регулярности для языка L существует детерминированный конечный автомат (ДКА), который распознает этот язык. Пусть этот автомат имеет p состояний.

Теперь рассмотрим любую строку w из языка L, длина которой |w| ≥ p. По принципу Дирихле (или "принципу ящиков"), если мы будем обрабатывать строку w на этом конечном автомате, то при обработке первых p символов строки автомат, проходя по состояниям, обязательно хотя бы одно состояние посетит дважды (поскольку всего состояний p, а символов в строке тоже p или больше).

Таким образом, строку w можно представить в виде трёх частей:
w = xyz, где:
 1. x — часть строки, которая ведёт автомат от начального состояния до какого-то состояния;
 2. y — часть строки, которая соответствует циклу в автомате (повторный визит в одно и то же состояние);
 3. z — остаток строки после выхода из цикла.
Из этого представления следует выполнение следующих условий:

1. |y| ≥ 1, потому что y — это непустая часть строки, которая вызывает цикл, иначе повторного посещения одного и того же состояния не было бы.
2. |xy| ≤ p, потому что цикл происходит в пределах первых p символов строки.
3. Для всех i ≥ 0, строка вида x(y^i)z тоже принадлежит языку L. Это означает, что мы можем повторять или убирать часть y (которая соответствует циклу в автомате) произвольное количество раз, и полученная строка всё равно будет распознаваться автоматом, следовательно, принадлежать языку L.
Таким образом, лемма о накачке утверждает, что для любой строки w длиной |w| ≥ p из регулярного языка можно найти разбиение w = xyz, которое удовлетворяет вышеуказанным условиям, что и завершает доказательство.
================================================================
5) Обобщённая лемма о накачке для регулярных языков
________________________________________________________________
Если язык L регулярен, то существует число p > 0 (длина накачки), такое что для любой строки uwv из L с |w| ≥ p справедливо представление uwv = uxyzv
где x, y и z — строки, такие что |xy| ≤ p, |y| > 0 и ux(y^i)zv принадлежит L для любого целого i ≥ 0.
Эту версию можно использовать для доказательства нерегулярность ещё большего числа языков, так как она накладывает более строгие ограничения.
================================================================
6) Недостаточность леммы о накачке для регулярных языков
________________________________________________________________
Лемма о накачке для регулярных языков — это мощный инструмент для доказательства того, что язык не является регулярным. Однако она имеет ограничения: даже если язык нарушает условия леммы о накачке, это не всегда означает, что он нерегулярен. Лемма не всегда достаточна для доказательства регулярности или нерегулярности языка. Рассмотрим это на примере языка L:
L={uvwxy:u,y∈{0,1,2,3}∗,vwx∈{0,1,2,3}∧(v=w∨v=x∨x=w)}∪{w:w∈{0,1,2,3}∗}

Рассмотрим структуру языка:
1. Первая часть языка:
   Это строки uvwxy, где:
   	u, y — произвольные строки из {0,1,2,3},
	vwx — строка длины 3 из {0,1,2,3},
	одно из условий выполняется: v = w, v = x или x = w (хотя бы два символа из vwx совпадают).
2. Вторая часть языка:
Это все строки из {0,1,2,3}, то есть любой возможный набор символов.

Попробуем применить лемму к языку L:
1. Строки вида uvwxy имеют строгие ограничения на то, как символы v, w и x могут быть связаны между собой (они должны содержать хотя бы два одинаковых символа). Это может потребовать от конечного автомата "памяти", чтобы сравнить символы v, w и x, что может привести к нерегулярности языка.
2. Однако из-за второй части языка (все строки из {0,1,2,3}) лемма о накачке будет бессильна. Любая строка из этой второй части удовлетворяет условиям леммы о накачке, так как она полностью регулярна (конечный автомат может распознать любые строки из {0,1,2,3}). Лемма просто не сможет доказать нерегулярность, потому что вторая часть языка охватывает все строки, которые можно "накачать", даже если первая часть не является регулярной.

Почему лемма недостаточна для языка L:
1. Если мы попытаемся применить лемму о накачке к языку L, она может "провалиться" на примерах из второй части языка (где любые строки регулярны). То есть лемма не сможет выявить нерегулярность первой части, так как регулярные строки из второй части будут удовлетворять условиям накачки.
2. Лемма о накачке не может доказать нерегулярность языка, если в языке присутствуют регулярные составляющие, которые позволяют любым строкам "успешно пройти" проверку на условия леммы.

Вывод:Лемма о накачке недостаточна для доказательства нерегулярности языка L, поскольку вторая часть языка ({w : w ∈ {0,1,2,3}^*}) состоит из всех строк из {0,1,2,3}, которые всегда удовлетворяют условиям накачки. Это мешает применению леммы для доказательства нерегулярности первой части языка, связанной с условием совпадения символов в строке vwx.
================================================================

7) Делинеаризация регулярных выражений
________________________________________________________________
Делинеаризация регулярных выражений — это процесс обратный линеаризации, который заключается в преобразовании регулярных выражений из линейной, упрощенной формы в более компактную или структурированную форму, обычно с использованием группировок и повторений для уменьшения объема кода и лучшего представления логики регулярного выражения. Делинеаризация помогает восстановить исходную структуру регулярного выражения, делая его более организованным и легко поддерживаемым.
================================================================
8) Зачем нужна делинеаризация?
________________________________________________________________
1. Компактность: Линейные регулярные выражения, особенно если они содержат много альтернатив или повторяющихся частей, могут стать громоздкими. Делинеаризация помогает сократить объем выражения и улучшить его читаемость.
2. Повышение читаемости: Делинеаризация добавляет структуру регулярному выражению. Сгруппированные части могут помочь лучше понять логику выражения, особенно когда разные части разделены на логические компоненты.
3. Поддерживаемость: Регулярное выражение, состоящее из множества линейных альтернатив, сложно поддерживать и модифицировать. Группировка общих частей и использование сокращений делает выражение проще для внесения изменений в будущем.
================================================================
9) Этапы делинеаризации
________________________________________________________________
1. Поиск общих элементов: Найдите части регулярного выражения, которые повторяются в альтернативных путях, и вынесите их за скобки. Например, в выражении abd|acd, можно вынести часть a и d, так как они повторяются в обеих альтернативных ветвях.
2. Использование группировок: После нахождения общих элементов, сгруппируйте различающиеся части в выражении с помощью скобок. Это позволит вам сократить избыточные части выражения.
3. Оптимизация повторений: Если в регулярном выражении присутствуют однотипные повторения символов или групп, используйте квантификаторы (*, +, {n} и другие), чтобы компактно выразить повторение.
================================================================
10) Преимущества делинеаризации
________________________________________________________________
1. Улучшенная читаемость: Делинеаризованное выражение легче читать и понимать, так как оно отображает логику в более организованной форме.
2. Меньший объем кода: После делинеаризации выражение часто становится короче, так как многие элементы можно вынести и сократить.
3. Проще в модификации: Делинеаризованное регулярное выражение проще модифицировать и поддерживать, так как его структура лучше отражает логику проверки.
================================================================
11) Недостатки делинеаризации
________________________________________________________________
1. Может усложнить понимание: В некоторых случаях слишком сложные группировки могут сделать регулярное выражение менее понятным, особенно для тех, кто не знаком с использованием квантификаторов и группировок.
2. Не всегда применимо: Не каждое линейное выражение можно делинеаризовать эффективно. Если в выражении нет очевидных повторений или общих частей, попытка делинеаризации может не дать значительного улучшения.
================================================================
12) Формальные языки
________________________________________________________________
Формальный язык — это множество M слов над алфавитом Σ(обозначается M ⊆ Σ∗, здесь знак ∗ — итерация Клини). Обычно подразумевает наличие формальных правил, определяющих корректность формы (т.е. синтаксиса) слов из M.
================================================================
13) Перечислимость и разрешимость формальных языков
________________________________________________________________
Язык M разрешимый ⇔ для любого слова w существует алгоритм проверки принадлежности w к M(всегда завершающийся и дающий точный, либо положительный, либо отрицательный ответ). 
Язык M перечислимый ⇔ для любого слова w существует алгоритм, положительно отвечающий на вопрос принадлежности w к M за конечное время (но, возможно, зацикливающийся, если w /∈ M). 
Перечислимый, но не разрешимый: язык программ, завершающихся на входе 0 (на любом достаточно мощном ЯП). Далее разрешимые языки можно классифицировать по минимально необходимой сложности разрешающего алгоритма.
================================================================
14) Системы переписывания термов
________________________________________________________________
Сигнатура — множество пар ⟨f, n⟩ из имени конструктора f и его местности n.
Пусть V — множество переменных, F — множество конструкторов; множество термов T(F) над F определяется рекурсивно:
1. все элементы V — термы;
2. если ⟨f, n⟩ — конструктор и t_1,. . . , t_n — термы, то f(t_1, . . . , t_n) — терм;
3. других термов нет.

Пусть V — множество переменных, F — множество конструкторов (сигнатура); T(F) — множество термов над множеством конструкторов F. TRS — набор правил переписывания вида Φ_i → Ψ_i, где Φ_i, Ψ_i — термы в T(F). Правило переписывания Φ_i → Ψ_i применимо к терму t, если t содержит подтерм, который можно сопоставить (унифицировать) с Φ_i.

Если к терму t не применимо ни одно правило переписывания TRS, терм называется нормализованным. Имея правила переписывания вида f(g(x)) → g(g(f(x))) и g(g(x)) → f(x), каждое из них можно применить к терму f(g(g(f(g(f(g(g(g(Z))))))))) тремя разными способами.
================================================================
15) Конфлюэнтность
________________________________________________________________
TRS называется конфлюэнтной, если для любых двух термов t, s, которые получаются переписыванием одного и того же терма u, существует терм v такой, что t, s оба переписываются в v.
Формально:
∀u, t, s(u →∗t & u →∗s ⇒ ∃v(t →∗ v & s →∗ v))

Конфлюэнтные системы поддаются распараллеливанию и легко оптимизируются.
→ — переписывание за 1 шаг;
→∗ — переписывание за произвольное число шагов,
начиная с 0.
================================================================
16) Синтаксический моноид
________________________________________________________________
Моноид — это алгебраическая структура, состоящая из множества MM с бинарной операцией ⋅ (умножение), которая:
1. ассоциативна: (a⋅b)⋅c=a⋅(b⋅c) для любых a, b ,c ∈ M;
2. имеет единичный элемент e ∈ M, такой что для любого a ∈ M выполнено e⋅a=a⋅e =a.

Факторизация по отношению к языку: Чтобы построить синтаксический моноид для языка, сначала определим отношение факторизации по отношению к языку L⊆Σ∗ (где Σ∗ — множество всех строк над алфавитом Σ).

Две строки u и v считаются эквивалентными по отношению к языку L, если для всех строк x,y ∈ Σ∗ выполнение условия xuy ∈ L эквивалентно xvy ∈ L. Это эквивалентное отношение называется синтаксической эквивалентностью и обозначается u ∼_L v.

Связь с конечными автоматами:
Синтаксический моноид можно использовать для описания регулярных языков. Для любого регулярного языка его синтаксический моноид является конечным, а язык можно распознать с помощью конечного автомата, построенного на основе этого моноида. Это означает, что синтаксический моноид является мощным инструментом для анализа структуры регулярных языков и их поведения.

Теорема Микана: Язык является регулярным тогда и только тогда, когда его синтаксический моноид является конечным.

Применение:
1. Классификация регулярных языков: Синтаксический моноид позволяет описывать регулярные языки с точки зрения алгебраической структуры. Это особенно полезно при анализе и классификации языков.
2. Определение сложности языков: Сложность синтаксического моноида (например, количество его элементов) может дать представление о сложности описания языка.
3. Минимизация конечных автоматов: Используя синтаксические моноиды, можно строить минимальные конечные автоматы, которые эффективно распознают регулярные языки.
================================================================
17) Построение синтаксического моноида
________________________________________________________________
Синтаксический моноид можно построить следующим образом:
1. Множество классов эквивалентности: Рассмотрим множество всех классов эквивалентности строк по отношению к синтаксической эквивалентности. Каждый класс эквивалентности строк соответствует одному элементу синтаксического моноида.
2. Операция на классах эквивалентности: Пусть [u][u] и [v][v] — классы эквивалентности строк uu и vv соответственно. Тогда операция в синтаксическом моноиде определяется как [u]⋅[v]=[uv], где uv — конкатенация строк u и v.
3. Единичный элемент: Единичным элементом синтаксического моноида является класс эквивалентности пустой строки ϵ, который обычно обозначается как [ϵ].

Таким образом, синтаксический моноид состоит из всех классов эквивалентности строк по отношению к синтаксической эквивалентности с операцией конкатенации строк.
