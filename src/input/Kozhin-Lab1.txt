Дай определение надрегулярного множества в теории формальных языков. Определи множество регулярных языков
________________________________________________________________
Пусть задан алфавит Σ={c1,c2,…,ck}.
Множество R
 будем называть надрегулярным множеством над алфавитом Σ, если:

R0⊂R, где R0={∅,{ε},{c1},{c2},…,{ck}},
L1,L2∈R⇒L1∪L2∈R,L1L2∈R,L∗1∈R.
Тогда множеством регулярных языков REG′
 над алфавитом Σ={c1,c2,…,ck}
 называется пересечение всех надрегулярных множеств над этим алфавитом.
 
================================================================
как проверить пару детерминированных конечных автоматов на эквивалентность с помощью поиска в ширину?
________________________________________________________________
Два автомата можно также проверить на эквивалентность, используя обход в ширину. Будем синхронно обходить два автомата, начиная со стартовых состояний, в поисках такой строки, которая различает два состояния этих автоматов. То есть она будет допускаться одним автоматом, но не будет принадлежать языку другого.

Поскольку эквивалентные автоматы допускают один и тот же язык, при переходе по одним и тем же символам в обоих автоматах, слово должно приниматься обоими автоматами одновременно. То есть вершины, в которые мы перешли, должны быть либо одновременно терминальными, либо одновременно нетерминальными, что и проверяет приведённый алгоритм.

Псевдокод
// aut[i][c]
 — номер состояния, в которое есть переход из состояния i
 по символу c

boolean bfsEquivalenceCheck
(aut1
 : int[][], aut2
 : int[][]):
    Q.push(⟨s1,s2⟩)
 // Q
 — очередь из пар состояний
    while Q≠∅
 
        u,v←Q.pop()

        if isTerminal1[u]≠isTerminal2[v]

            return false
        used[u][v]←
 true
        for c∈Σ

            if not used[aut1[u][c]][aut2[v][c]]

                Q.push(⟨aut1[u][c],aut2[v][c]⟩)

    return true
Корректность алгоритма следует из строго доказательства того факта, что если два состояния u
 и v
 различаются какой-то строкой, то они различаются строкой длины O(n).

Интуитивное понимание алгоритма такое: пусть по строке w
 мы пришли в состояния ⟨u,v⟩, и пусть они оба нетерминальные. После этого совершим переход по символу c
 в состояния ⟨u′,v′⟩.

Тогда если isTerminal1[u′]≠isTerminal2[v′], то строка wc
 различает эти два состояния. А значит автоматы не эквивалентны.
================================================================
Какими свойствами обладают КС-языки относительно операций объединения, конкатенации, замыкания Клини, прямого гомоморфизма?
________________________________________________________________
Объединение
L1∪L2
  является КС-языком.
Доказательство:
Построим КС-грамматику для языка L1∪L2. Для этого рассмотрим соответствующие КС-грамматики для языков L1
 и L2. Пусть стартовые символы в них имеют имена S
 и T
 соответственно. Тогда стартовый символ для L1∪L2
 обозначим за S′
 и добавим правило S′→S∣T.

Покажем, что S′⇒∗w⟺S⇒∗w∨T⇒∗w.

⇒

Поскольку S⇒∗w
 и есть правило S′→S
, то, по определению ⇒∗
 получаем, что S′⇒∗w. Аналогично и для T.
⇐

Пусть S′⇒∗w. Поскольку S′→S∣T
 — единственные правила, в которых нетерминал S′
 присутствует в правой части, то это означает, что либо S′⇒S⇒∗w, либо S′⇒T⇒∗w.

Конкатенация  
L1L2
 — КС-язык.
Доказательство
Нужно использовать идею прошлого доказательства и построить КС-грамматику для L1L2 с правилом S′→ST, где S
 и T
 — стартовые символы языков L1
 и L2
 соответственно.
 
L∗=⋃i=0∞Li
  — КС-язык.

Гомоморфизм
КС-языки замкнуты относительно прямого гомоморфизма.

Обратный гомоморфизм
КС-языки замкнуты относительно обратного гомоморфизма.

Пересечение
Если L1=aibicj,L2=aibjcj
, то L1∩L2
 не является КС-языком.
 
Разворот
L^R={w^R∣w∈L}
контекстно-свободен.
================================================================
докажи, что язык алфавитной префиксной грамматики регулярен
________________________________________________________________
Определение APG
Дана SRS S с правилами переписывания двух видов:
ai → b1 . . . bn ai → ε
Разрешим применять правила только к первым буквам
слова. Пусть дана пара ⟨S, w0⟩, где w0 — слово в алфавите
Σ. Эта пара определяет алфавитную префиксную
грамматику.
Утверждение
Язык L⟨S, w0⟩ регулярен.
2 / 24
▲
Алфавитные префиксные грамматики
Утверждение
Язык L⟨S, w0⟩ регулярен.
Скажем, что a ↠ ε (a коллапсирует), если либо a → ε ∈ S, либо
∃b1, . . . , bn(∀bi(bi ↠ ε) & a → b1 . . . bn ∈ S).
По APG ⟨S, s1 . . . sn⟩ породим праволинейную грамматику G. Каждому
символу алфавита ai сопоставим Ai — нетерминал G.
1 Пусть a → b1 . . . bn и ∃bi(¬(bi ↠ ε) & ∀j(j < i ⇒ bj ↠ ε)).
Тогда добавим в G правила A → B1b2 . . . bn, A → B2b3 . . . bn,. . . ,
A → Bibi+1 . . . bn, A → a.
2 Если такого bi нет, добавляем в G все правила вида
A → B1b2 . . . bn, . . . , A → Bn−1bn, A → Bn, A → a.
3 Вводим стартовый нетерминал S и для него добавляем развёртку в
исходное слово s1 . . . sm по правилам выше.
4 Если все si коллапсируют, тогда добавляем в G правило S → ε.
2 / 24
▲
Алфавитные префиксные грамматики
Скажем, что a ↠ ε (a коллапсирует), если либо a → ε ∈ S, либо
∃b1, . . . , bn(∀bi(bi ↠ ε) & a → b1 . . . bn ∈ S).
По APG ⟨S, s1 . . . sn⟩ породим праволинейную грамматику G. Каждому
символу алфавита ai сопоставим Ai — нетерминал G.
1 Пусть a → b1 . . . bn и ∃bi(¬(bi ↠ ε) & ∀j(j < i ⇒ bj ↠ ε)).
Тогда добавим в G правила A → B1b2 . . . bn, A → B2b3 . . . bn,. . . ,
A → Bibi+1 . . . bn, A → a.
2 Если такого bi нет, добавляем в G все правила вида
A → B1b2 . . . bn, . . . , A → Bn−1bn, A → Bn, A → a.
3 Вводим стартовый нетерминал S и для него добавляем развёртку в
исходное слово s1 . . . sm по правилам выше.
4 Если все si коллапсируют, тогда добавляем в G правило S → ε.
Остается сделать развертку правил вида A → Bn, либо перейти от G к
НКА с ε-переходами.
2 / 24
▲
================================================================
напиши лемму Ардена		
________________________________________________________________
Пусть X = (pX) | q, где X — неизвестное RE, а p, q —
известные, причём ε /∈ L (p). Тогда X = (p)
∗q.
То есть p
∗q — наименьшая (но не единственная) неподвижная
точка выражения px | q по отношению ⩽, и единственная, если
ε /∈ L (p).
================================================================
Сформулируй теорему о замкнутости регулярных языыков
________________________________________________________________
Пусть L1,L2
 — регулярные языки над одним алфавитом Σ. Тогда следующие языки также являются регулярными:
 Языки, полученные путём применения следующих теоретико-множественных операций:
 L1∪L2,
 L1¯¯¯¯¯¯,
 L1∩L2,
 L1∖L2;
 L∗1;
 L1L2; 
 L1←;
================================================================
Сформулируй теоремы о построении LL(k) грамматики без пустых правил
________________________________________________________________
Теорема 1 
Для всякой LL(k)-
грамматики существует и может быть эффективно построена LL(k + 1)-грамматика
без пустых правил, задающая тот же язык.

Теорема 2 
Для всякой LL(k)-грамматики без пустых правил можно построить LL(k)-грамматику в н.в.Грейбах, задающую тот же язык.
================================================================
Сформулируй лемму Розенкранца и Стирнса для обыкновенной грамматики
________________________________________________________________
Лемма 1 (Розенкранц и Стирнс [1970]). Для всякой обыкновенной грамматики G =
(Σ, N, R, S), существует другая грамматика G0 = (Σ, N ∪ N0, R0, S0), где N0 = { A0| A ∈
N }, удовлетворяющая следующим условиям.
1. Всякий нетерминальный символ A ∈ N задаёт в G0 тот же язык, что и в G.
2. Всякий нетерминальный символ A0 ∈ N в G0
задаёт тот же язык, что и в G, с
исключённой пустой строкой: LG0(A0) = LG(A0) \ {ε}. В частности, L(G0) = L(G) \{ε}.
3. Никакое правило из R0 не начинается с нетерминального символа из N.
4. Если G — LL(k), то и G0 — тоже LL(k).
================================================================
Сформулируй лемму Розенкранца и Стирнса для LL(k)-грамматики
________________________________________________________________
Лемма 2 (Розенкранц и Стирнс [1970]). Пусть G = (Σ, N, R, S) — LL(k)-грамматика,
не содержащая правил вида A → Bγ, где ε ∈ LG(B). Пусть обнуляемые нетерминальные
символы обозначаются через N0 = { A | A ∈ N, ε ∈ LG(A) }, и пусть N1 = { A | A ∈ N, ε /∈
LG(A) } — все остальные. Тогда существует LL(k + 1)-грамматика G0 = (Σ, N0, R0, S0),где N0 — конечное множество нетерминальных символов вида [Xθ], где X ∈ Σ ∪ N1 и
θ ∈ N∗0, и LG0([Xθ]) = LG(Xθ) для всякого [Xθ] ∈ N0
[Xθ] ∈ N0.
При этом множество N0 не содержит ни одного элемента вида [XθAθ0Aθ00], который
содержал бы повторяющиеся вхождения одного и того же нетерминального символа.
================================================================
Напиши теорему о непересекающемся объединении LL(k)-языков
________________________________________________________________
Теорема (О непересекающемся объединении LL(k)-языков: Розенкранц и Стирнс [1970]).
Пусть L1, . . . , Ln ⊆ Σ
∗ — попарно непересекающиеся LL(k)-языки, и пусть их объединение
L1 ∪ . . . ∪ Ln регулярно. Тогда все языки L1, . . . , Ln должны быть регулярны.
================================================================
Расскажи про свойства LL-грамматик
________________________________________________________________
Грамматику, которая была бы LL(k), но не LL(k − 1), построить легко: например, S →
a
k
| a
k−1 — такая грамматика. Но в данном примере есть очевидная LL(1)-грамматика для
того же языка: S → a
k−1A, A → a | ε. Растёт ли класс языков с увеличением k? Да.
Лемма 1. Пусть G = (Σ, N, R, S) — LL(k)-грамматика без пустых правил, и пусть вычисление LL(k)-анализатора на некоторой строке w = xyz после чтения x приводит в
конфигурацию (yz, Y γ), и затем, после чтения y, — в конфигурацию (z, γ). Тогда для всякой строки z
0, совпадающей z в первых k − 1 символах, вычисление на xyz0 приходит в
конфигурацию (z
0, γ).
Набросок доказательства. Разбирая y в виде Y , анализатор при каждом выборе правила
видит не менее одного последнего символа y. Поэтому различия между z и z
0 при этом
выборе окажутся за горизонтом, и, стало быть, анализатор одинаково прочитает y в обоих
случаях.
Теорема 1 (Курки-Суонио [1969]; Розенкранц и Стинрс [1970]). Для всякого k > 1, существует язык Lk, задаваемый LL(k)-грамматикой, но не задаваемый никакой LL(k)-
грамматикой без пустых правил — и, стало быть, никакой LL(k − 1)-грамматикой.
Доказательство. Язык Lk определяется как Lk =S
n>1
a^n{b^kd, b, c}^n, и он описывается
следующей грамматикой.
S → aCA
C → aCA | ε
A → bB | c
B → b
k−1
d | ε
Чтобы убедиться, что эта грамматика — LL(k), нужно проверить, что анализатор может
выбрать правило для B. Действительно, правило B → ε выбирается для всех просматриваемых строк Firstk(LG(A)
+), каковые все состоят целиком из символов b и c: строка b
k−1d
не относится к числу этих строк.
Отрицательный результат получается методом подменяемой строки впереди. Если Lk
задаётся LL(k)-грамматикой без пустых правил, то, по теореме из прошлой лекции, есть
LL(k)-грамматика G = (Σ, N, R, S) в нормальном виде Грейбах, задающая язык L(G) = Lk.
Пусть αn — содержимое стека соответствующего LL(k)-анализатора на входе a
n+k−1
. . .,
после прочтения символов u = a
n
.
Утверждение. αm 6= αn для всех m 6= n.
Утверждение. Существует число n > 0, для которого |αn| > 2k − 1
================================================================
Что такое локальные автоматы
________________________________________________________________
Определение:
Автомат A
 называется локальным (англ. local automaton, Glushkov automaton), если для любого c
 из Σ
 множество {δ(s,c)∣s∈S}
 содержит не более одного элемента.


Определение:
Локальный автомат A
 называется стандартным локальным автоматом (англ. standard local automation), если в нем нет перехода в начальное состояние.

Таким образом, автомат является локальным, если для каждого c
 из Σ
 нет переходов, отмеченных c, или если все они ведут в одно состояние.

Покажем, что граф Майхилла может быть преобразован в стандартный локальный автомат таким образом, что распознаваемый им язык не изменится.

Теорема:
Язык распознается графом Майхилла тогда и только тогда, когда он распознается стандартным локальным автоматом, стартовое состояние которого не является терминальным.
================================================================