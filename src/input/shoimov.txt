Линеаризация регулярных выражений это
________________________________________________________________

Если регулярное выражение r ∈ RE (регулярное выражение) содержит n вхождений букв алфавита ∑, тогда линеаризованное регулярное выражение Linearize(r) получается из r приписыванием i-ой по счёту букве, входящий в r, индекса i.
Рассмотрим регулярное выражение:(ba | b)aa(a | ab)*
Его линеаризованная версия:(b_1a_2 | b_3)a_4a_5(a_6 | a_7b_8)*

================================================================
Множество First Last Follow

________________________________________________________________

Пусть регулярное выражение r ∈ RE (регулярное выражение), тогда:Множество First - это множество букв, с которых может начинаться слово из L(r) (если ε ∈ L(r), то оно формально добавляется в First);
Множество Last- это множество букв, с которых может заканчиваться слово из L(r) 
Множество Follow(c)- это множество букв, с которых может предшествовать c. Т.е. { d ∈ ∑ | ∃ w_1, w_2 (w_1cdw_2 ∈ L(r)) }
r = (ba | b)aa(a | ab)* - регулярное выражениеFirst(r) = {b}
Last(r) = {a, b}
Follow_r(a) = {a, b}; Follow)_r(b) ={a}

================================================================

Минимализация ДКА алгоритм Хопкрофта
________________________________________________________________
Алгоритм Хопкрофта для минимизации ДКА (Deterministic Finite Automaton) - это алгоритм, который позволяет найти минимальный ДКА, эквивалентный дадому ДКА.
Алгоритм Хопкрофта работает следующим образом:
Шаг 1: Инициализация. Создаем начальное разделение на множество Q0 (начальные состояния) и множество Q1,..., Qn-1 (все другие состояния).
Шаг 2: Пока множество разделений более чем из одного элемента, выполняем следующее:
* Выберите множество A из разделения.
* Выберите символ c.
* Для каждого множества B в разделении, разделите B на два подмножества:
    * B_c: множество состояний в B, которые, прочитав c, переходят в состояние в A.
    * B_~c: множество состояний в B, которые, прочитав c, не переходят в состояние в A.
* Добавьте B_c и B_~c в разделение.
Шаг 3: Алгоритм останавливается, когда невозможно выполнить больше разделений.
Теорема: Алгоритм Хопкрофта останавливается и производит минимальный ДКА.
Алгоритм Хопкрофта является алгоритмом для поиска минимального ДКА, эквивалентного дадому ДКА, и используется в теории автоматов и регулярных языках.

================================================================

что такое LTS(Labelled Transition System)

________________________________________________________________
LTS это тройка <S,∑,Q> где S-множество состояний, ∑ - множество меток, Q - множество переходов <троек из S x ∑ x S>. LTS похожи на автоматы но допускают бесконечные множества S и Q. так же в них нет начальных и финальных 
состояний

================================================================

Если язык L - регулярный, то он задаётся конечным недетерминированным автоматом. Докажи
________________________________________________________________	

Пусть задан алфавит Σ терминальных символов.
Как строятся регулярные множества, так же и доказывается теорема. Наша задача - доказать, что любое регулярное множество можно задать конечным недетерминированным автоматом. Для начала найдем схему построения автомата для регулярок-констант, т.е. для букв алфавита ∑, потом перейдем к усложнениям.
Построим автомат, который распознаёт некоторую букву а ∈ ∑:
M = <Q, Σ, δ(x,y), q0, F>
Q = {q0}
F = {q0}
δ(q0, a) = q0.
Т.е. это автомат, распознающий язык {a}. Для языка { }, функция будет пустой, все остальное будет таким же. А для языка ∅ еще и множество допускающих состояний будет пустым, F = ∅.
Тут должен был быть рисунок с диаграммой, но его нет. Диаграмма автомата - обычный ориентированный граф, где вершины - состояния из Q, а те, что из F еще и как-то выделены цветом/обводкой/т.д. Ребро q1 → q2 всегда должно быть подписано буквой из a ∈ ∑, что означает, что (q1, a) = q2. Вот и все.
Нужно построить автомат, распознающий язык L1 + L2
По определению: Если языки L1 и L2 - регулярные, то и L1 + L2 - регулярный язык. Пусть L1 распознаётся автоматом M1=<Q1, Σ, δ1, q1, F1>, а L2 распознаётся автоматом M1=<Q2, Σ, δ2, q2, F2> Не ограничивая общности, считаем, что Q1∩Q2 =∅ (достигается обычным переименовыванием). Введём новое состояние q0.
Пусть M распознаёт L1+L2. M=<Q, Σ, δ, q0, F>
Q=Q1UQ2U{q0}
δ(q0, a) = δ1(q1,a) U δ2(q2,a)
δ(q, a)= δ1(q, a); q∈Q1
δ2(q, a), q∈Q2
F = F1 U F2
Нужно построить автомат, распознающий язык L1 L2
Пусть M распознаёт L1L2. M=<Q, Σ, δ, q1, F>
δ1(q, a), если q∈Q1\F1
δ(q, a)= δ1(q,a) U δ2(q2,a); q∈F1
δ2(q, a), q∈Q2
F=F2
/здесь не все так просто - если q2 ∈ F2, то F = F1 ∪ F2/
Нужно построить автомат, распознающий язык L1*
M=<Q, Σ, δ, q0, F>
F=F1 U {q0}
δ1(q1, a), если q=q0
δ(q, a)= δ1(q, a); q∉F1
δ1(q1,a) U δ1(q,a), q∈F

================================================================

Если язык L - регулярный, то он задаётся праволинейной грамматикой. Докажи
________________________________________________________________
S→ a — грамматика, из которой выводится 1 символ. Пустая грамматика соответствует пустому языку, а грамматика S → соответствует языку { }.
Пусть L1 и L2 - регулярные языки, и задаются грамматиками G1 и G2 соответственно.
Построим грамматику, которая задаёт язык L = L1 + L2:
Добавим один новый нетерминал S: G=<N1 U N2, ∑, P, S>, где N1 - множество нетерминалов из G1, N2
* множество нетерминалов из G2 Предположим, что N1∩N2=∅. P=P1U P2 и добавим новое правило: S → S1|S2 Построим грамматику, которая задаёт язык L=L1L2 Возьмём из P1 правила A → γ, где γ ∈ ∑*, и заменим их на правила A → γS2 Построим грамматику, которая задаёт язык L=L1
* 
Возьмём все правила A → γ, где γ ∈ ∑*, и заменим их на правила A → γS1, а так же добавим правило S→

================================================================

{a^nb^n| n>=0} is regular?
________________________________________________________________

{a^nb^n| n>=0} is not regular. Let W = {a^k | k >=0}. For every distinct words a^i, a^j ∈ W (i !=j), we have b^i ∈ L^(a^i), but b^j !∈ L^(a^j)

================================================================

{ww | w ∈ ∑* } regular?
________________________________________________________________

{ww | w ∈ ∑* } is not regular. Let W=Σ*. For every 2 distinct words w, v ∈ W (w !=v), we have that w ∈ L^w, but w !∈ L^v
