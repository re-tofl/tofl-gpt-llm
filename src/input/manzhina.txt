Рекурсивный нетерминал
________________________________________________________________
Рекурсивный нетерминал — это нетерминальный символ в грамматике, который можно вывести в строку, содержащую самого себя. То есть, в процессе развертывания правил грамматики нетерминал может привести к цепочке вывода, где он снова появляется.
Например, если нетерминал \( A \) имеет правило \( A \rightarrow \alpha A \beta \) или через несколько шагов выводится в такое, то \( A \) является рекурсивным.
================================================================
Леворекурсивный нетерминал
________________________________________________________________
Леворекурсивный нетерминал — это нетерминал, у которого есть правило, где он стоит первым символом в правой части своего собственного правила, то есть \( A \rightarrow A \alpha \), где \( \alpha \) — некоторая строка символов.
Леворекурсия может приводить к проблемам при нисходящем разборе (парсинге), так как может вызывать бесконечную рекурсию в рекурсивных парсерах.
================================================================
Праворекурсивный нетерминал
________________________________________________________________
Праворекурсивный нетерминал — это нетерминал, у которого есть правило, где он стоит последним символом в правой части своего собственного правила, то есть \( A \rightarrow \alpha A \), где \( \alpha \) — некоторая строка символов.
Праворекурсия обычно не вызывает проблем при нисходящем разборе и может быть предпочтительнее для некоторых типов парсеров, хотя может влиять на эффективность при больших глубинах рекурсии.
================================================================
Рассмотрим следующую контекстно-свободную грамматику \( G \):

1. \( S \rightarrow aSb \)
2. \( S \rightarrow SS \)
3. \( S \rightarrow \varepsilon \)
Докажите, что язык \( L(G) \), порождаемый грамматикой \( G \), непуст и опишите этот язык.
________________________________________________________________
Грамматика \( G \) непустая, поскольку содержит правило \( S \rightarrow \varepsilon \), которое позволяет вывести пустую строку \( \varepsilon \). Это означает, что \( \varepsilon \in L(G) \), и, следовательно, язык \( L(G) \) непуст.

Опишем язык \( L(G) \), порождаемый грамматикой:

1. Правило \( S \rightarrow aSb \): Оно порождает строки, которые начинаются с символа \( a \), заканчиваются символом \( b \), а между ними может быть рекурсивно вставлена такая же структура. Это создает баланс между количеством \( a \) и \( b \), где каждому \( a \) слева соответствует \( b \) справа.

2. Правило \( S \rightarrow SS \): Это правило позволяет конкатенировать две любые строки, порожденные из \( S \). Таким образом, мы можем комбинировать несколько структур, порожденных первым правилом, или даже другие конкатенации.

3. Правило \( S \rightarrow \varepsilon \): Позволяет завершить вывод и порождает пустую строку.

Описание языка \( L(G) \):

Язык \( L(G) \) состоит из всех строк, содержащих равное количество символов \( a \) и \( b \), где символы \( a \) и \( b \) могут быть расположены таким образом, что каждая позиция символа \( a \) слева соответствует символу \( b \) справа, но также допускаются конкатенации таких структур.

То есть, \( L(G) = \{ w \in \{a, b\}^* \mid |w|_a = |w|_b \} \).
================================================================
Рассмотрим следующую контекстно-свободную грамматику \( G \):

1. \( S \rightarrow aSb \)
2. \( S \rightarrow SS \)
3. \( S \rightarrow \varepsilon \)
Постройте недетерминированный магазинный автомат (НМПА), эквивалентный грамматике \( G \).
________________________________________________________________
Для построения НМПА, распознающего язык \( L(G) \), мы можем воспользоваться следующим подходом:

Алфавит ввода: \( \{a, b\} \)

Алфавит стека: \( \{A\} \) (символ для отслеживания количества \( a \))

Набор состояний: \( \{q_0\} \) (начальное и единственное состояние)

Функции переходов:

1. Обработка символа \( a \):

   При чтении символа \( a \), НМПА кладет символ \( A \) в стек.

   \( \delta(q_0, a, Z) = \{ (q_0, AZ) \} \)

   \( \delta(q_0, a, A) = \{ (q_0, AA) \} \)

2. Обработка символа \( b \):

   При чтении символа \( b \), НМПА снимает символ \( A \) с вершины стека, если он там есть.

   \( \delta(q_0, b, A) = \{ (q_0, \varepsilon) \} \)

3. Обработка пустого символа (для принятия пустой строки):

   \( \delta(q_0, \varepsilon, Z) = \{ (q_0, Z) \} \)

Описание работы НМПА:

- НМПА начинает в состоянии \( q_0 \) со стеком, содержащим начальный символ \( Z \).

- При чтении каждого символа \( a \) автомат кладет \( A \) в стек, увеличивая счетчик количества \( a \).

- При чтении каждого символа \( b \) автомат снимает \( A \) с вершины стека, уменьшая счетчик.

- Если после обработки всей входной строки стек возвращается к начальному символу \( Z \) (т.е. стек пуст в отношении символов \( A \)), автомат принимает строку.

- НМПА принимает строку, если количество символов \( a \) равно количеству символов \( b \).

Соответствие грамматике \( G \):

- Правило \( S \rightarrow aSb \) соответствует увеличению стека на \( A \) при чтении \( a \) и последующему уменьшению при чтении \( b \).

- Правило \( S \rightarrow SS \) соответствует недетерминированности НМПА, позволяющей ему разделять строку на подстроки, обрабатываемые независимо.

- Правило \( S \rightarrow \varepsilon \) соответствует возможности НМПА принять пустую строку без изменения стека.

================================================================
Рассмотрим следующую контекстно-свободную грамматику \( G \):

1. \( S \rightarrow aSb \)
2. \( S \rightarrow SS \)
3. \( S \rightarrow \varepsilon \)
Объясните, почему невозможно построить детерминированный магазинный автомат, распознающий язык \( L(G) \).
________________________________________________________________
Язык \( L(G) \) состоит из всех строк над алфавитом \( \{a, b\} \), в которых количество символов \( a \) равно количеству символов \( b \). Этот язык не является детерминированным контекстно-свободным.

Причины невозможности построения детерминированного МПА:

1. Отсутствие возможности предсказания:

   Детерминированный МПА должен на каждом шаге однозначно определять действие (переход и операция со стеком) на основе текущего состояния, символа входа и символа на вершине стека.

   В языке \( L(G) \) символы \( a \) и \( b \) могут появляться в любом порядке, при этом решение, когда положить символ в стек или когда извлечь его, не может быть принято однозначно на основе текущей информации.

2. Недетерминированность необходима для балансировки:

   Чтобы определить, соответствует ли данная строка условию \( |w|_a = |w|_b \), автомат должен "заглядывать" вперед или помнить неопределенное количество информации о прочитанных символах. Это требует недетерминированных выборов.

3. Пример невозможности однозначного перехода:

   Рассмотрим ситуацию, когда автомат прочитал несколько символов \( a \) и \( b \) в произвольном порядке. При встрече следующего символа автомат не может однозначно решить, следует ли добавить символ в стек или извлечь его, так как не известно, какие символы еще последуют.

Заключение:

Недетерминированность необходима для распознавания языка \( L(G) \), поскольку автомат должен рассматривать все возможные варианты распределения символов \( a \) и \( b \), обеспечивающих условие равенства их количества. Это невозможно реализовать в детерминированном МПА, где каждый шаг строго определен.
================================================================
Алгоритм избавления от левой рекурсии
________________________________________________________________

Шаги алгоритма устранения левой рекурсии:

1. Идентификация левой рекурсии:
   - Непосредственная левая рекурсия: Когда правило имеет вид A → Aα | β, где A — нетерминал, α — последовательность символов (непустая), а β — альтернатива, которая не начинается с A.
   - Косвенная левая рекурсия: Когда последовательность правил приводит к ситуации, где A → Bα, а B может вывести A в качестве первого символа (т.е. B ⇒+ A).

2. Устранение непосредственной левой рекурсии для каждого нетерминала:
   Для каждого нетерминала A, имеющего правила вида:
   

   A → Aα₁ | Aα₂ | ... | Aαₙ | β₁ | β₂ | ... | βₘ
   
   где β₁, β₂, ..., βₘ — альтернативы, которые не начинаются с A.

   - Создаем новый нетерминал A'.
   - Переписываем правила следующим образом:
     

     A  → β₁A' | β₂A' | ... | βₘA'
     A' → α₁A' | α₂A' | ... | αₙA' | ε
     
     Здесь ε обозначает пустую строку (эпсилон).

3. Устранение косвенной левой рекурсии:
   - Упорядочиваем нетерминалы в некотором порядке A₁, A₂, ..., An.
   - Для каждого нетерминала Ai от i = 1 до n:
     - Для каждого правила вида Ai → Ajγ, где j < i:
       - Заменяем Aj на его правые части.
     - После замены устраняем непосредственную левую рекурсию из правил для Ai, используя метод из шага 2.

================================================================
Различия между контекстно-свободной грамматикой и автоматной грамматикой
________________________________________________________________
Ключевые различия между контекстно-свободными (КС) грамматиками и автоматными грамматиками

Контекстно-свободные грамматики (КС-грамматики):

Контекстно-свободные грамматики являются более мощным инструментом для описания языков по сравнению с регулярными (автоматными) грамматиками. Они используются для определения контекстно-свободных языков и занимают второй уровень в иерархии Хомского (типа 2).
- Правила имеют вид: \(A \rightarrow \alpha\), где \(A\) — нетерминальный символ, а \(\alpha\) — произвольная строка из терминальных и нетерминальных символов.

Автоматные грамматики (Регулярные грамматики):

Автоматные грамматики, также известные как регулярные грамматики, являются самым простым классом грамматик и соответствуют регулярным языкам. Они находятся на самом низком уровне иерархии Хомского (типа 3).
- Правила имеют вид:
    - Праволинейные грамматики: \(A \rightarrow aB\) или \(A \rightarrow a\)
    - Леволинейные грамматики: \(A \rightarrow Ba\) или \(A \rightarrow a\)
    - Где \(A\) и \(B\) — нетерминалы, \(a\) — терминальный символ.

*Основные различия:

1. **Выразительная мощность:
   - КС-грамматики способны описывать более сложные языки с рекурсией и вложенностями.
   - Регулярные грамматики ограничены описанием простых последовательностей без рекурсивных структур.

2. Типы правил производства:
   - В КС-грамматиках на левой стороне правила всегда один нетерминал, а правая сторона может быть любой строкой из терминалов и нетерминалов.
   - В регулярных грамматиках правая часть правила ограничена одним терминалом, возможно с последующим нетерминалом (для праволинейных грамматик), или нетерминалом, предшествующим терминалу (для леволинейных грамматик).

3. Соответствующие автоматы:
   - КС-языки распознаются автоматами с магазинной памятью, которые имеют стек для учета вложенных структур.
   - Регулярные языки распознаются конечными автоматами без дополнительной памяти.

4.Замкнутость относительно операций:
   - Регулярные языки замкнуты относительно объединения, конкатенации, замыкания Клини, пересечения и дополнения.
   - КС-языки замкнуты относительно объединения, конкатенации и замыкания Клини, но не замкнуты относительно пересечения и дополнения.
================================================================
