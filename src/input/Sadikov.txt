Двоичное префиксное кодирование
________________________________________________________________
это гомоморфизм h : Σ+ → {0, 1}+ такой, что ∀ a, b ∈ Σ ∀ w ∈ {0, 1}∗(h(a) != h(b)w).
================================================================
Формальная грамматика
________________________________________________________________
это способ описания формального языка, представляющий собой четверку
Γ=⟨Σ,N,S∈N,P⊂((Σ∪N)∗N(Σ∪N)∗)×(Σ∪N)∗⟩, где:
Σ — алфавит, элементы которого называют терминалами (англ. terminals);
N — множество, элементы которого называют нетерминалами (англ. nonterminals);
S — начальный символ грамматики (англ. start symbol);
P — набор правил вывода (англ. production rules или productions) α -> β.
================================================================
Сентенциальная форма
________________________________________________________________
это последовательность терминалов и нетерминалов, выводимых из начального символа.
================================================================
Грамматика для правильной скобочной последовательности
________________________________________________________________
Σ={(,)}
S -> (S)
S -> SS
S -> ε
================================================================
Регулярная (праволинейная) грамматика это
________________________________________________________________
это грамматика, которая содержит правила вида S -> ε (причем S не встречается в правых частях никаких правил), T_i -> a_i, T_i -> a_iT_j.
================================================================
G_1 и G_2 - праволинейные. Построить G: L(G) = L(G_1) U L(G_2) (объединение):
________________________________________________________________
1. Переименовать нетерминалы из N_1 и N_2, чтобы стало N_1 ∩ N_2 = ∅ (сделать α-преобразование). Применить переименовку к правилам G_1 и G_2
2. Объявить стартовым символом свежий нетерминал S и для всех правил G_1 вида S_1 -> α и правил G_2 вида S_2 -> β, добавить правила S -> α, S-> β в правила G
3. Добавить в правила G остальные правила из G_1 и G_2.
================================================================
G_1 и G_2 - праволинейные. Построить G: L(G) = L(G_1)L(G_2) (конкатенация):
________________________________________________________________
1. Переименовать нетерминалы из N_1 и N_2, чтобы стало N_1 ∩ N_2 = ∅ (сделать α-преобразование).
2. Построить из G_1 ее вариант без ε-правил
3. По всякому прваилу из G_1 вида A -> a строим правило G вида A -> aS_2, где S_2 - стартовый нетерминал G_2
4. Добавить в правила G остальные правила из G_1 и G_2. Объявить S_1 стартовым
5. Если ε ∈ L(G_1) (до шага 2), то по всем S_2 -> β добавить правило S_1 -> β.
================================================================
G_1 - праволинейная. Построить G: L(G) = L(G_1)+ (положительная итерация Клини):
________________________________________________________________
1. Построить из G_1 её вариант без ε-правил
2. По всякому правилу из G_1 вида A → a строим правило G вида A → aS_1, где S_1 — стартовый нетерминал G_1
3. Добавить в правила G все (включая вида A → a) правила из G_1. Объявить S_1 стартовым
4. Если ε ∈ L(G_1) (до шага 2), добавить правило S_1 → ε и вывести S1 из рекурсии
================================================================
G — праволинейная. Построить G′ без правил вида A → ε такую, что L(G′) = L(G) или L(G′) ∪ {ε} = L(G):
________________________________________________________________
1. Перенести в G′ все правила G, не имеющие вид A → ε
2. Если существует правило A → ε, то по всем правилам вида B → aA дополнительно строим правила B → a.
================================================================
G_1, G_2 — праволинейные. Построить G′ такую, что L(G′) = L(G_1) ∩ L(G_2):
________________________________________________________________
1. Построить стартовый символ G′ — пару ⟨S_1, S_2⟩, где S_i — стартовый символ грамматики G_i
2. Поместить ⟨S_1, S_2⟩ в множество U неразобранных нетерминалов. Множество T разобранных нетерминалов объявить пустым
3. Для каждого очередного нетерминала ⟨A_1, A_2⟩ ∈ U:
	- если A_1 → a ∈ G_1, A_2 → a ∈ G_2, тогда добавить в G′ правило ⟨A_1, A_2⟩ → a;
	- если A_1 → aA_3 ∈ G_1, A_2 → aA_4 ∈ G_2, тогда добавить в G′ правило ⟨A_1, A_2⟩ → a⟨A_3, A_4⟩, а в U — нетерминал ⟨A_3, A_4⟩, если его ещё нет в множестве T;
	- если все пары правил, указанные выше, были обработаны, тогда переместить ⟨A_1, A_2⟩ из U в T
4 Повторять шаг 3, пока множество U не пусто
5 Если ε ∈ L(G_1) & ε ∈ L(G_2), тогда добавить в G′ правило ⟨S_1, S_2⟩ → ε.
================================================================
Доказать теорема: Множество языков, задаваемых праволинейными грамматиками, совпадает со множеством языков, задаваемых конечными автоматами.
________________________________________________________________
Пусть имеется конечный автомат. Построим для него праволинейную грамматику. Множеством нетерминалов нашей грамматики будет множество состояний автомата. Для каждой пары состояний A и B такой, что имеется переход из A в B по символу c, добавим в грамматику правило A -> cB. Затем для каждой пары состояний автомата A и B такой, что имеется переход из A в B по символу c, и B является допускающим состоянием в автомате, добавим в грамматику правило A -> c.

Докажем, что если для автомата верно ⟨S,α⟩⊢∗⟨U,ε⟩, то для построенной грамматики верно S⇒∗αU. Будем доказывать индукцией по переходам в автомате.
Базой индукции будут переходы за 0 шагов.
Индукционный переход: пусть данное свойство выполняется для переходов длины k−1. Докажем, что верно и для переходов за k шагов.
Рассмотрим переход ⟨S,α⟩⊢k⟨U,ε⟩, а именно его последний шаг: ⟨S,α⟩⊢k−1⟨Q,c⟩⊢⟨U,ε⟩.
Так как для k−1 шага верно, то S⇒k−1αc−1Q, но по построению грамматики имеется правило Q -> cU, значит S⇒k−1αc−1Q⇒αc−1cU=αU. Таким образом, доказали для k шагов.

Докажем в обратную сторону, а именно из S⇒∗αU следует ⟨S,α⟩⊢∗⟨U,ε⟩. Доказательство также проведем по индукции. Индукция будет идти по количеству примененных подряд правил.
Базой индукции будут строки, выводимые в грамматике из начального нетерминала S за 0 применений правил.
Индукционный переход: пусть верно для k−1 применения правил. Рассмотрим произвольную строку, полученную за k применений правил. Рассмотрим последнее применение правила. Если оно имело вид A -> aB, значит в автомате возможен переход ⟨A,a⟩⊢⟨B,ε⟩, а если A -> a, то B является допускающим в автомате. Таким образом, свойство выполняется для k последовательно примененных правил. Эквивалентность языков автомата и грамматики доказана.

Теперь пусть имеется праволинейная грамматика. Построим по ней конечный детерминированный автомат. Введём специальное допускающее состояние ok. Множеством состояний автомата будет множество нетерминалов грамматики вместе с состоянием ok(Q=N∪ok). Для правил вида A -> aB определим функцию перехода в автомате как δ(A,a)=B. Для правил вида A -> a определим функцию перехода в автомате как δ(A,a)=ok.

Докажем, что если слово выводится в грамматике, то оно допускается автоматом. Рассмотрим последовательность применений правил, дающую слово α длины k. Для каждого правила вида A -> aB в автомате существует переход из состояния A в состояние B по символу a. Таким образом, если после k−1 применения правил мы можем получить строку вида αc−1B, то в автомате имеется соответствующая последовательность переходов ⟨S,α⟩⊢k−1⟨B,c⟩, а поскольку можно вывести α, то хотя бы для одной строки такого вида существует правило B -> c, а значит в автомате есть переход ⟨B,c⟩⊢⟨ok,ε⟩. Таким образом автомат допускает слово α.

Докажем, что если слово допускается автоматом, то его можно вывести в грамматике. Рассмотрим слово α длины k. Рассмотрим какую-либо последовательность переходов автомата, допускающую данное слово ⟨S,α⟩⊢k⟨ok,ε⟩. Для каждого одношагового перехода в автомате существует соответствующее правило в грамматике. Значит для подпоследовательности переходов из k−1 шага ⟨S,α⟩⊢k−1⟨U,c⟩ существует соответствующая последовательность применений правил S⇒k−1αc−1U. Для последнего перехода в автомате ⟨U,c⟩⊢⟨ok,ε⟩ существует правило U⇒c. Таким образом, существует последовательность применений правил грамматики, выводящая слово α.
================================================================
Автоматы называются изоморфными
________________________________________________________________
если существует биекция между их вершинами такая, что сохраняются все переходы, терминальные состояния соответствуют терминальным, а начальные — начальным.
================================================================
Задано два детерминированных конечных автомата. Определить, изоморфны ли они друг другу. Гарантируется, что все состояния автоматов достижимы.
________________________________________________________________
Алгоритм
Из определения следует, что если автоматы изоморфны, то можно их состояния занумеровать одним способом так, что вершины из разных автоматов с одинаковыми номерами будут равны — то есть в каждом из этих двух состояний существует переход в какое-то состояние с таким же номером, что и переход по этой же букве в другом состоянии. Поэтому мы можем зафиксировать какую-то нумерацию, например, в порядке обхода в глубину по символам в лексикографическом порядке и просто проверить состояния с одинаковыми номерами на равенство. Если все состояния будут равны, то автоматы будут равны, в нашем случае будет следовать изоморфизм двух автоматов. Асимптотика алгоритма совпадает с асимптотикой обхода в глубину, то есть O(N+M), где N — суммарное число вершин в автоматах, M — суммарное число ребер.

Псевдокод
Transitions — множество пар ⟨a, T⟩ , где a∈Σ, T∈Q
Assotiations — массив, где каждому состоянию первого автомата соответствует найденное состояние второго автомата.

boolean dfs(u: Vertex, v: Vertex): 
   visited[u] = true   // заметим, что достаточно только одного массива visited на два автомата
   
   if (v.terminal != u.terminal)
     return false   
   associations[u] = v
   boolean result = true
   for (⟨c,q⟩ : u.transitions)      
     Vertex t1 = u.transitions.getVertex(c)
     Vertex t2 = v.transitions.getVertex(c)
     if одна из вершин t1, t2 дьявольская, а другая — нет
       return false
     if (visited[t1]) 
       result = result and t2 == associations[t1]
     else
       result = result and dfs(t1, t2)                
         
   return result
================================================================
Полукольцо S = ⟨A, ⊕, ⊗, 0⟩ над носителем A
________________________________________________________________
это алгебраическая структура такая, что:
S — коммутативный моноид по ⊕;
S — полугруппа по ⊗;
0 — это id по сложению и ноль по умножению;
выполнены левая и правая дистрибутивности.
================================================================
Алгебра Клини ⟨Σ, |, ·, ∗, ∅, ε⟩
________________________________________________________________
идемпотентное полукольцо с единицей, удовлетворяющее следующим аксиомам:
1) x∗x + 1 = x∗ = 1 + xx∗(аксиома развёртки)
2) (формализация Саломаа, Sal): ∀p, q, x ((p | qx = x ⇒ x = q∗p) & (p | xq = x ⇒ x = pq∗)), где q не распознаёт ε — левая и правая леммы Ардена;
3) (формализация Козена, Koz): ∀p, q, x ((q | px <= x ⇒ p∗q <= x) & (q | xp <= x ⇒ qp∗ <= x)), где x <= y ⇔ x | y = y, x = y ⇔ x <= y & y <= x.

Аксиома -- Сокращение
x | x = x -- (Idm)
ε | xx∗ = x∗,  ε | x∗x = x∗ -- (Unfold) 
(x | y)z = xz | yz, x(y | z) = xy | xz -- (Dstr) 
q | px <= x ⇒ p∗q <= x, q | xp <= x ⇒ qp∗ <= x -- (Koz) 
================================================================
Некоторые теоремы алгебры Клини и их приминения
________________________________________________________________
(Bsm) ax = xb ⇒ a∗x = xb∗ (Бисимуляция)
(Sld) x(yx)∗ = (xy)∗x (Сдвиг)
(Dnst) x∗(yx∗)∗ = (x | y)∗ (Уплощение)

Законы сдвига и уплощения используются в оптимизациях
регулярных событий: закон сдвига позволяет перестраивать циклы с поствычислениями в циклы с предвычислениями; закон уплощения позволяет перестраивать друг в друга вложенные циклы и циклы с условиями внутри итерации.
================================================================
Теорема о полноте Sal и Koz (формализация Саломаа и Козена)
________________________________________________________________
Любое равенство регулярных выражений выводимо из аксиоматики Sal и аксиоматики Koz.
================================================================
Смысл леммы Ардена и Козена
________________________________________________________________
Неподвижная точка функции f(x) — такое x, что f(x) = x.
Пусть X = (pX) | q, где X — неизвестное RE, а p, q — известные, причём ε не принадлежит L(p). Тогда X = (p)∗q.
То есть p∗q — наименьшая (но не единственная) неподвижная точка выражения px | q по отношению <=, и единственная, если ε не принадлежит L(p).
Рассмотрим систему уравнений:
X1 = (A_11X_1) | (A_12X_2) | . . . | B_1
X2 = (A_21X_1) | (A_22X_2) | . . . | B_2
. . .
Xn = (A_n1X_1) | (A_n2X_2) | . . . | B_n
Положим ε не принадлежит A_ij. Выразим X_1 через X_2, . . . , X_n, X_2 через X_3. . . X_n и т.д. Получим регулярное выражение для X_n (и после обратных подстановок также для X_n-1,. . . ,X_1).









