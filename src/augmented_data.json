[
    {
        "question": "Дай определение надрегулярного множества в теории формальных языков. Определи множество регулярных языков",
        "answer": "____\nПусть задан алфавит Σ={c1,c2,…,ck}.\nМножество R\n будем называть надрегулярным множеством над алфавитом Σ, если:\n\nR0⊂R, где R0={∅,{ε},{c1},{c2},…,{ck}},\nL1,L2∈R⇒L1∪L2∈R,L1L2∈R,L∗1∈R.\nТогда множеством регулярных языков REG′\n над алфавитом Σ={c1,c2,…,ck}\n называется пересечение всех надрегулярных множеств над этим алфавитом."
    },
    {
        "question": "Дайте определение суперрегулярного множества в теории формальных языков. Определите множество регулярных языков",
        "answer": "____\nПусть задан алфавит Σ={c1,c2,…,ck}.\nМножество R\nбудем называть суперрегулярным множеством над алфавитом Σ, если:\n\nR0⊂R, где R0={∅,{ε},{c1},{c2},…,{ck}},\nL1,L2∈R⇒L1∪L2∈R,L1L2∈R,L∗1∈R.\nТогда множество регулярных языков REG′\nнад алфавитом Σ={c1,c2,…,ck}\nявляется пересечением всех суперрегулярных множеств над этим алфавитом."
    },
    {
        "question": "Дайте определение суперрегулярного множества в теории формальных языков. Определение множества обычных языков",
        "answer": "____\nПусть алфавит Σ={c1,c2,…,ck}.\nОпределить R\nбудем называть суперрегулярным множеством в алфавите Σ, если:\n\nR0⊂R, где R0={∅,{ε},{c1},{c2},…,{ck}},\nL1, L2€R⇒L1∪L2€R, L1L2€R, L∗1€R.\nТогда множество регулярных языков REG′\nна алфавите Σ={c1,c2,…,ck}\nявляется пересечением всех суперрегулярных множеств этого алфавита."
    },
    {
        "question": "Дайте определение суперрегулярного множества в теории формальных языков. Определить набор обычных языков",
        "answer": "____\nПусть алфавит Σ={c1,c2,…,ck}.\nОпределить R\n будем называть супрарегулярным множеством в алфавите Σ, если:\n\nR0⊂R, где R0={∅,{ε},{c1},{c2},…,{ck}},\nL1, L2€R⇒L1∪L2€R, L1L2€R, L∗1€R.\nТогда множество регулярных языков REG′\n на алфавите Σ={c1,c2,…,ck}\n является пересечением всех суперрегулярных множеств этого алфавита."
    },
    {
        "question": "как проверить пару детерминированных конечных автоматов на эквивалентность с помощью поиска в ширину?",
        "answer": "____\nДва автомата можно также проверить на эквивалентность, используя обход в ширину. Будем синхронно обходить два автомата, начиная со стартовых состояний, в поисках такой строки, которая различает два состояния этих автоматов. То есть она будет допускаться одним автоматом, но не будет принадлежать языку другого.\n\nПоскольку эквивалентные автоматы допускают один и тот же язык, при переходе по одним и тем же символам в обоих автоматах, слово должно приниматься обоими автоматами одновременно. То есть вершины, в которые мы перешли, должны быть либо одновременно терминальными, либо одновременно нетерминальными, что и проверяет приведённый алгоритм.\n\nПсевдокод\n// aut[i][c]\n — номер состояния, в которое есть переход из состояния i\n по символу c\n\nboolean bfsEquivalenceCheck\n(aut1\n : int[][], aut2\n : int[][]):\n    Q.push(⟨s1,s2⟩)\n // Q\n — очередь из пар состояний\n    while Q≠∅\n \n        u,v←Q.pop()\n\n        if isTerminal1[u]≠isTerminal2[v]\n\n            return false\n        used[u][v]←\n true\n        for c∈Σ\n\n            if not used[aut1[u][c]][aut2[v][c]]\n\n                Q.push(⟨aut1[u][c],aut2[v][c]⟩)\n\n    return true\nКорректность алгоритма следует из строго доказательства того факта, что если два состояния u\n и v\n различаются какой-то строкой, то они различаются строкой длины O(n).\n\nИнтуитивное понимание алгоритма такое: пусть по строке w\n мы пришли в состояния ⟨u,v⟩, и пусть они оба нетерминальные. После этого совершим переход по символу c\n в состояния ⟨u′,v′⟩.\n\nТогда если isTerminal1[u′]≠isTerminal2[v′], то строка wc\n различает эти два состояния. А значит автоматы не эквивалентны."
    },
    {
        "question": "Как проверить эквивалентность пары детерминированных конечных автоматов с помощью поиска в ширину?",
        "answer": "____\nДва автомата также можно проверить на эквивалентность с помощью обхода в ширину. Мы будем синхронно проходить два автомата, начиная с начальных состояний, в поисках строки, которая различает два состояния этих автоматов. То есть она будет принята одним автоматом, но не будет принадлежать языку другого.\n\nПоскольку эквивалентные автоматы принимают один и тот же язык, при движении по одним и тем же символам в обоих автоматах слово должно быть принято обоими автоматами одновременно. То есть вершины, в которые мы перешли, должны быть либо одновременно конечными, либо одновременно неконечными, что и проверяет данный алгоритм.\n\nПсевдокод\n// aut[i][c]\n— номер состояния, в которое происходит переход из состояния i\nпо символу c\n\nboolean bfsEquivalenceCheck\n(aut1\n: int[][], aut2\n: int[][]):\nQ.push(⟨s1,s2⟩)\n// Q\n— очередь пар состояний\nwhile Q≠∅\n\nu,v←Q.pop()\n\nif isTerminal1[u]≠isTerminal2[v]\n\nreturn false\nused[u][v]←\ntrue\nfor c∈Σ\n\nif not used[aut1[u][c]][aut2[v][c]]\n\nQ.push(⟨aut1[u][c],aut2[v][c]⟩)\n\nreturn true\nКорректность алгоритма следует из строгого доказательства того, что если два состояния u\nи v\nотличаются на некоторую строку, то они отличаются на строку длины O(n).\n\nИнтуитивное понимание алгоритма таково: придем к состояниям ⟨u,v⟩ по строке w\n, и пусть они оба нетерминальные. После этого мы делаем переход по символу c\nв состояния ⟨u′,v′⟩.\n\nТогда если isTerminal1[u′]≠isTerminal2[v′], то строка wc\nотличает эти два состояния. Это означает, что автоматы не эквивалентны."
    },
    {
        "question": "Как проверить эквивалентность пары детерминированных конечных автоматов с помощью поиска в ширину?",
        "answer": "____\nЭквивалентность двух автоматов можно проверить и сканированием в ширину. Будем синхронно обходить два автомата, начиная с начальных состояний, ища линию, различающую два состояния этих автоматов. Другими словами, он будет принят одной машиной, но не будет принадлежать языку другой.\n\nПоскольку эквивалентные машины принимают один и тот же язык, при перемещении по одним и тем же символам в обеих машинах слово должно быть принято обеими машинами одновременно. Другими словами, вершины, в которые мы переместились, должны быть либо одновременно конечными, либо одновременно неконечными, что и проверяет данный алгоритм.\n\nПсевдокод\n//авто[i][c]\n— номер состояния, в которое происходит переход из состояния i\nсимволом с\n\nлогическое значение bfsEquivalenceCheck\n(авто1\n: int[][], аут2\n:int[][]):\nQ.push(⟨s1,s2⟩)\n// Вопрос\n— очередь пар состояний\nв то время как Q≠∅\n\nu,v ←Q.pop()\n\nесли isTerminal1[u]≠isTerminal2[v]\n\nвернуть ложь\nб/у[u][v] ←\nистинный\nдля cεΣ\n\nесли не используется[aut1[u][c]][aut2[v][c]]\n\nQ.push(⟨aut1[u][c],aut2[v][c]⟩)\n\nвернуть истину\nКорректность алгоритма обусловлена ​​строгим доказательством того, что если два состояния u\nи в\nотличаются на некоторую строку, то они отличаются на строку длины O(n).\n\nИнтуитивное понимание алгоритма следующее: к состояниям ⟨u,v⟩ приходим по цепочке w\n, и что они оба нетерминальные. После этого переходим к символу c\nв состояниях ⟨u′,v′⟩.\n\nТаким образом, если isTerminal1[u′]≠isTerminal2[v′], то строка wc\nразличает эти два состояния. Это означает, что автоматы не эквивалентны."
    },
    {
        "question": "как проверить эквивалентность пары детерминированных конечных автоматов с помощью поиска в ширину?",
        "answer": "____\nЭквивалентность двух автоматов можно проверить и сканированием в ширину. Мы пройдемся по двум автоматам синхронно, начиная со стартовых состояний, ища линию, различающую два состояния этих автоматов. Другими словами, он будет принят одной машиной, но не будет принадлежать языку другой.\n\nПоскольку эквивалентные автоматы принимают один и тот же язык, при использовании одних и тех же символов в обоих автоматах слово должно быть принято обоими автоматами одновременно. То есть вершины, в которые мы переместились, должны быть либо одновременно терминальными, либо одновременно нетерминальными, что и проверяется данным алгоритмом.\n\nПсевдокод\n//авто[i][c]\n — номер состояния, в которое происходит переход из состояния i\n символом с\n\nлогическое значение bfsEquivalenceCheck\n(авто1\n : int[][], аут2\n :int[][]):\n    Q.push(⟨s1,s2⟩)\n // Вопрос\n — очередь пар состояний\n    в то время как Q≠∅\n \n        u,v ←Q.pop()\n\n        если isTerminal1[u]≠isTerminal2[v]\n\n            вернуть ложь\n        б/у[u][v] ←\n истинный\n        для cεΣ\n\n            если не используется[aut1[u][c]][aut2[v][c]]\n\n                Q.push(⟨aut1[u][c],aut2[v][c]⟩)\n\n    вернуть истину\nКорректность алгоритма возникает из строгого доказательства того факта, что если два состояния u\n и в\n отличаются на строку, то они отличаются на строку длины O(n).\n\nИнтуитивное понимание алгоритма таково: пусть строка w\n мы пришли к состояниям ⟨u,v⟩, и оба они нетерминальные. После этого будем двигаться по символу c\n в состояниях ⟨u′,v′⟩.\n\nТаким образом, если isTerminal1[u′]≠isTerminal2[v′], то строка wc\n различает эти два состояния. Это означает, что машины не эквивалентны."
    },
    {
        "question": "Какими свойствами обладают КС-языки относительно операций объединения, конкатенации, замыкания Клини, прямого гомоморфизма?",
        "answer": "____\nОбъединение\nL1∪L2\n  является КС-языком.\nДоказательство:\nПостроим КС-грамматику для языка L1∪L2. Для этого рассмотрим соответствующие КС-грамматики для языков L1\n и L2. Пусть стартовые символы в них имеют имена S\n и T\n соответственно. Тогда стартовый символ для L1∪L2\n обозначим за S′\n и добавим правило S′→S∣T.\n\nПокажем, что S′⇒∗w⟺S⇒∗w∨T⇒∗w.\n\n⇒\n\nПоскольку S⇒∗w\n и есть правило S′→S\n, то, по определению ⇒∗\n получаем, что S′⇒∗w. Аналогично и для T.\n⇐\n\nПусть S′⇒∗w. Поскольку S′→S∣T\n — единственные правила, в которых нетерминал S′\n присутствует в правой части, то это означает, что либо S′⇒S⇒∗w, либо S′⇒T⇒∗w.\n\nКонкатенация  \nL1L2\n — КС-язык.\nДоказательство\nНужно использовать идею прошлого доказательства и построить КС-грамматику для L1L2 с правилом S′→ST, где S\n и T\n — стартовые символы языков L1\n и L2\n соответственно.\n \nL∗=⋃i=0∞Li\n  — КС-язык.\n\nГомоморфизм\nКС-языки замкнуты относительно прямого гомоморфизма.\n\nОбратный гомоморфизм\nКС-языки замкнуты относительно обратного гомоморфизма.\n\nПересечение\nЕсли L1=aibicj,L2=aibjcj\n, то L1∩L2\n не является КС-языком.\n \nРазворот\nL^R={w^R∣w∈L}\nконтекстно-свободен."
    },
    {
        "question": "Какими свойствами обладают языки CF относительно операций объединения, конкатенации, замыкания Клини и прямого гомоморфизма?",
        "answer": "____\nОбъединение\nL1∪L2\nявляется CF-языком.\nДоказательство:\nПостроим CF-грамматику для языка L1∪L2. Для этого рассмотрим соответствующие CF-грамматики для языков ​​L1\nи L2. Пусть начальные символы в них будут называться S\nи T\nсоответственно. Затем обозначим начальный символ для L1∪L2\nчерез S′\nи добавим правило S′→S∣T.\n\nПокажем, что S′⇒∗w⟺S⇒∗w∨T⇒∗w.\n\n⇒\n\nПоскольку S⇒∗w\nявляется правилом S′→S\n, то по определению ⇒∗\nполучаем, что S′⇒∗w. Аналогично для T.\n⇐\n\nПусть S′⇒∗w. Поскольку S′→S∣T\nявляются единственными правилами, в которых нетерминал S′\nприсутствует в правой части, это означает, что либо S′⇒S⇒∗w, либо S′⇒T⇒∗w.\n\nКонкатенация\nL1L2\nявляется CFG.\nДоказательство\nНам нужно использовать идею предыдущего доказательства и построить CFG для L1L2 с правилом S′→ST, где S\nи T\nявляются начальными символами языков ​​L1\nи L2\nсоответственно.\n\nL∗=⋃i=0∞Li\nявляется CFG.\n\nГомоморфизм\nCFG замкнуты относительно прямого гомоморфизма.\n\nОбратный гомоморфизм\nЯзыки CF замкнуты относительно обратного гомоморфизма.\n\nПересечение\nЕсли L1=aibicj,L2=aibjcj\n, то L1∩L2\nне является языком CF.\n\nОбращение\nL^R={w^R∣w∈L}\nконтекстно-свободно."
    },
    {
        "question": "Какими свойствами обладают языки CF в отношении объединения, конкатенации, замыкания Клини и операций прямого гомоморфизма?",
        "answer": "____\nАссоциация\nL1∪L2\nэто язык CF.\nДоказательство:\nПостроим CF-грамматику для языка L1∪L2. Для этого рассмотрим соответствующие CF-грамматики для языков L1.\nи Л2. Пусть их начальные символы будут называться S\nи Т\nсоответственно. Далее обозначим стартовый символ для L1∪L2\nчерез S'\nи добавим правило S′→S∣T.\n\nПокажем, что S′⇒∗w⟺S⇒∗w∨T⇒∗w.\n\n⇒\n\nПоскольку S⇒∗w\nэто правило S′→S\n, то по определению ⇒∗\nмы находим, что S′⇒∗w. Аналогично и для Т.\n⇐\n\nПусть S′⇒∗w. Поскольку S′→S∣T\n— единственные правила, в которых нетерминал S'\nприсутствует в правой части, это означает, что либо S′⇒S⇒∗w, либо S′⇒T⇒∗w.\n\nЦепочка\nЛ1Л2\nэто CFG.\nДоказательство\nМы должны взять идею из предыдущего доказательства и построить КФГ для L1L2 с правилом S′→ST, где S\nи Т\nявляются начальными символами языков L1\nи L2\nсоответственно.\n\nL∗=⋃i=0∞Li\nэто CFG.\n\nГомоморфизм\nКФГ замкнуты относительно прямого гомоморфизма.\n\nОбратный гомоморфизм\nЯзыки CF замкнуты относительно обратного гомоморфизма.\n\nПересечение\nЕсли L1=aibicj,L2=aibjcj\n, то L1∩L2\nне является языком CF.\n\nВызов\nL^R={w^R∣wاL}\nвне контекста."
    },
    {
        "question": "Какими свойствами обладают языки KS относительно операций объединения, конкатенации, замыкания Клини и прямого гомоморфизма?",
        "answer": "____\nАссоциация\nL1∪L2\n  это язык CS.\nДоказательство:\nПостроим KS-грамматику для языка L1∪L2. Для этого рассмотрим соответствующие КС-грамматики для языков L1.\n и Л2. Пусть стартовые символы в них имеют S названий\n и Т\n соответственно. Тогда стартовый символ для L1∪L2\n отметил S'\n и добавим правило S′→S∣T.\n\nПокажем, что S′⇒∗w⟺S⇒∗w∨T⇒∗w.\n\n⇒\n\nПоскольку S⇒∗w\n и существует правило S′→S\n, то по определению ⇒∗\n мы находим, что S′⇒∗w. Аналогично и для Т.\n⇐\n\nПусть S′⇒∗w. Поскольку S′→S∣T\n — единственные правила, в которых нетерминал S'\n присутствует в правой части, это означает, что либо S′⇒S⇒∗w, либо S′⇒T⇒∗w.\n\nЦепочка  \nЛ1Л2\n — Язык КС.\nДоказательство\nНам нужно воспользоваться идеей предыдущего доказательства и построить KS-грамматику для L1L2 с правилом S′→ST, где S\n и Т\n — начальные символы языков L1\n и L2\n соответственно.\n \nL∗=⋃i=0∞Li\n  — Язык КС.\n\nГомоморфизм\nЯзыки КС замкнуты относительно прямого гомоморфизма.\n\nОбратный гомоморфизм\nЯзыки КС замкнуты относительно обратного гомоморфизма.\n\nПересечение\nЕсли L1=aibicj,L2=aibjcj\n, то L1∩L2\n не является языком CS.\n \nразворот\nL^R={w^R∣wاL}\nвне контекста."
    },
    {
        "question": "докажи, что язык алфавитной префиксной грамматики регулярен",
        "answer": "____\nОпределение APG\nДана SRS S с правилами переписывания двух видов:\nai → b1 . . . bn ai → ε\nРазрешим применять правила только к первым буквам\nслова. Пусть дана пара ⟨S, w0⟩, где w0 — слово в алфавите\nΣ. Эта пара определяет алфавитную префиксную\nграмматику.\nУтверждение\nЯзык L⟨S, w0⟩ регулярен.\n2 / 24\n▲\nАлфавитные префиксные грамматики\nУтверждение\nЯзык L⟨S, w0⟩ регулярен.\nСкажем, что a ↠ ε (a коллапсирует), если либо a → ε ∈ S, либо\n∃b1, . . . , bn(∀bi(bi ↠ ε) & a → b1 . . . bn ∈ S).\nПо APG ⟨S, s1 . . . sn⟩ породим праволинейную грамматику G. Каждому\nсимволу алфавита ai сопоставим Ai — нетерминал G.\n1 Пусть a → b1 . . . bn и ∃bi(¬(bi ↠ ε) & ∀j(j < i ⇒ bj ↠ ε)).\nТогда добавим в G правила A → B1b2 . . . bn, A → B2b3 . . . bn,. . . ,\nA → Bibi+1 . . . bn, A → a.\n2 Если такого bi нет, добавляем в G все правила вида\nA → B1b2 . . . bn, . . . , A → Bn−1bn, A → Bn, A → a.\n3 Вводим стартовый нетерминал S и для него добавляем развёртку в\nисходное слово s1 . . . sm по правилам выше.\n4 Если все si коллапсируют, тогда добавляем в G правило S → ε.\n2 / 24\n▲\nАлфавитные префиксные грамматики\nСкажем, что a ↠ ε (a коллапсирует), если либо a → ε ∈ S, либо\n∃b1, . . . , bn(∀bi(bi ↠ ε) & a → b1 . . . bn ∈ S).\nПо APG ⟨S, s1 . . . sn⟩ породим праволинейную грамматику G. Каждому\nсимволу алфавита ai сопоставим Ai — нетерминал G.\n1 Пусть a → b1 . . . bn и ∃bi(¬(bi ↠ ε) & ∀j(j < i ⇒ bj ↠ ε)).\nТогда добавим в G правила A → B1b2 . . . bn, A → B2b3 . . . bn,. . . ,\nA → Bibi+1 . . . bn, A → a.\n2 Если такого bi нет, добавляем в G все правила вида\nA → B1b2 . . . bn, . . . , A → Bn−1bn, A → Bn, A → a.\n3 Вводим стартовый нетерминал S и для него добавляем развёртку в\nисходное слово s1 . . . sm по правилам выше.\n4 Если все si коллапсируют, тогда добавляем в G правило S → ε.\nОстается сделать развертку правил вида A → Bn, либо перейти от G к\nНКА с ε-переходами.\n2 / 24\n▲"
    },
    {
        "question": "доказать, что язык алфавитной префиксной грамматики является регулярным",
        "answer": "____\nОпределение APG\nДана SRS S с двумя видами правил переписывания:\nai → b1 . . . bn ai → ε\nРазрешить правилам применяться только к первым буквам\nслова. Пусть дана пара ⟨S, w0⟩, где w0 — слово в алфавите\nΣ. Эта пара определяет алфавитную префиксную\nграмматику.\nУтверждение\nЯзык L⟨S, w0⟩ является регулярным.\n2 / 24\n▲\nАлфавитные префиксные грамматики\nУтверждение\nЯзык L⟨S, w0⟩ является регулярным.\nСкажем, что a ↠ ε (a схлопывается), если либо a → ε ∈ S, либо\n∃b1, . . . , bn(∀bi(bi ↠ ε) & a → b1 . . . bn ∈ S).\nДля заданного APG ⟨S, s1 . . . sn⟩ мы генерируем праволинейную грамматику G. Каждому\nсимволу алфавита ai мы назначаем Ai, нетерминал G.\n1 Пусть a → b1 . . . bn и ∃bi(¬(bi ↠ ε) & ∀j(j < i ⇒ bj ↠ ε)).\nЗатем мы добавляем к G правила A → B1b2 . . . bn, A → B2b3 . . . bn,. . . ,\nA → Bibi+1 . . . bn, A → a.\n2 Если такого bi нет, то добавляем к G все правила вида\nA → B1b2 . . . bn, . . . , A → Bn−1bn, A → Bn, A → a.\n3 Вводим начальный нетерминал S и добавляем расширение для него в\nисходное слово s1 . . . sm согласно правилам выше.\n4 Если все si схлопываются, то добавляем к G правило S → ε.\n2 / 24\n▲\nАлфавитные префиксные грамматики\nМы говорим, что a ↠ ε (a схлопывается), если либо a → ε ∈ S, либо\n∃b1, . . . , bn(∀bi(bi ↠ ε) & a → b1 . . . bn ∈ S).\nДано APG ⟨S, s1 . . . sn⟩, мы генерируем праволинейную грамматику G. Каждому символу алфавита ai мы назначаем Ai, нетерминал G.\n1 Пусть a → b1 . . . bn и ∃bi(¬(bi ↠ ε) & ∀j(j < i ⇒ bj ↠ ε)).\nЗатем мы добавляем к G правила A → B1b2 . . . bn, A → B2b3 . . . bn,. . . ,\nA → Bibi+1 . . . bn, A → a.\n2 Если такого bi нет, добавляем к G все правила вида\nA → B1b2 . . . bn, . . . , A → Bn−1bn, A → Bn, A → a.\n3 Вводим начальный нетерминал S и добавляем для него расширение в\nисходное слово s1 . . . sm по правилам выше.\n4 Если все si разрушаются, то добавляем к G правило S → ε.\nОстается сделать расширение правил вида A → Bn, или перейти от G к\nНКА с ε-переходами.\n2 / 24\n▲"
    },
    {
        "question": "доказать, что грамматический язык с алфавитным префиксом является регулярным",
        "answer": "____\nОпределение ПНГ\nДан SRS S с двумя типами правил перезаписи:\nай → b1. . . bn ai → ε\nРазрешить правилам применяться только к первым буквам\nслова. Рассмотрим пару ⟨S, w0⟩, где w0 — слово алфавита\nΣ. Эта пара определяет алфавитный префикс\nграмматика.\nЗаявление\nЯзык L⟨S, w0⟩ регулярен.\n2 / 24\n▲\nГрамматики алфавитных префиксов\nЗаявление\nЯзык L⟨S, w0⟩ регулярен.\nСкажем, что a ↠ ε (a коллапсирует), если либо a → ε ∈ S, либо\n∃b1, . . . , bn(∀bi(bi ↠ ε) & a → b1 . . bn ∈ S).\nДля ПНГ ⟨S, s1. . . sn⟩ мы генерируем прямую линейную грамматику G. Каждая\nалфавитному символу ai мы приписываем Ai, нетерминал G.\n1 Пусть a → b1. . . bn и ∃bi(¬(bi ↠ ε) & ∀j(j < i ⇒ bj ↠ ε)).\nЗатем мы добавляем правила A → B1b2 в G. . . лол, А → B2b3. . . хорошо,. . . ,\nА → Биби+1. . . мкр, А → а.\n2 Если такого би не существует, то добавим к G все правила вида\nА → Б1б2. . . хорошо, . . . , A → Bn−1bn, A → Bn, A → a.\n3 Введите начальный нетерминал S и добавьте к нему расширение в\nисходное слово s1. . . см по правилам выше.\n4 Если все if схлопываются, то добавляем в G правило S → ε.\n2 / 24\n▲\nГрамматики алфавитных префиксов\nМы говорим, что a ↠ ε (a коллапсирует), если либо a → ε ∈ S, либо\n∃b1, . . . , bn(∀bi(bi ↠ ε) & a → b1 . . bn ∈ S).\nДано APG ⟨S, s1. . . sn⟩, мы генерируем прямую линейную грамматику G. Каждому символу алфавита ai мы присваиваем Ai, нетерминал G.\n1 Пусть a → b1. . . bn и ∃bi(¬(bi ↠ ε) & ∀j(j < i ⇒ bj ↠ ε)).\nЗатем мы добавляем правила A → B1b2 в G. . . лол, А → B2b3. . . хорошо,. . . ,\nА → Биби+1. . . мкр, А → а.\n2 Если такого bi нет, добавим к G все правила вида\nА → Б1б2. . . хорошо, . . . , A → Bn−1bn, A → Bn, A → a.\n3 Введите начальный нетерминал S и добавьте к нему расширение в\nисходное слово s1. . . см по правилам выше.\n4 Если все if уничтожены, то добавляем в G правило S → ε.\nОсталось расширить правила вида A → Bn, т.е. перейти от G к\nНКА с ε-переходами.\n2 / 24\n▲"
    },
    {
        "question": "докажите, что буквенный префикс грамматики языка регулярен",
        "answer": "____\nОпределение ПНГ\nДан SRS S с двумя типами правил перезаписи:\nай → b1. . . bn ai → ε\nПусть правила касаются только первых букв\nслова. Рассмотрим пару ⟨S, w0⟩, где w0 — слово алфавита\nΣ. Эта пара определяет алфавитный префикс\nграмматика.\nЗаявление\nЯзык L⟨S, w0⟩ регулярен.\n2 / 24\n▲\nГрамматики алфавитных префиксов\nЗаявление\nЯзык L⟨S, w0⟩ регулярен.\nСкажем, что a ↠ ε (a коллапсирует), если либо a → ε ∈ S, либо\n∃b1, . . . , bn(∀bi(bi ↠ ε) & a → b1 . . bn ∈ S).\nПо ПНГ ⟨S, s1. . . sn⟩ порождает праволинейную грамматику G. Каждая\nбуквенному символу ai сопоставляем Ai — нетерминал группы G.\n1 Пусть a → b1. . . bn и ∃bi(¬(bi ↠ ε) & ∀j(j < i ⇒ bj ↠ ε)).\nЗатем добавим правила A → B1b2 в G. . . лол, А → B2b3. . . хорошо,. . . ,\nА → Биби+1. . . мкр, А → а.\n2 Если такого bi нет, добавим к G все правила вида\nА → Б1б2. . . хорошо, . . . , A → Bn−1bn, A → Bn, A → a.\n3 Введите начальный нетерминал S и добавьте к нему расширение в\nисходное слово s1. . . см по правилам выше.\n4 Если все if схлопываются, то добавляем в G правило S → ε.\n2 / 24\n▲\nГрамматики алфавитных префиксов\nСкажем, что a ↠ ε (a коллапсирует), если либо a → ε ∈ S, либо\n∃b1, . . . , bn(∀bi(bi ↠ ε) & a → b1 . . bn ∈ S).\nПо ПНГ ⟨S, s1. . . sn⟩ порождает праволинейную грамматику G. Каждая\nбуквенному символу ai сопоставляем Ai — нетерминал группы G.\n1 Пусть a → b1. . . bn и ∃bi(¬(bi ↠ ε) & ∀j(j < i ⇒ bj ↠ ε)).\nЗатем добавим правила A → B1b2 в G. . . лол, А → B2b3. . . хорошо,. . . ,\nА → Биби+1. . . мкр, А → а.\n2 Если такого bi нет, добавим к G все правила вида\nА → Б1б2. . . хорошо, . . . , A → Bn−1bn, A → Bn, A → a.\n3 Введите начальный нетерминал S и добавьте к нему расширение в\nисходное слово s1. . . см по правилам выше.\n4 Если все if схлопываются, то добавляем в G правило S → ε.\nОсталось расширить правила вида A → Bn, т.е. перейти от G к\nНКА с ε-переходами.\n2 / 24\n▲"
    },
    {
        "question": "напиши лемму Ардена",
        "answer": "____\nПусть X = (pX) | q, где X — неизвестное RE, а p, q —\nизвестные, причём ε /∈ L (p). Тогда X = (p)\n∗q.\nТо есть p\n∗q — наименьшая (но не единственная) неподвижная\nточка выражения px | q по отношению ⩽, и единственная, если\nε /∈ L (p)."
    },
    {
        "question": "написать лемму Ардена",
        "answer": "____\nПусть X = (pX) | q, где X — неизвестное РЭ, а p, q известны, причем ε /∈ L (p). Тогда X = (p)\n∗q.\nТо есть, p\n∗q — наименьшая (но не единственная) неподвижная\nточка выражения px | q относительно ⩽, и единственная, если\nε /∈ L (p)."
    },
    {
        "question": "напиши лемму Ардена",
        "answer": "____\nПусть X = (pX) | q, где X — неизвестная РЭ, а p, q известны и ε /ε L (p). Тогда X = (p)\n∗q.\nТо есть п\n∗q — наименьшая (но не единственная) фиксированная\nточка выражения px | q относительно ⩽ и единственна, если\nε /ε L (p)."
    },
    {
        "question": "напиши лемму Ардена",
        "answer": "____\nПусть X = (pX) | q, где X — неизвестное RE, а p, q —\nизвестны и ε /ε L (p). Тогда X = (p)\n∗q.\nТо есть п\n∗q — наименьшая (но не единственная) фиксированная\nточка выражения px | q относительно ⩽ и единственна, если\nε /ε L (p)."
    },
    {
        "question": "Сформулируй теорему о замкнутости регулярных языыков",
        "answer": "____\nПусть L1,L2\n — регулярные языки над одним алфавитом Σ. Тогда следующие языки также являются регулярными:\n Языки, полученные путём применения следующих теоретико-множественных операций:\n L1∪L2,\n L1¯¯¯¯¯¯,\n L1∩L2,\n L1∖L2;\n L∗1;\n L1L2; \n L1←;"
    },
    {
        "question": "Сформулируйте теорему о закрытии регулярных языков.",
        "answer": "____\nПусть L1,L2\nбудут регулярными языками над одним алфавитом Σ. Тогда следующие языки также являются регулярными:\nЯзыки, полученные применением следующих теоретико-множественных операций:\nL1∪L2,\nL1¯¯¯¯¯¯¯,\nL1∩L2,\nL1∖L2;\nL∗1;\nL1L2;\nL1←;"
    },
    {
        "question": "Сформулируйте теорему замыкания для регулярных языков.",
        "answer": "____\nПусть L1,L2\nбудут регулярными языками на одном алфавите Σ. Тогда регулярными являются также следующие языки:\nЯзыки получены применением следующих операций теории множеств:\nЛ1∪Л2,\nL1¯¯¯¯¯¯¯¯,\nЛ1∩Л2,\nЛ1∖Л2;\nL∗1;\nЛ1Л2;\nЛ1 ←;"
    },
    {
        "question": "Сформулируйте теорему о замыкании регулярных языков.",
        "answer": "____\nПусть L1,L2\n — регулярные языки на алфавите Σ. Тогда регулярными являются также следующие языки:\n Языки получены применением следующих операций теории множеств:\n Л1∪Л2,\n Л1¯¯¯¯¯¯¯,\n Л1∩Л2,\n Л1∖Л2;\n L∗1;\n Л1Л2; \n Л1 ←;"
    },
    {
        "question": "Сформулируй теоремы о построении LL(k) грамматики без пустых правил",
        "answer": "____\nТеорема 1 \nДля всякой LL(k)-\nграмматики существует и может быть эффективно построена LL(k + 1)-грамматика\nбез пустых правил, задающая тот же язык.\n\nТеорема 2 \nДля всякой LL(k)-грамматики без пустых правил можно построить LL(k)-грамматику в н.в.Грейбах, задающую тот же язык."
    },
    {
        "question": "Сформулировать теоремы о построении грамматик LL(k) без пустых правил.",
        "answer": "____\nТеорема 1\nДля каждой LL(k)-\nграмматики существует и может быть эффективно построена LL(k + 1)-\nграмматика без пустых правил, определяющая тот же язык.\n\nТеорема 2\nДля каждой LL(k)-грамматики без пустых правил можно построить LL(k)-\nграмматику в Н. В. Грейбахе, определяющую тот же язык."
    },
    {
        "question": "Сформулируйте теоремы о построении LL(k)-грамматик без пустых правил.",
        "answer": "____\nТеорема 1\nДля каждого LL(k)-\nграмматика существует и может быть эффективно построена LL(k + 1)-\nграмматика без пустых правил, определяющих один и тот же язык.\n\nТеорема 2\nДля любой LL(k)-грамматики без пустых правил мы можем построить LL(k)-грамматику:\nграмматика у Н. В. Грейбаха, определяющая тот же язык."
    },
    {
        "question": "Сформулируйте теоремы о построении LL(k)-грамматики без пустых правил.",
        "answer": "____\nТеорема 1 \nДля всех LL(k)-\nграмматика существует, и грамматику LL(k + 1) можно эффективно построить\nбез пустых правил, определяющих один и тот же язык.\n\nТеорема 2 \nДля любой LL(k)-грамматики без пустых правил можно построить LL(k)-грамматику на языке Н.В.Грейбаха, определяющую тот же язык."
    },
    {
        "question": "Сформулируй лемму Розенкранца и Стирнса для обыкновенной грамматики",
        "answer": "____\nЛемма 1 (Розенкранц и Стирнс [1970]). Для всякой обыкновенной грамматики G =\n(Σ, N, R, S), существует другая грамматика G0 = (Σ, N ∪ N0, R0, S0), где N0 = { A0| A ∈\nN }, удовлетворяющая следующим условиям.\n1. Всякий нетерминальный символ A ∈ N задаёт в G0 тот же язык, что и в G.\n2. Всякий нетерминальный символ A0 ∈ N в G0\nзадаёт тот же язык, что и в G, с\nисключённой пустой строкой: LG0(A0) = LG(A0) \\ {ε}. В частности, L(G0) = L(G) \\{ε}.\n3. Никакое правило из R0 не начинается с нетерминального символа из N.\n4. Если G — LL(k), то и G0 — тоже LL(k)."
    },
    {
        "question": "Сформулируйте лемму Розенкранца-Стернса для обычной грамматики.",
        "answer": "____\nЛемма 1 (Розенкранц и Стернс [1970]). Для каждой обычной грамматики G =\n(Σ, N, R, S) существует другая грамматика G0 = (Σ, N ∪ N0, R0, S0), где N0 = { A0| A ∈\nN }, удовлетворяющая следующим условиям.\n1. Каждый нетерминальный символ A ∈ N определяет в G0 тот же язык, что и в G.\n2. Каждый нетерминальный символ A0 ∈ N в G0\nопределяет тот же язык, что и в G, с\nисключенной пустой строкой: LG0(A0) = LG(A0) \\ {ε}. В частности, L(G0) = L(G) \\ {ε}.\n3. Ни одно правило из R0 не начинается с нетерминального символа из N.\n4. Если G есть LL(k), то G0 также есть LL(k)."
    },
    {
        "question": "Сформулируйте лемму Розенкранца-Стернса для обычной грамматики.",
        "answer": "____\nЛемма 1 (Розенкранц и Стернс [1970]). Для любой обычной грамматики G =\n(Σ, N, R, S) существует другая грамматика G0 = (Σ, N ∪ N0, R0, S0), где N0 = { A0| А €\nN }, удовлетворяющий следующим условиям.\n1. Любой нетерминальный символ A ∈ N определяет в G0 тот же язык, что и в G.\n2. Любой нетерминальный символ A0 ∈ N в G0\nопределяет тот же язык, что и в G, с\nисключается пустой строкой: LG0(A0) = LG(A0) \\ {ε}. В частности, L(G0) = L(G) \\ {ε}.\n3. Ни одно правило R0 не начинается с нетерминального символа N.\n4. Если G — это LL(k), то G0 — это тоже LL(k)."
    },
    {
        "question": "Сформулируйте лемму Розенкранца и Стернса для обычной грамматики.",
        "answer": "____\nЛемма 1 (Розенкранц и Стернс [1970]). Для любой обычной грамматики G =\n(Σ, N, R, S) существует другая грамматика G0 = (Σ, N ∪ N0, R0, S0), где N0 = { A0| А €\nN }, удовлетворяющий следующим условиям.\n1. Любой нетерминальный символ A ∈ N определяет в G0 тот же язык, что и в G.\n2. Любой нетерминальный символ A0 ∈ N в G0\nопределяет тот же язык, что и в G, с\nисключается пустой строкой: LG0(A0) = LG(A0) \\ {ε}. В частности, L(G0) = L(G) \\{ε}.\n3. Ни одно правило R0 не начинается с нетерминального символа N.\n4. Если G — это LL(k), то G0 — это тоже LL(k)."
    },
    {
        "question": "Сформулируй лемму Розенкранца и Стирнса для LL(k)-грамматики",
        "answer": "____\nЛемма 2 (Розенкранц и Стирнс [1970]). Пусть G = (Σ, N, R, S) — LL(k)-грамматика,\nне содержащая правил вида A → Bγ, где ε ∈ LG(B). Пусть обнуляемые нетерминальные\nсимволы обозначаются через N0 = { A | A ∈ N, ε ∈ LG(A) }, и пусть N1 = { A | A ∈ N, ε /∈\nLG(A) } — все остальные. Тогда существует LL(k + 1)-грамматика G0 = (Σ, N0, R0, S0),где N0 — конечное множество нетерминальных символов вида [Xθ], где X ∈ Σ ∪ N1 и\nθ ∈ N∗0, и LG0([Xθ]) = LG(Xθ) для всякого [Xθ] ∈ N0\n[Xθ] ∈ N0.\nПри этом множество N0 не содержит ни одного элемента вида [XθAθ0Aθ00], который\nсодержал бы повторяющиеся вхождения одного и того же нетерминального символа."
    },
    {
        "question": "Сформулируйте лемму Розенкранца и Стернса для грамматики LL(k)",
        "answer": "____\nЛемма 2 (Розенкранц и Стернс [1970]). Пусть G = (Σ, N, R, S) — LL(k)-грамматика,\nне содержащая правил вида A → Bγ, где ε ∈ LG(B). Пусть обнуляемые нетерминальные\nсимволы обозначаются как N0 = {A | A ∈ N, ε ∈ LG(A)}, а N1 = {A | A ∈ N, ε /∈\nLG(A)} — все остальные. Тогда существует LL(k + 1)-грамматика G0 = (Σ, N0, R0, S0), где N0 — конечное множество нетерминальных символов вида [Xθ], где X ∈ Σ ∪ N1 и\nθ ∈ N∗0, и LG0([Xθ]) = LG(Xθ) для любого [Xθ] ∈ N0\n[Xθ] ∈ N0.\nБолее того, множество N0 не содержит ни одного элемента вида [XθAθ0Aθ00], который\nсодержал бы повторяющиеся вхождения одного и того же нетерминального символа."
    },
    {
        "question": "Сформулируйте лемму Розенкранца и Стернса для грамматики LL(k).",
        "answer": "____\nЛемма 2 (Розенкранц и Стернс [1970]). Пусть G = (Σ, N, R, S) — LL(k)-грамматика,\nне содержащая правил вида A → Bγ, где ε ∈ LG(B). Оставьте нетерминальное значение null\nсимволы обозначены N0 = {A | A ∈ N, ε ∈ LG(A)} и N1 = {A | A ∈ N, ε /ε\nЛГ(А)} - все остальные. Тогда существует LL(k + 1)-грамматика G0 = (Σ, N0, R0, S0), где N0 — конечное множество нетерминальных символов вида [Xθ], где X ∈ Σ ∪ N1 и\nθ ∈ N∗0 и LG0([Xθ]) = LG(Xθ) для всех [Xθ] ∈ N0\n[Xθ] ∈ N0.\nПри этом множество N0 не содержит ни одного элемента вида [XθAθ0Aθ00], что\nбудет содержать повторяющиеся вхождения одного и того же нетерминального характера."
    },
    {
        "question": "Сформулируйте лемму Розенкранца и Стернса для грамматики LL(k).",
        "answer": "____\nЛемма 2 (Розенкранц и Стернс [1970]). Пусть G = (Σ, N, R, S) — LL(k)-грамматика,\nне содержащая правил вида A → Bγ, где ε ∈ LG(B). Оставьте нетерминальное значение null\nсимволы обозначаются N0 = { A | A ∈ N, ε ∈ LG(A) }, и пусть N1 = { A | A ∈ N, ε /ε\nLG(A) } — все остальные. Тогда существует LL(k + 1)-грамматика G0 = (Σ, N0, R0, S0), где N0 — конечное множество нетерминальных символов вида [Xθ], где X ∈ Σ ∪ N1 и\nθ ∈ N∗0 и LG0([Xθ]) = LG(Xθ) для всех [Xθ] ∈ N0\n[Xθ] ∈ N0.\nПри этом множество N0 не содержит ни одного элемента вида [XθAθ0Aθ00], что\nбудет содержать повторяющиеся вхождения одного и того же нетерминального характера."
    },
    {
        "question": "Напиши теорему о непересекающемся объединении LL(k)-языков",
        "answer": "____\nТеорема (О непересекающемся объединении LL(k)-языков: Розенкранц и Стирнс [1970]).\nПусть L1, . . . , Ln ⊆ Σ\n∗ — попарно непересекающиеся LL(k)-языки, и пусть их объединение\nL1 ∪ . . . ∪ Ln регулярно. Тогда все языки L1, . . . , Ln должны быть регулярны."
    },
    {
        "question": "Напишите теорему о несвязном объединении языков LL(k)",
        "answer": "____\nТеорема (О непересекающемся объединении LL(k)-языков: Rosenkranz and Stearns [1970]).\nПусть L1, . . , Ln ⊆ Σ\n∗ — попарно непересекающиеся LL(k)-языки, и пусть их объединение\nL1 ∪ . . . ∪ Ln является регулярным. Тогда все языки ​​L1, . . . , Ln должны быть регулярными."
    },
    {
        "question": "Напишите теорему о дизъюнктном объединении LL(k) языков.",
        "answer": "____\nТеорема (О дизъюнктном объединении языков LL(k): Розенкранц и Стернс [1970]).\nПусть L1, . . , Ln ⊆Σ\n∗ являются попарно непересекающимися языками LL(k) и оставляют их объединение\nЛ1 ∪ . . . ∪ Ln регулярен. Тогда все языки L1, . . . , Ln должен быть регулярным."
    },
    {
        "question": "Напишите теорему о дизъюнктном объединении LL(k) языков.",
        "answer": "____\nТеорема (О дизъюнктном объединении языков LL(k): Розенкранц и Стернс [1970]).\nПусть L1, . . . , Ln ⊆Σ\n∗ являются попарно непересекающимися языками LL(k) и оставляют их объединение\nЛ1 ∪ . . . ∪ Ln регулярен. Тогда все языки L1, . . . , Ln должен быть регулярным."
    },
    {
        "question": "Расскажи про свойства LL-грамматик",
        "answer": "____\nГрамматику, которая была бы LL(k), но не LL(k − 1), построить легко: например, S →\na\nk\n| a\nk−1 — такая грамматика. Но в данном примере есть очевидная LL(1)-грамматика для\nтого же языка: S → a\nk−1A, A → a | ε. Растёт ли класс языков с увеличением k? Да.\nЛемма 1. Пусть G = (Σ, N, R, S) — LL(k)-грамматика без пустых правил, и пусть вычисление LL(k)-анализатора на некоторой строке w = xyz после чтения x приводит в\nконфигурацию (yz, Y γ), и затем, после чтения y, — в конфигурацию (z, γ). Тогда для всякой строки z\n0, совпадающей z в первых k − 1 символах, вычисление на xyz0 приходит в\nконфигурацию (z\n0, γ).\nНабросок доказательства. Разбирая y в виде Y , анализатор при каждом выборе правила\nвидит не менее одного последнего символа y. Поэтому различия между z и z\n0 при этом\nвыборе окажутся за горизонтом, и, стало быть, анализатор одинаково прочитает y в обоих\nслучаях.\nТеорема 1 (Курки-Суонио [1969]; Розенкранц и Стинрс [1970]). Для всякого k > 1, существует язык Lk, задаваемый LL(k)-грамматикой, но не задаваемый никакой LL(k)-\nграмматикой без пустых правил — и, стало быть, никакой LL(k − 1)-грамматикой.\nДоказательство. Язык Lk определяется как Lk =S\nn>1\na^n{b^kd, b, c}^n, и он описывается\nследующей грамматикой.\nS → aCA\nC → aCA | ε\nA → bB | c\nB → b\nk−1\nd | ε\nЧтобы убедиться, что эта грамматика — LL(k), нужно проверить, что анализатор может\nвыбрать правило для B. Действительно, правило B → ε выбирается для всех просматриваемых строк Firstk(LG(A)\n+), каковые все состоят целиком из символов b и c: строка b\nk−1d\nне относится к числу этих строк.\nОтрицательный результат получается методом подменяемой строки впереди. Если Lk\nзадаётся LL(k)-грамматикой без пустых правил, то, по теореме из прошлой лекции, есть\nLL(k)-грамматика G = (Σ, N, R, S) в нормальном виде Грейбах, задающая язык L(G) = Lk.\nПусть αn — содержимое стека соответствующего LL(k)-анализатора на входе a\nn+k−1\n. . .,\nпосле прочтения символов u = a\nn\n.\nУтверждение. αm 6= αn для всех m 6= n.\nУтверждение. Существует число n > 0, для которого |αn| > 2k − 1"
    },
    {
        "question": "Расскажите мне о свойствах грамматик LL",
        "answer": "____\nЛегко построить грамматику, которая является LL(k), но не LL(k − 1): например, S →\na\nk\n| a\nk−1 является такой грамматикой. Но в этом примере есть очевидная грамматика LL(1) для\nтого же языка: S → a\nk−1A, A → a | ε. Растет ли класс языков с k? Да.\nЛемма 1. Пусть G = (Σ, N, R, S) является грамматикой LL(k) без пустых правил, и пусть вычисление синтаксического анализатора LL(k) на некоторой строке w = xyz после чтения x дает\nконфигурацию (yz, Y γ), а затем после чтения y дает конфигурацию (z, γ). Тогда для каждой строки z\n0, которая совпадает с z в первых k − 1 символах, вычисление над xyz0 приходит к\nконфигурации (z\n0, γ).\nНабросок доказательства. При разборе y как Y анализатор для каждого выбора правила\nвидит по крайней мере один последний символ y. Поэтому различия между z и z\n0 для этого выбора будут за горизонтом, и, следовательно, анализатор будет читать y одинаково в обоих\nслучаях.\nТеорема 1 (Курки-Суонио [1969]; Розенкранц и Стинерс [1970]). Для каждого k > 1 существует язык Lk, который определяется LL(k)-грамматикой, но не любой LL(k)-грамматикой без пустых правил — и, следовательно, не любой LL(k − 1)-грамматикой.\nДоказательство. Язык Lk определяется как Lk = S\nn>1\na^n{b^kd, b, c}^n, и он описывается\nследующей грамматикой.\nS → aCA\nC → aCA | ε\nA → bB | c\nB → b\nk−1\nd | ε\nЧтобы убедиться, что эта грамматика — LL(k), мы должны проверить, что парсер может\nвыбрать правило для B. Действительно, правило B → ε выбирается для всех Firstk(LG(A)\n+) строк, которые он сканирует, все из которых состоят полностью из b и c: строка b\nk−1d\nне является одной из этих строк.\nОтрицательный результат получается методом подставленной строки впереди. Если Lk\nопределен LL(k)-грамматикой без пустых правил, то по теореме из предыдущей лекции существует\nLL(k)-грамматика G = (Σ, N, R, S) в нормальной форме Грейбаха, определяющая язык L(G) = Lk.\nПусть αn будет содержимым стека соответствующего LL(k)-анализатора на входе a\nn+k−1\n. . .,\nпосле чтения символов u = a\nn\n.\nУтверждение. αm 6= αn для всех m 6= n.\nУтверждение. Существует число n > 0 такое, что |αn| > 2k − 1"
    },
    {
        "question": "Расскажите мне о свойствах грамматик LL.",
        "answer": "____\nЛегко построить грамматику, которая будет LL(k), но не LL(k − 1): например, S →\nА\nк\n| А\nk−1 — такая грамматика. Но в этом примере существует очевидная LL(1)-грамматика для\nтот же язык: S → a\nk−1A, А → а | е. Растет ли класс языков с ростом k? Да.\nЛемма 1. Пусть G = (Σ, N, R, S) — LL(k)-грамматика без пустых правил, и пусть синтаксический анализатор вычисляет LL(k) в строке w = xyz после чтения x и дает\nконфигурация (yz, Y γ), то после прочтения y дает конфигурацию (z, γ). Итак, для каждой строки z\n0, который совпадает с z в первых k − 1 символах, вычисление по xyz0 сводится к\nконфигурации (з\n0,у).\nЭскиз доказательства. При анализе y как анализатора Y для каждого выбора правила\nвидит хотя бы один последний символ y. Итак, различия между z и z\nнули для этого выбора будут на горизонте, и поэтому синтаксический анализатор будет читать их одинаково в обоих случаях.\nслучай.\nТеорема 1 (Курки-Суонио [1969]; Розенкранц и Стинерс [1970]). Для всех k > 1 существует язык Lk, который определяется грамматикой LL(k), но не грамматикой LL(k) без пустых правил – и, следовательно, грамматикой LL(k − 1).\nДоказательство. Язык Lk определяется как Lk = S\nп>1\na^n{b^kd, b, c}^n, и это описано\nследующую грамматику.\nS → аСА\nС → аСА | ε\nА → бБ | с\nБ → б\nк-1\nд | ε\nЧтобы гарантировать, что эта грамматика является LL(k), мы должны проверить, что синтаксический анализатор может\nвыбрать правило для B. Действительно, правило B → ε выбирается для всех Firstk(LG(A)\n+) сканируемые строки, которые полностью состоят из b и c: строка b\nk−1d\nне является одним из этих каналов.\nОтрицательный результат получается при вставке линии впереди. Если Люк\nопределяется LL(k)-грамматикой без пустых правил, то по теореме предыдущего курса существует\nLL(k)-грамматика G = (Σ, N, R, S) в нормальной форме Грейбаха, определяющая язык L(G) = Lk.\nПусть αn — содержимое стека анализатора LL(k), соответствующее входу a\nn+k−1\n. . .,\nпосле прочтения символов u=a\nн\n.\nЗаявление. αm 6= αn для всех m 6= n.\nЗаявление. Существует число n > 0 такое, что |αn| > 2к - 1"
    },
    {
        "question": "Расскажите о свойствах LL-грамматик.",
        "answer": "____\nГрамматику, которая была бы LL(k), но не LL(k − 1), легко построить: например, S →\nА\nк\n| А\nk−1 — такая грамматика. Но в этом примере существует очевидная LL(1)-грамматика для\nтот же язык: S → a\nk−1A, А → а | е. Растет ли класс языков с увеличением k? Да.\nЛемма 1. Пусть G = (Σ, N, R, S) — LL(k)-грамматика без пустых правил, и пусть вычисление синтаксического анализатора LL(k) на строке w = xyz после чтения x приводит к\nконфигурации (yz, Y γ), затем, после прочтения y, в конфигурации (z, γ). Итак, для каждой строки z\n0, соответствующий z в первых k − 1 символах, вычисление по xyz0 составляет\nконфигурация (з\n0,у).\nЭскиз доказательства. Parse y as Y , анализатор каждого выбора правила.\nвидит хотя бы один последний символ y. Итак, различия между z и z\n0 в этом случае\nвыбор будет за горизонтом и поэтому парсер прочитает y в обоих\nслучай.\nТеорема 1 (Курки-Суонио [1969]; Розенкранц и Стинрс [1970]). Для всех k > 1 существует язык Lk, определенный грамматикой LL(k), но не определенный грамматикой LL(k).\nграмматика без пустых правил и, следовательно, отсутствие LL(k - 1)-грамматики.\nДоказательство. Язык Lk определяется как Lk =S\nп>1\na^n{b^kd, b, c}^n, и это описано\nследующую грамматику.\nS → аСА\nС → аСА | ε\nА → бБ | с\nБ → б\nк-1\nд | ε\nЧтобы убедиться, что эта грамматика соответствует LL(k), вам нужно убедиться, что синтаксический анализатор может\nвыбрать правило для B. Действительно, правило B → ε выбирается для всех искомых строк Firstk(LG(A)\n+), все они полностью состоят из символов b и c: строка b\nk−1d\nэто не одна из этих строк.\nОтрицательный результат получается методом предполагаемой замены. Если Люк\nзадается LL(k)-грамматикой без пустых правил, то по теореме предыдущего курса существует\nLL(k)-грамматика G = (Σ, N, R, S) в нормальной форме Грейбаха, определяющая язык L(G) = Lk.\nПусть αn — содержимое стека анализатора LL(k), соответствующее входу a\nn+k−1\n. . .,\nпосле прочтения символов u = a\nн\n.\nЗаявление. αm 6= αn для всех m 6= n.\nЗаявление. Существует число n > 0, для которого |αn| > 2к - 1"
    },
    {
        "question": "Что такое локальные автоматы",
        "answer": "____\nОпределение:\nАвтомат A\n называется локальным (англ. local automaton, Glushkov automaton), если для любого c\n из Σ\n множество {δ(s,c)∣s∈S}\n содержит не более одного элемента.\n\n\nОпределение:\nЛокальный автомат A\n называется стандартным локальным автоматом (англ. standard local automation), если в нем нет перехода в начальное состояние.\n\nТаким образом, автомат является локальным, если для каждого c\n из Σ\n нет переходов, отмеченных c, или если все они ведут в одно состояние.\n\nПокажем, что граф Майхилла может быть преобразован в стандартный локальный автомат таким образом, что распознаваемый им язык не изменится.\n\nТеорема:\nЯзык распознается графом Майхилла тогда и только тогда, когда он распознается стандартным локальным автоматом, стартовое состояние которого не является терминальным."
    },
    {
        "question": "Что такое локальные автоматы?",
        "answer": "____\nОпределение:\nЛокальный автомат (автомат Глушкова) называется автоматом, если для любого c\nиз Σ\nмножество {δ(s,c)∣s∈S}\nсодержит не более одного элемента.\n\nОпределение:\nЛокальный автомат A\nназывается стандартным локальным автоматом, если он не имеет перехода в начальное состояние.\n\nТаким образом, автомат является локальным, если для каждого c\nиз Σ\nнет переходов, отмеченных c, или если все они ведут в одно и то же состояние.\n\nМы покажем, что граф Майхилла можно преобразовать в стандартный локальный автомат таким образом, что распознаваемый им язык не изменится.\n\nТеорема:\nЯзык распознается графом Майхилла тогда и только тогда, когда он распознается стандартным локальным автоматом, начальное состояние которого не является терминальным."
    },
    {
        "question": "Что такое локальные машины?",
        "answer": "____\nОпределение:\nЛокальный автомат (автомат Глушкова) называется автоматом, если для всех c\nΣ\nнабор {δ(s,c)∣sεS}\nсодержит не более одного элемента.\n\nОпределение:\nЛокальный ПЛК А\nназывается стандартным локальным автоматом, если он не имеет перехода в исходное состояние.\n\nТаким образом, автомат является локальным, если для каждого c\nΣ\nпереходов, отмеченных буквой c, нет, или все они ведут в одно и то же состояние.\n\nМы покажем, что граф Майхилла можно преобразовать в стандартный локальный автомат так, что распознаваемый им язык не изменится.\n\nТеорема:\nЯзык распознается графом Майхилла тогда и только тогда, когда он распознается стандартным локальным автоматом, начальное состояние которого не является терминальным."
    },
    {
        "question": "Что такое локальные машины",
        "answer": "____\nОпределение:\nАвтоматический А\n называется локальным (англ. local автомат, автомат Глушкова), если для любого c\n Σ\n набор {δ(s,c)∣sεS}\n содержит не более одного элемента.\n\n\nОпределение:\nЛокальный ПЛК А\n называется стандартной локальной автоматизацией, если она не включает переход в исходное состояние.\n\nТаким образом, автомат является локальным, если для каждого c\n Σ\n переходов, отмеченных буквой c, нет, или все они ведут в одно и то же состояние.\n\nПокажем, что граф Майхилла можно преобразовать в стандартный локальный автомат так, что распознаваемый им язык не изменится.\n\nТеорема:\nЯзык распознается графом Майхилла тогда и только тогда, когда он распознается стандартным локальным автоматом, начальное состояние которого не является терминальным."
    },
    {
        "question": "Следствие теоремы Турчина",
        "answer": "____\nПусть G - алфавитная префиксная грамматик, в которой N правил с непустой правой частью, и максимальная длина правой части правила равна M. Тогда любая последовательность порождаемых ею слов\na_1...a_n\n...\nε\nдлиной не менее N^M*(n+1) содержит пару вида τ_1=Φ*Θ_0, τ_2=Φ*Ψ*Θ_0 такую, что |Φ|<=M и на отрезке [τ_1, τ_2] нет слов длины меньше |Θ_0|+1."
    },
    {
        "question": "Следствие теоремы Турчина",
        "answer": "____\nПусть G — алфавитная префиксная грамматика с N правилами с непустой правой частью, а максимальная длина правой части правила равна M. Тогда любая последовательность слов, ею порождаемая\na_1...a_n\n...\nε\nдлиной не менее N^M*(n+1), содержит пару вида τ_1=Φ*Θ_0, τ_2=Φ*Ψ*Θ_0 такую, что |Φ|<=M и на интервале [τ_1, τ_2] нет слов длины меньше |Θ_0|+1."
    },
    {
        "question": "Следствие теоремы Турчина",
        "answer": "____\nПусть G — грамматика алфавитных префиксов с N правилами и непустой правой частью, а максимальная длина правой части правила равна M. Тогда любая последовательность слов, порожденная ею,\nа_1...а_н\n...\nε\nдлины не менее N^M*(n+1), содержит пару вида τ_1=Φ*Θ_0, τ_2=Φ*Ψ*Θ_0 такую, что |Φ|<=M и на интервале [τ_1, τ_2 ] нет слов длины меньше |Θ_0|+1."
    },
    {
        "question": "Следствие теоремы Турчина",
        "answer": "____\nПусть G — грамматика буквенных префиксов, в которой правил N с непустой правой частью, а максимальная длина правой части правила равна M. Тогда любая последовательность слов, порожденная ею,\nа_1...а_н\n...\nε\nдлины не менее N^M*(n+1) содержит пару вида τ_1=Φ*Θ_0, τ_2=Φ*Ψ*Θ_0 такую, что |Φ|<=M и на отрезке [τ_1, τ_2] существуют нет слов длины меньше |Θ_0|+1."
    },
    {
        "question": "Критерий синхронизации",
        "answer": "____\nDFA A синхронизирующийся <=> ∀q,q'∃w, q_x(q-w->q_x & q' -w->q_x)."
    },
    {
        "question": "Критерий синхронизации",
        "answer": "____ DFA A синхронизирующий <=> ∀q,q'∃w, q_x(q-w->q_x & q' -w->q_x)."
    },
    {
        "question": "Критерий синхронизации",
        "answer": "____ Синхронизация DFA A <=> ∀q,q'∃w, q_x(q-w->q_x & q' -w->q_x)."
    },
    {
        "question": "Критерий синхронизации",
        "answer": "____\nСинхронизация DFA A <=> ∀q,q'∃w, q_x(q-w->q_x & q' -w->q_x)."
    },
    {
        "question": "Докажите, что множество автоматных грамматик образует булеву алгебру",
        "answer": "____\nКласс регулярных множеств образует булеву алгебру. Класс регулярных множеств замкнут\nотносительно реверса?\nΩ=<∨,∧,¬> - сигнатура булевой алгебры\nСвойства булевой алгебры:\n● A∧B=B∧A - коммутативность по умножению\n● A∧(B∧C)=(A∧B)∧C - ассоциативность по умножению\n● A∧(B∨C)=(A∧B) ∨(A∧C) - дистрибутивность\n● ¬¬A=A\n● A∨¬A=1\n● A∧¬A=0\n● A∧1=A\n● A∧0=A\n● A∨0=A\n● A∨1=1\nДоказательство:\nСвойства операций сложения и умножения следуют из Леммы о регулярных выражениях\nДополнение регулярного множества является регулярным ⇐ если множество регулярно, то оно\nраспознаётся автоматом. Если в автомате M изменить множество конечных состояний на Q\\F, то\nполучим автомат , который распознаёт дополнение к заданному языку."
    },
    {
        "question": "Докажите, что множество автоматных грамматик образует булеву алгебру.",
        "answer": "____\nКласс регулярных множеств образует булеву алгебру. Замкнут ли класс регулярных множеств относительно обратного?\nΩ=<∨,∧,¬> - сигнатура булевой алгебры\nСвойства булевой алгебры:\n● A∧B=B∧A - коммутативность при умножении\n● A∧(B∧C)=(A∧B)∧C - ассоциативность при умножении\n● A∧(B∨C)=(A∧B) ∨(A∧C) - дистрибутивность\n● ¬¬A=A\n● A∨¬A=1\n● A∧¬A=0\n● A∧1=A\n● A∧0=A\n● A∨0=A\n● A∨1=1\nДоказательство:\nСвойства операций сложения и умножения следуют из Леммы о регулярных выражениях\nДополнение регулярного множества является регулярным ⇐ если набор регулярен, то он\nраспознается автоматом. Если в автомате M изменить набор конечных состояний на Q\\F, то\nмы получим автомат, распознающий дополнение заданного языка."
    },
    {
        "question": "Покажите, что множество грамматик автоматов образует булеву алгебру.",
        "answer": "____\nКласс регулярных множеств образует булеву алгебру. Закрыт ли класс регулярных множеств относительно обратного?\nΩ=<∨,∧,¬> - сигнатура булевой алгебры\nСвойства булевой алгебры:\n● A∧B=B∧A – коммутативность при умножении\n● A∧(B∧C)=(A∧B)∧C – ассоциативность при умножении\n● A∧(B∨C)=(A∧B) ∨(A∧C) - дистрибутивность\n● ¬¬A=A\n● А∨¬А=1\n● А∧¬А=0\n● А∧1=А\n● А∧0=А\n● А∨0=А\n● А∨1=1\nДоказательство:\nСвойства операций сложения и умножения следуют из леммы о регулярных выражениях.\nДополнение к регулярному множеству регулярно ⇐ если множество регулярно, то оно\nраспознается автоматически. Если в автомате М изменить множество конечных состояний на Q\\F, то\nмы получим автомат, распознающий дополнение данного языка."
    },
    {
        "question": "Покажите, что множество грамматик автоматов образует булеву алгебру",
        "answer": "____\nКласс регулярных множеств образует булеву алгебру. Класс регулярных множеств замкнут.\nотносительно обратного?\nΩ=<∨,∧,¬> - сигнатура булевой алгебры\nСвойства булевой алгебры:\n● A∧B=B∧A – коммутативность против умножения.\n● A∧(B∧C)=(A∧B)∧C – ассоциативность умножения.\n● A∧(B∨C)=(A∧B) ∨(A∧C) - дистрибутивность\n● ¬¬A=A\n● А∨¬А=1\n● А∧¬А=0\n● А∧1=А\n● А∧0=А\n● А∨0=А\n● А∨1=1\nДоказательство:\nСвойства операций сложения и умножения следуют из леммы о регулярных выражениях.\nДополнение к регулярному множеству регулярно ⇐ если множество регулярно, то оно\nраспознается автоматически. Если в автомате М изменить множество конечных состояний на Q\\F, то\nмы получаем автомат, распознающий дополнение данного языка."
    },
    {
        "question": "Сформулировать теорему Майхилла-Нероуда",
        "answer": "____\nЯзык L является VPL => множество сбалансированных слов(т.е. таких, каждый символ из Σ_с в которых имеет соответствующий символ из Σ_r) разбивается на конечное число классов эквивалентности по Майхиллу-Нероуду относительно L."
    },
    {
        "question": "Сформулируйте теорему Майхилла-Нерода.",
        "answer": "____\nЯзык L является VPL => множество сбалансированных слов (т. е. таких, в которых каждый символ из Σ_c имеет соответствующий символ из Σ_r) разбито на конечное число классов эквивалентности Майхилла-Нерода относительно L."
    },
    {
        "question": "Сформулируйте теорему Майхилла-Нерода.",
        "answer": "____\nЯзык L представляет собой VPL => набор сбалансированных слов (т.е. тех, в которых каждому символу Σ_c соответствует соответствующий символ Σ_r) разделен на конечное число классов эквивалентности Майхилла-Нерода по сравнению с L."
    },
    {
        "question": "Сформулируйте теорему Майхилла-Нерхуда.",
        "answer": "____\nЯзык L представляет собой VPL => набор сбалансированных слов (т.е. тех, в которых каждому символу Σ_c соответствует соответствующий символ Σ_r) разделен на конечное число классов эквивалентности Майхилла-Нероуда по сравнению с L."
    },
    {
        "question": "Что такое конъюктивная грамматика?",
        "answer": "____\nКонъюнктивная грамматика G - грамматика, правила которой имеют вид A_i -> Φ_1 & ... & Φ_2 где A_i - нетерминал; Φ_j - строки в смешанном алфавите терминалов и нетерминалов."
    },
    {
        "question": "Что такое конъюнктивная грамматика?",
        "answer": "____\nКонъюнктивная грамматика G — это грамматика, правила которой имеют вид A_i -> Φ_1 & ... & Φ_2, где A_i — нетерминал; Φ_j — строки в смешанном алфавите терминалов и нетерминалов."
    },
    {
        "question": "Что такое соединительная грамматика?",
        "answer": "____\nКонъюнктивная грамматика G — это грамматика, правила которой имеют вид A_i -> Φ_1 & ... & Φ_2, где A_i — нетерминал; Φ_j — строки в смешанном алфавите терминалов и нетерминалов."
    },
    {
        "question": "Что такое соединительная грамматика?",
        "answer": "____\nКонъюнктивная грамматика G — это грамматика, правила которой имеют вид A_i -> Φ_1 & ... & Φ_2, где A_i — нетерминал; Φ_j — строки в смешанном алфавите терминалов и нетерминалов."
    },
    {
        "question": "Что такое древесный автомат?",
        "answer": "____\nДревесный автомат задается входным алфавитом(сигнатурой конструкторов) Σ⊂{⟨f, n⟩} и конечным состоянием, а также правилами перехода: ⟨f, n⟩ ∈ Σ => (q_1,..., q_n, f)->q_s."
    },
    {
        "question": "Что такое деревообрабатывающий станок?",
        "answer": "____\nДерево автомата определяется входным алфавитом (сигнатурой конструкторов) Σ⊂{⟨f, n⟩} и конечным состоянием, а также правилами перехода: ⟨f, n⟩ ∈ Σ => (q_1,..., q_n, f)->q_s."
    },
    {
        "question": "Что такое деревообрабатывающий станок?",
        "answer": "____\nДерево автоматов определяется входным алфавитом (сигнатурой конструктора) Σ⊂{⟨f, n⟩} и конечным состоянием, а также правилами перехода: ⟨f, n⟩ ∈ Σ => (q_1,.. ., q_n, f)->q_s."
    },
    {
        "question": "Что такое деревообрабатывающий станок?",
        "answer": "____\nДревовидный автомат задается входным алфавитом (сигнатурой конструктора) Σ⊂{⟨f, n⟩} и конечным состоянием, а также правилами перехода: ⟨f, n⟩ ∈ Σ => ( q_1,..., q_n, f)->q_s."
    },
    {
        "question": "Следствия теоремы Париха",
        "answer": "____\n1)Множества регулярных и КС-языков над однобуквенным алфавитом совпадают.\n2)Коммутативным образом КС-языка является регулярный язык."
    },
    {
        "question": "Следствия теоремы Париха",
        "answer": "____\n1) Множества регулярных и CF-языков над однобуквенным алфавитом совпадают.\n2) Коммутативный образ CF-языка — регулярный язык."
    },
    {
        "question": "Следствия теоремы Париха",
        "answer": "____\n1) Множества регулярного и КФ языков на однобуквенном алфавите совпадают.\n2) Коммутативный образ языка CF является регулярным языком."
    },
    {
        "question": "Следствия теоремы Париха",
        "answer": "____\n1) Регулярное и КС-множества языков в однобуквенном алфавите совпадают.\n2) Коммутативный образ языка КС является регулярным языком."
    },
    {
        "question": "Пересечение КС-грамматики и регулярного языка",
        "answer": "____\nДаны КС-грамматика G и конечный автомат A. Можно построить КС-грамматику G' такую, что L(G')=L(G)∩L(A)."
    },
    {
        "question": "Пересечение грамматики KS и обычного языка",
        "answer": "____\nДля заданной конечной грамматики G и конечного автомата A мы можем построить конечную грамматику G' такую, что L(G')=L(G)∩L(A)."
    },
    {
        "question": "Пересечение грамматики КС и обычного языка.",
        "answer": "____\nУчитывая конечную грамматику G и конечный автомат A, мы можем построить конечную грамматику G' такую, что L(G')=L(G)∩L(A)."
    },
    {
        "question": "Пересечение грамматики КС и обычного языка.",
        "answer": "____\nДаны KS-грамматика G и конечный автомат A. Можно построить KS-грамматику G' такую, что L(G')=L(G)∩L(A)."
    },
    {
        "question": "Что такое стековый автомат?",
        "answer": "____\nСтековый автомат A - кортеж ⟨Π, Σ, Q, δ, q_0, Z_0⟩, где:\nΠ - алфавит стека;\nΣ - алфавит языка;\nQ - множество состояний;\nδ - правила перехода вида ⟨q_i, t, P_i⟩ -> ⟨q_j, α⟩, где t ∈ Σ ∪ {ε}, α ∈ Π*\nq_0 - стартовое сотояние;\nZ_0 - дно стека."
    },
    {
        "question": "Что такое штабелёр?",
        "answer": "____ Стековый автомат A - кортеж ⟨Π, Σ, Q, δ, q_0, Z_0⟩, где: Π - стековый алфавит;\nΣ - языковой алфавит;\nQ - множество состояний;\nδ - правила перехода вида ⟨q_i, t, P_i⟩ -> ⟨q_j, α⟩, где t ∈ Σ ∪ {ε}, α ∈ Π* q_0 - начальное состояние;\nZ_0 - дно стека."
    },
    {
        "question": "Что такое штабелер?",
        "answer": "____ Стековой автомат А - кортеж ⟨Π, Σ, Q, δ, q_0, Z_0⟩, где: Π - алфавит стека;\nΣ – алфавит языка;\nQ – набор состояний;\nδ - правила перехода вида ⟨q_i, t, P_i⟩ -> ⟨q_j, α⟩, где t ∈ Σ ∪ {ε}, α ∈ Π* q_0 - исходное состояние;\nZ_0 — низ стека."
    },
    {
        "question": "Что такое штабелеукладчик?",
        "answer": "____\nСтек-автомат A представляет собой кортеж ⟨Π, Σ, Q, δ, q_0, Z_0⟩, где:\nП - алфавит стека;\nΣ – алфавит языка;\nQ – набор состояний;\nδ — правила перехода вида ⟨q_i, t, P_i⟩ -> ⟨q_j, α⟩, где t ∈ Σ ∪ {ε}, α ∈ Π*\nq_0 – стартовое состояние;\nZ_0 — низ стека."
    },
    {
        "question": "Доказать алгоритм Эрли",
        "answer": "____⟹\n\nДокажем индукцией по исполнению алгоритма.\nБаза индукции:\n[S′→⋅S,0]∈D0.\nИндукционный переход:\nПусть предположение верно для всех списков ситуаций с номерами меньше j. Разберемся, в результате применения какого правила ситуация [A→α⋅β,i] попала в Dj\n1. Включаем по правилу scan. Это произошло, если α=α′a, a=wj−1 и [A→α′⋅aβ,i]∈Dj−1.\nПо предположению индукции S′⇒∗w0…wi−1Aδ и α′⇒∗wi…wj−2, тогда в силу a=wj−1 получаем α=α′a⇒∗wi…wj−2wj−1=wi…wj−1. Таким образом условия: S′⇒∗w0…wi−1Aδ и α⇒∗wi…wj−1 выполняются.\n2. Включаем по правилу predict. По построению: α=ε и i=j, что автоматически влечет второй пункт утверждения.\nКроме того ∃i′≤i и ситуация [A′→α′⋅Aδ′,i′]∈Di, из чего по  предположению индукции следует S′⇒∗w0…wi′−1A′δ′′ и α′⇒∗wi′…wi−1.\nПолучаем, что S′⇒∗w0…wi′−1A′δ′′, значит S⇒∗w0…wi′−1α′Aδ′δ′′, следовательно S′⇒∗w0…wi′−1wi′…wi−1Aδ′δ′′, в итоге S′⇒∗w0…wi−1Aδ, что нам и требовалось.\n3. Включаем по правилу complete. По построению: α=α′A′ и ∃i′,δ:[A→α′⋅A′β,i]∈Di′∧[A′→η⋅,i′]∈Dj. Cледовательно α=α′A ⇒∗wi…wi′−1wi′…wj=wi…wj−1, что дает нам второй пункт утверждения, а так как первый пункт следует из индукционного предположения, все хорошо.\n\n⟸\n\nВ обратную сторону будем доказывать индукцией по суммарной длине вывода w0…wi−1Aδ  из S′ и wi…wj−1 из α. После чего применим индукцию по длине вывода wi…wj−1 из α. Рассмотрим три случая последнего символа α:\n1. α=α′a, тогда a=wj−1 и α′⇒∗wi…wj−2. По предположению индукции: [A→α′⋅aβ,i]∈Dj−1, а отсюда по правилу scan получаем [A→α′a⋅β,i]∈Dj.\n2. α=α′B, тогда ∃i′:α′⇒∗wi…wi′−1∧B′⇒∗wi′…wj−1.Тогда имеем [A→α′a⋅β,i]∈Dj. Также можно записать S′⇒∗w0…wi−1Aδ, как S′⇒∗w0…wi−1wi…wi′−1Bβδ, а также B→η∧η→wi′…wj−1.\nПрименяя индукцию по второму параметру получим [B→η⋅,i′]∈Dj, откуда по правилу complete получаем [A→α′B⋅β,i]∈Dj.\n\n3. α=ε, тогда i=j. Тогда либо i=0∧A=S∧δ=ε, что доказывает базу индукции, либо вывод можно записать в виде S′⇒∗w0…wi′−1wi′…wi−1Aδ′δ′′=w0…wi−1Aδ для некоторого правила (A′→wi′…wi−1Aδ′)∈P.\nОтсюда по предположению индукции [A′→⋅wi′…wi−1Aδ′,i′]∈Di′ , что после нескольких применений правила scan приводит к [A′→wi′…wi−1⋅Aδ′,i′]∈Di, после чего по правилу predict  получим [A→⋅β,i]∈Dj, что и требовалось."
    },
    {
        "question": "Докажите алгоритм Эрли",
        "answer": "____⟹\n\nДокажем индукцией по выполнению алгоритма.\nБаза индукции:\n[S′→⋅S,0]∈D0.\nШаг индукции:\nПусть предположение верно для всех списков ситуаций с номерами меньше j. Разберемся, в результате применения какого правила ситуация [A→α⋅β,i] попала в Dj\n1. Включаем по правилу сканирования. Это произошло, если α=α′a, a=wj−1 и [A→α′⋅aβ,i]∈Dj−1.\nПо предположению индукции S′⇒∗w0…wi−1Aδ и α′⇒∗wi…wj−2, тогда в силу a=wj−1 получаем α=α′a⇒∗wi…wj−2wj−1=wi…wj−1. Таким образом, условия: S′⇒∗w0…wi−1Aδ и α⇒∗wi…wj−1 выполнены.\n2. Включаем по правилу предсказывать. По построению: α=ε и i=j, что автоматически влечет второй пункт утверждения.\nПри этом ∃i′≤i и ситуация [A′→α′⋅Aδ′,i′]∈Di, из которой по предположению индукции следует, что S′⇒∗w0…wi′−1A′δ′′ и α′⇒∗wi′…wi−1. Получаем, что S′⇒∗w0…wi′−1A′δ′′, а значит S⇒∗w0…wi′−1α′Aδ′δ′′, следовательно S′⇒∗w0…wi′−1wi′…wi−1Aδ′δ′′, в результате S′⇒∗w0…wi−1Aδ, что и требовалось.\n3. Включаем по полному правилу. По построению: α=α′A′ и ∃i′,δ:[A→α′⋅A′β,i]∈Di′∧[A′→η⋅,i′]∈Dj. Следовательно, α=α′A ⇒∗wi…wi′−1wi′…wj=wi…wj−1, что дает нам второй пункт утверждения, а поскольку первый пункт следует из предположения индукции, то все в порядке.\n\n⟸\n\nОбратное докажем индукцией по общей длине вывода w0…wi−1Aδ из S′ и wi…wj−1 из α. После этого применим индукцию по длине вывода wi…wj−1 из α. Рассмотрим три случая последнего символа α:\n1. α=α′a, тогда a=wj−1 и α′⇒∗wi…wj−2. По предположению индукции: [A→α′⋅aβ,i]∈Dj−1, и отсюда по правилу сканирования получаем [A→α′a⋅β,i]∈Dj.\n2. α=α′B, тогда ∃i′:α′⇒∗wi…wi′−1∧B′⇒∗wi′…wj−1. Тогда имеем [A→α′a⋅β,i]∈Dj. Мы также можем записать S′⇒∗w0…wi−1Aδ как S′⇒∗w0…wi−1wi…wi′−1Bβδ, а также B→η∧η→wi′…wj−1.\nПрименяя индукцию по второму параметру, получаем [B→η⋅,i′]∈Dj, откуда по полному правилу получаем [A→α′B⋅β,i]∈Dj.\n\n3. α=ε, тогда i=j. Тогда либо i=0∧A=S∧δ=ε, что доказывает базу индукции, либо заключение можно записать как S′⇒∗w0…wi′−1wi′…wi−1Aδ′δ′′=w0…wi−1Aδ для некоторого правила (A′→wi′…wi−1Aδ′)∈P. Следовательно, по предположению индукции, [A′→⋅wi′…wi−1Aδ′,i′]∈Di′ , что после нескольких применений правила сканирования приводит к [A′→wi′…wi−1⋅Aδ′,i′]∈Di, после чего по правилу предсказания получаем [A→⋅β,i]∈Dj, что и требовалось."
    },
    {
        "question": "Докажите алгоритм Эрли",
        "answer": "____⟹\n\nДокажем это индукцией по выполнению алгоритма.\nИндукционная база:\n[S′→⋅S,0]еD0.\nИндукционная стадия:\nПредположим, что предположение верно для всех списков ситуаций с номерами меньше j. Посмотрим, какое правило привело к тому, что ситуация [A→α⋅β,i] оказалась в Dj\n1. Активируйте согласно правилу анализа. Это произошло, если α=α′a, a=wj−1 и [A→α′⋅aβ,i]εDj−1.\nПо предположению индукции S′⇒∗w0…wi−1Aδ и α′⇒∗wi…wj−2, тогда благодаря a=wj−1 получаем α=α′a⇒∗wi…wj−2wj− 1=wi …wj −1. Таким образом, условия: S′⇒∗w0…wi−1Aδ и α⇒∗wi…wj−1 выполнены.\n2. Включите правило прогнозирования. По построению: α=ε и i=j, что автоматически приводит ко второму пункту утверждения.\nВ этом случае ∃i′妻i и ситуация [A′→α′⋅Aδ′,i′]εDi, откуда по предположению индукции следует, что S′⇒∗w0…wi′ −1A′ δ′′ и α′ ⇒∗wi′…wi−1. Получаем, что S′⇒∗w0…wi′−1A′δ′′, и, следовательно, S⇒∗w0…wi′−1α′Aδ′δ′′, следовательно, S′⇒∗w0…wi′−1wi′…wi −1Aδ′δ′′, что дает S′⇒∗w0…wi−1Aδ, что и требовалось.\n3. Свет по полному правилу. По построению: α=α′A′ и ∃i′,δ:[A→α′⋅A′β,i]εDi′∧[A′→η⋅,i′]εDj. Итак, α=α′A ⇒∗wi…wi′−1wi′…wj=wi…wj−1, что дает нам второй пункт утверждения, а поскольку первый пункт следует из предположения индукции, то все в порядке. заказ.\n\n⟸\n\nМы докажем обратное индукцией по полной длине выхода w0…wi−1Aδ функции S′ и wi…wj−1 функции α. После этого применяем индукцию по длине выхода wi…wj−1 функции α. Рассмотрим три случая последнего символа α:\n1. α=α′a, тогда a=wj−1 и α′⇒∗wi…wj−2. По предположению индукции: [A→α′⋅aβ,i]εDj−1, и отсюда по правилу сканирования получаем [A→α′a⋅β,i]εDj.\n2. α=α′B, тогда ∃i′:α′⇒∗wi…wi′−1∧B′⇒∗wi′…wj−1. Тогда имеем [A→α′a⋅β,i]εDj. Мы также можем записать S′⇒∗w0…wi−1Aδ как S′⇒∗w0…wi−1wi…wi′−1Bβδ, а также B→η∧η→wi′…wj−1.\nПрименяя индукцию по второму параметру, получаем [B→η⋅,i′]εDj, откуда по полному правилу получаем [A→α′B⋅β,i]εDj.\n\n3. α=ε, тогда i=j. Тогда либо i=0∧A=S∧δ=ε, что доказывает основу индукции, либо заключение можно записать S′⇒∗w0…wi′−1wi′…wi−1Aδ′δ′′ =w0… wi −1Aδ для правила (A′→wi′…wi−1Aδ′)εP. Следовательно, по предположению индукции [A′→⋅wi′…wi−1Aδ′,i′]εDi′ , что после нескольких применений правила сканирования приводит к [A′→wi′…wi −1⋅Aδ′ ,i′ ]εDi, после чего согласно правилу прогнозирования получаем [A→⋅β,i]εDj, что и требовалось."
    },
    {
        "question": "Докажите алгоритм Эрли",
        "answer": "____⟹\n\nДокажем это индукцией по выполнению алгоритма.\nИндукционная база:\n[S′→⋅S,0]еD0.\nИндукционный переход:\nПредположим, что предположение верно для всех списков ситуаций с номерами меньше j. Посмотрим, какое правило привело к тому, что ситуация [A→α⋅β,i] оказалась в Dj\n1. Активируйте согласно правилу анализа. Это произошло, если α=α′a, a=wj−1 и [A→α′⋅aβ,i]εDj−1.\nПо предположению индукции S′⇒∗w0…wi−1Aδ и α′⇒∗wi…wj−2, тогда благодаря a=wj−1 получаем α=α′a⇒∗wi…wj−2wj− 1=wi …wj −1. Таким образом, условия: S′⇒∗w0…wi−1Aδ и α⇒∗wi…wj−1 выполнены.\n2. Активируйте согласно правилу прогнозирования. По построению: α=ε и i=j, что автоматически приводит ко второму пункту утверждения.\nКроме того, ∃i′妻i и ситуация [A′→α′⋅Aδ′,i′]εDi, откуда по предположению индукции следует S′⇒∗w0…wi′−1A ′δ′ ′ и α′⇒∗ wi′…wi−1.\nПолучаем, что S′⇒∗w0…wi′−1A′δ′′, что означает S⇒∗w0…wi′−1α′Aδ′δ′′, поэтому S′⇒∗w0…wi′−1wi′… wi − 1Aδ′δ′′, поэтому S′⇒∗w0…wi−1Aδ, что нам и нужно.\n3. Активируйте по полному правилу. По построению: α=α′A′ и ∃i′,δ:[A→α′⋅A′β,i]εDi′∧[A′→η⋅,i′]εDj. Итак, α=α′A ⇒∗wi…wi′−1wi′…wj=wi…wj−1, что дает нам второй пункт утверждения, а поскольку первый пункт следует из предположения индукции, все в порядке.\n\n⟸\n\nПротивоположное направление докажем индукцией по полной длине выхода w0…wi−1Aδ сигнала S′ и wi…wj−1 сигнала α. Затем применяем индукцию по длине выхода wi…wj−1 функции α. Рассмотрим три случая последнего символа α:\n1. α=α′a, тогда a=wj−1 и α′⇒∗wi…wj−2. По предположению индукции: [A→α′⋅aβ,i]εDj−1, и отсюда по правилу сканирования получаем [A→α′a⋅β,i]εDj.\n2. α=α′B, тогда ∃i′:α′⇒∗wi…wi′−1∧B′⇒∗wi′…wj−1 Тогда имеем [A→α′a⋅β,i]ε. диджей. Вы также можете записать S′⇒∗w0…wi−1Aδ как S′⇒∗w0…wi−1wi…wi′−1Bβδ, а также B→η∧η→wi′…wj−1.\nПрименяя индукцию по второму параметру, получаем [B→η⋅,i′]εDj, откуда по полному правилу получаем [A→α′B⋅β,i]εDj.\n\n3. α=ε, тогда i=j. Тогда либо i=0∧A=S∧δ=ε, что доказывает основу индукции, либо заключение можно записать S′⇒∗w0…wi′−1wi′…wi−1Aδ′δ′′ =w0… wi −1Aδ для правила (A→wi′…wi−1Aδ′)εP.\nТаким образом, по предположению индукции [A′→⋅wi′…wi−1Aδ′,i′]εDi′ , которое после нескольких применений правила сканирования приводит к [A′→wi′…wi−1 ⋅Aδ′, i′]ε Di, после чего согласно правилу прогнозирования получаем [A→⋅β,i]εDj, что и требовалось."
    },
    {
        "question": "LL-подгонка",
        "answer": "____\n●Устранение левой рекурсии\n●Извлечение левого контекста:\nЕсли даны A->Φγ_1, A-> Φγ_2, тогда можно построить эквивалентные правила A -> ΦA', A'-> γ_1|γ_2."
    },
    {
        "question": "LL-фитинг",
        "answer": "____\n●Устранение левой рекурсии\n●Извлечение левого контекста:\nЕсли заданы A->Φγ_1, A->Φγ_2, то можно построить эквивалентные правила A -> ΦA', A'-> γ_1|γ_2."
    },
    {
        "question": "фитинг LL",
        "answer": "____\n●Устранение левой рекурсии.\n●Извлечение левого контекста:\nЕсли заданы А->Фу_1, А->Фу_2, то можно построить эквивалентные правила А->ФА', А'->γ_1|γ_2."
    },
    {
        "question": "Кубок LL",
        "answer": "____\n●Устранение левой рекурсии.\n●Извлечение левого контекста:\nЕсли заданы А->Фу_1, А->Фу_2, то можно построить эквивалентные правила А->ФА', А'->γ_1|γ_2."
    },
    {
        "question": "Рекурсивный нетерминал",
        "answer": "____\nРекурсивный нетерминал — это нетерминальный символ в грамматике, который можно вывести в строку, содержащую самого себя. То есть, в процессе развертывания правил грамматики нетерминал может привести к цепочке вывода, где он снова появляется.\nНапример, если нетерминал \\( A \\) имеет правило \\( A \\rightarrow \\alpha A \\beta \\) или через несколько шагов выводится в такое, то \\( A \\) является рекурсивным."
    },
    {
        "question": "Рекурсивный нетерминал",
        "answer": "____\nРекурсивный нетерминал — это нетерминальный символ в грамматике, который может быть выведен в строку, содержащую самого себя. То есть в процессе расширения правил грамматики нетерминал может привести к цепочке выводов, где он снова появляется.\nНапример, если нетерминал \\( A \\) имеет правило \\( A \\rightarrow \\alpha A \\beta \\) или после нескольких шагов выводится в одно, то \\( A \\) является рекурсивным."
    },
    {
        "question": "Нетерминальная рекурсия",
        "answer": "____\nРекурсивный нетерминал — это нетерминальный символ в грамматике, который можно записать в строку, содержащую самого себя. Другими словами, в процессе расширения грамматических правил нетерминал может привести к цепочке умозаключений, где он появится вновь.\nНапример, если нетерминал \\( A\\) имеет правило \\( A \\rightarrow \\alpha A \\beta\\) или после нескольких шагов выводится за один, то \\( A\\) является рекурсивным."
    },
    {
        "question": "Нетерминальная рекурсия",
        "answer": "____\nРекурсивный нетерминал — это нетерминальный символ в грамматике, который можно записать в строку, содержащую самого себя. То есть в процессе расширения правила грамматики нетерминал может привести к выходной строке, где он появится снова.\nНапример, если нетерминал \\( A \\) подчиняется правилу \\( A \\rightarrow \\alpha A \\beta \\) или выводится из него после нескольких шагов, то \\( A \\) является рекурсивным."
    },
    {
        "question": "Леворекурсивный нетерминал",
        "answer": "____\nЛеворекурсивный нетерминал — это нетерминал, у которого есть правило, где он стоит первым символом в правой части своего собственного правила, то есть \\( A \\rightarrow A \\alpha \\), где \\( \\alpha \\) — некоторая строка символов.\nЛеворекурсия может приводить к проблемам при нисходящем разборе (парсинге), так как может вызывать бесконечную рекурсию в рекурсивных парсерах."
    },
    {
        "question": "Левый рекурсивный нетерминал",
        "answer": "____\nЛеворекурсивный нетерминал — это нетерминал, у которого есть правило, где он является первым символом в правой части своего правила, т. е. \\( A \\rightarrow A \\alpha \\), где \\( \\alpha \\) — это некоторая строка символов.\nЛеворекурсия может вызвать проблемы при нисходящем анализе, поскольку она может вызвать бесконечную рекурсию в рекурсивных синтаксических анализаторах."
    },
    {
        "question": "Леворекурсивный нетерминал",
        "answer": "____\nЛеворекурсивный нетерминал — это нетерминал, для которого существует правило, в котором он является первым символом в правой части правила, то есть \\( A \\rightarrow A \\alpha \\), где \\( \\alpha \\) — строка персонажей.\nЛевая рекурсия может вызвать проблемы при обратном анализе, поскольку она может вызвать бесконечную рекурсию в рекурсивных анализаторах."
    },
    {
        "question": "Леворекурсивный нетерминал",
        "answer": "____\nЛеворекурсивный нетерминал — это нетерминал, который имеет правило, в котором он появляется как первый символ в правой части собственного правила, то есть \\( A \\rightarrow A \\alpha \\), где \\( \\alpha \\) строка символов.\nЛевая рекурсия может вызвать проблемы при обратном анализе, поскольку она может вызвать бесконечную рекурсию в рекурсивных анализаторах."
    },
    {
        "question": "Праворекурсивный нетерминал",
        "answer": "____\nПраворекурсивный нетерминал — это нетерминал, у которого есть правило, где он стоит последним символом в правой части своего собственного правила, то есть \\( A \\rightarrow \\alpha A \\), где \\( \\alpha \\) — некоторая строка символов.\nПраворекурсия обычно не вызывает проблем при нисходящем разборе и может быть предпочтительнее для некоторых типов парсеров, хотя может влиять на эффективность при больших глубинах рекурсии."
    },
    {
        "question": "Правый рекурсивный нетерминал",
        "answer": "____\nПраворекурсивный нетерминал — это нетерминал, у которого есть правило, в котором он появляется как последний символ в правой части своего правила, т. е. \\( A \\rightarrow \\alpha A \\), где \\( \\alpha \\) — это некоторая строка символов.\nПравая рекурсия обычно не вызывает проблем при нисходящем синтаксическом анализе и может быть предпочтительнее для некоторых типов синтаксических анализаторов, хотя она может повлиять на эффективность при высокой глубине рекурсии."
    },
    {
        "question": "Праворекурсивный нетерминал",
        "answer": "____\nПраворекурсивный нетерминал — это нетерминал, для которого существует правило, в котором он появляется как последний символ в правой части правила, то есть \\( A \\rightarrow \\alpha A \\), где \\ (\\alpha\\) — это символьная строка.\nПравильная рекурсия обычно не вызывает проблем с анализом сверху вниз и может быть предпочтительнее для определенных типов анализаторов, хотя это может повлиять на производительность при большой глубине рекурсии."
    },
    {
        "question": "Праворекурсивный нетерминал",
        "answer": "____\nПраворекурсивный нетерминал — это нетерминал, имеющий правило, в котором он появляется как последний символ в правой части собственного правила, т. е. \\( A \\rightarrow \\alpha A \\), где \\( \\alpha \\ ) — это строка.\nПравильная рекурсия обычно не вызывает проблем с анализом сверху вниз и может быть предпочтительнее для определенных типов анализаторов, хотя это может повлиять на производительность при большей глубине рекурсии."
    },
    {
        "question": "Рассмотрим следующую контекстно-свободную грамматику \\( G \\):\n\n1. \\( S \\rightarrow aSb \\)\n2. \\( S \\rightarrow SS \\)\n3. \\( S \\rightarrow \\varepsilon \\)\nДокажите, что язык \\( L(G) \\), порождаемый грамматикой \\( G \\), непуст и опишите этот язык.",
        "answer": "____\nГрамматика \\( G \\) непустая, поскольку содержит правило \\( S \\rightarrow \\varepsilon \\), которое позволяет вывести пустую строку \\( \\varepsilon \\). Это означает, что \\( \\varepsilon \\in L(G) \\), и, следовательно, язык \\( L(G) \\) непуст.\n\nОпишем язык \\( L(G) \\), порождаемый грамматикой:\n\n1. Правило \\( S \\rightarrow aSb \\): Оно порождает строки, которые начинаются с символа \\( a \\), заканчиваются символом \\( b \\), а между ними может быть рекурсивно вставлена такая же структура. Это создает баланс между количеством \\( a \\) и \\( b \\), где каждому \\( a \\) слева соответствует \\( b \\) справа.\n\n2. Правило \\( S \\rightarrow SS \\): Это правило позволяет конкатенировать две любые строки, порожденные из \\( S \\). Таким образом, мы можем комбинировать несколько структур, порожденных первым правилом, или даже другие конкатенации.\n\n3. Правило \\( S \\rightarrow \\varepsilon \\): Позволяет завершить вывод и порождает пустую строку.\n\nОписание языка \\( L(G) \\):\n\nЯзык \\( L(G) \\) состоит из всех строк, содержащих равное количество символов \\( a \\) и \\( b \\), где символы \\( a \\) и \\( b \\) могут быть расположены таким образом, что каждая позиция символа \\( a \\) слева соответствует символу \\( b \\) справа, но также допускаются конкатенации таких структур.\n\nТо есть, \\( L(G) = \\{ w \\in \\{a, b\\}^* \\mid |w|_a = |w|_b \\} \\)."
    },
    {
        "question": "Рассмотрим следующую контекстно-свободную грамматику \\( G \\):\n\n1. \\( S \\rightarrow aSb \\)\n2. \\( S \\rightarrow SS \\)\n3. \\( S \\rightarrow \\varepsilon \\)\nДокажите, что язык \\( L(G) \\), порожденный грамматикой \\( G \\), непуст, и опишите этот язык.",
        "answer": "____\nГрамматика \\( G \\) непустая, потому что она содержит правило \\( S \\rightarrow \\varepsilon \\), которое позволяет выводить пустую строку \\( \\varepsilon \\). Это означает, что \\( \\varepsilon \\in L(G) \\), и, следовательно, язык \\( L(G) \\) непустой.\n\nОпишем язык \\( L(G) \\), сгенерированный грамматикой:\n\n1. Правило \\( S \\rightarrow aSb \\): Оно генерирует строки, которые начинаются с \\( a \\), заканчиваются на \\( b \\), и между ними может быть рекурсивно вставлена ​​одна и та же структура. Это создает баланс между количеством \\( a \\) и \\( b \\), где для каждого \\( a \\) слева есть \\( b \\) справа.\n\n2. Правило \\( S \\rightarrow SS \\): Это правило позволяет объединить любые две строки, сгенерированные из \\( S \\). Таким образом, мы можем объединить несколько структур, сгенерированных первым правилом, или даже другие конкатенации.\n\n3. Правило \\( S \\rightarrow \\varepsilon \\): Позволяет завершить вывод и создает пустую строку.\n\nОписание языка \\( L(G) \\):\n\nЯзык \\( L(G) \\) состоит из всех строк, содержащих равное количество символов \\( a \\) и \\( b \\), где символы \\( a \\) и \\( b \\) могут быть расположены таким образом, что каждая позиция символа \\( a \\) слева соответствует символу \\( b \\) справа, но конкатенации таких структур также разрешены.\n\nТо есть, \\( L(G) = \\{ w \\in \\{a, b\\}^* \\mid |w|_a = |w|_b \\} \\)."
    },
    {
        "question": "Рассмотрим следующую контекстно-свободную грамматику \\(G\\):\n\n1. \\( S \\rightarrow asSb \\)\n2. \\( S \\rightarrow SS \\)\n3. \\( S \\rightarrow \\varepsilon \\)\nПокажите, что язык \\( L(G) \\), порождённый грамматикой \\( G \\), непуст, и опишите этот язык.",
        "answer": "____\nГрамматика \\( G \\) непуста, поскольку она содержит правило \\( S \\rightarrow \\varepsilon \\), позволяющее выводить пустую строку \\( \\varepsilon \\). Это означает, что \\( \\varepsilon \\in L(G) \\), а значит, язык \\( L(G) \\) не пуст.\n\nОпишем язык \\(L(G)\\), порожденный грамматикой:\n\n1. Правило \\( S \\rightarrow aSb \\): оно генерирует строки, которые начинаются с \\( a \\), заканчиваются \\( b \\), и между ними можно рекурсивно вставлять одну и ту же структуру. Это создает баланс между количеством \\( a \\) и \\( b \\), где для каждого \\( a \\) слева есть \\( b \\) справа.\n\n2. Правило \\( S \\rightarrow SS \\): Это правило позволяет объединить любые две строки, сгенерированные из \\( S \\). Таким образом, мы можем объединить несколько структур, сгенерированных первым правилом, или даже другие конкатенации.\n\n3. Правило \\( S \\rightarrow \\varepsilon \\): разрешает завершение вывода и создает пустую строку.\n\nОписание языка \\(L(G)\\):\n\nЯзык \\( L(G) \\) состоит из всех строк, содержащих равное количество символов \\( a \\) и \\( b \\), где символы \\( a \\) и \\( b \\) могут быть расположены в таким образом, что каждая позиция символа \\(a\\) слева соответствует символу \\(b\\) справа, но допускается также объединение таких структур.\n\nДругими словами, \\( L(G) = \\{ w \\in \\{a, b\\}^* \\mid |w|_a = |w|_b \\} \\)."
    },
    {
        "question": "Рассмотрим следующую контекстно-свободную грамматику \\(G\\):\n\n1. \\( S \\rightarrow asSb \\)\n2. \\( S \\rightarrow SS \\)\n3. \\( S \\rightarrow \\varepsilon \\)\nПокажите, что язык \\( L(G) \\), порождённый грамматикой \\( G \\), непуст и опишем этот язык.",
        "answer": "____\nГрамматика \\( G \\) непуста, поскольку содержит правило \\( S \\rightarrow \\varepsilon \\), позволяющее печатать пустую строку \\( \\varepsilon \\). Это означает, что \\( \\varepsilon \\in L(G) \\), а значит, язык \\( L(G) \\) не пуст.\n\nОпишем язык \\(L(G)\\), порожденный грамматикой:\n\n1. Правило \\(S\\rightarrow aSb\\): оно порождает строки, начинающиеся с символа \\(a\\), заканчивающиеся символом \\(b\\), и между ними можно рекурсивно вставлять одну и ту же структуру. Это создает баланс между количеством \\( a \\) и \\( b \\), где каждому \\( a \\) слева соответствует \\( b \\) справа.\n\n2. Правило \\( S \\rightarrow SS \\): Это правило позволяет объединить две строки, сгенерированные из \\( S \\). Таким образом, мы можем объединить несколько структур, сгенерированных первым правилом, или даже другие конкатенации.\n\n3. Правило \\(S \\rightarrow \\varepsilon \\): завершает вывод и создает пустую строку.\n\nОписание языка \\(L(G)\\):\n\nЯзык \\( L(G) \\) состоит из всех строк, содержащих равное количество символов \\( a \\) и \\( b \\), где символы \\( a \\) и \\( b \\) могут быть расположены в таким образом, что каждая позиция символа \\(a\\) слева соответствует символу \\(b\\) справа, но допускается также объединение таких структур.\n\nДругими словами, \\( L(G) = \\{ w \\in \\{a, b\\}^* \\mid |w|_a = |w|_b \\} \\)."
    },
    {
        "question": "Рассмотрим следующую контекстно-свободную грамматику \\( G \\):\n\n1. \\( S \\rightarrow aSb \\)\n2. \\( S \\rightarrow SS \\)\n3. \\( S \\rightarrow \\varepsilon \\)\nПостройте недетерминированный магазинный автомат (НМПА), эквивалентный грамматике \\( G \\).",
        "answer": "____\nДля построения НМПА, распознающего язык \\( L(G) \\), мы можем воспользоваться следующим подходом:\n\nАлфавит ввода: \\( \\{a, b\\} \\)\n\nАлфавит стека: \\( \\{A\\} \\) (символ для отслеживания количества \\( a \\))\n\nНабор состояний: \\( \\{q_0\\} \\) (начальное и единственное состояние)\n\nФункции переходов:\n\n1. Обработка символа \\( a \\):\n\n   При чтении символа \\( a \\), НМПА кладет символ \\( A \\) в стек.\n\n   \\( \\delta(q_0, a, Z) = \\{ (q_0, AZ) \\} \\)\n\n   \\( \\delta(q_0, a, A) = \\{ (q_0, AA) \\} \\)\n\n2. Обработка символа \\( b \\):\n\n   При чтении символа \\( b \\), НМПА снимает символ \\( A \\) с вершины стека, если он там есть.\n\n   \\( \\delta(q_0, b, A) = \\{ (q_0, \\varepsilon) \\} \\)\n\n3. Обработка пустого символа (для принятия пустой строки):\n\n   \\( \\delta(q_0, \\varepsilon, Z) = \\{ (q_0, Z) \\} \\)\n\nОписание работы НМПА:\n\n- НМПА начинает в состоянии \\( q_0 \\) со стеком, содержащим начальный символ \\( Z \\).\n\n- При чтении каждого символа \\( a \\) автомат кладет \\( A \\) в стек, увеличивая счетчик количества \\( a \\).\n\n- При чтении каждого символа \\( b \\) автомат снимает \\( A \\) с вершины стека, уменьшая счетчик.\n\n- Если после обработки всей входной строки стек возвращается к начальному символу \\( Z \\) (т.е. стек пуст в отношении символов \\( A \\)), автомат принимает строку.\n\n- НМПА принимает строку, если количество символов \\( a \\) равно количеству символов \\( b \\).\n\nСоответствие грамматике \\( G \\):\n\n- Правило \\( S \\rightarrow aSb \\) соответствует увеличению стека на \\( A \\) при чтении \\( a \\) и последующему уменьшению при чтении \\( b \\).\n\n- Правило \\( S \\rightarrow SS \\) соответствует недетерминированности НМПА, позволяющей ему разделять строку на подстроки, обрабатываемые независимо.\n\n- Правило \\( S \\rightarrow \\varepsilon \\) соответствует возможности НМПА принять пустую строку без изменения стека."
    },
    {
        "question": "Рассмотрим следующую контекстно-свободную грамматику \\( G \\):\n\n1. \\( S \\rightarrow aSb \\)\n2. \\( S \\rightarrow SS \\)\n3. \\( S \\rightarrow \\varepsilon \\)\nПостройте недетерминированный магазинный автомат (NPA), эквивалентный грамматике \\( G \\).",
        "answer": "____\nЧтобы построить NMPA, распознающий язык \\( L(G) \\), мы можем использовать следующий подход:\n\nВходной алфавит: \\( \\{a, b\\} \\)\n\nСтековый алфавит: \\( \\{A\\} \\) (символ для отслеживания количества \\( a \\))\n\nНабор состояний: \\( \\{q_0\\} \\) (начальное и единственное состояние)\n\nФункции перехода:\n\n1. Обработка символа \\( a \\):\n\nПри чтении символа \\( a \\) NMPA помещает символ \\( A \\) в стек.\n\n\\( \\delta(q_0, a, Z) = \\{ (q_0, AZ) \\} \\)\n\n\\( \\delta(q_0, a, A) = \\{ (q_0, AA) \\} \\)\n\n2. Обработка символа \\( b \\):\n\nПри чтении символа \\( b \\) NMPA удаляет символ \\( A \\) из вершины стека, если он там есть.\n\n\\( \\delta(q_0, b, A) = \\{ (q_0, \\varepsilon) \\} \\)\n\n3. Обработка пустого символа (для принятия пустой строки):\n\n\\( \\delta(q_0, \\varepsilon, Z) = \\{ (q_0, Z) \\} \\)\n\nОписание работы NMPA:\n\n- NMPA начинает работу в состоянии \\( q_0 \\) со стеком, содержащим начальный символ \\( Z \\).\n\n- При чтении каждого символа \\( a \\) автомат помещает \\( A \\) в стек, увеличивая счетчик \\( a \\).\n\n- При чтении каждого символа \\( b \\) автомат извлекает \\( A \\) из вершины стека, уменьшая счетчик.\n\n- Если после обработки всей входной строки стек возвращается к начальному символу \\( Z \\) (т. е. стек пуст относительно символов \\( A \\)), автомат принимает строку.\n\n- NMPA принимает строку, если количество символов \\( a \\) равно количеству символов \\( b \\).\n\nСоответствие грамматике \\( G \\):\n\n- Правило \\( S \\rightarrow aSb \\) соответствует увеличению стека на \\( A \\) при чтении \\( a \\) и последующему его уменьшению при чтении \\( b \\).\n\n- Правило \\( S \\rightarrow SS \\) соответствует недетерминизму NMPA, что позволяет ему разбивать строку на подстроки, обрабатываемые независимо.\n\n- Правило \\( S \\rightarrow \\varepsilon \\) соответствует способности NMPA принимать пустую строку без изменения стека."
    },
    {
        "question": "Рассмотрим следующую контекстно-свободную грамматику \\(G\\):\n\n1. \\( S \\rightarrow asSb \\)\n2. \\( S \\rightarrow SS \\)\n3. \\( S \\rightarrow \\varepsilon \\)\nПостройте недетерминированный автомат хранения (NPA), эквивалентный грамматике \\(G\\).",
        "answer": "____\nЧтобы построить NMPA, распознающий язык \\(L(G)\\), мы можем использовать следующий подход:\n\nВходной алфавит: \\( \\{a, b\\} \\)\n\nАлфавит стека: \\( \\{A\\} \\) (символ для отслеживания количества \\( a \\))\n\nНабор состояний: \\( \\{q_0\\} \\) (начальное и уникальное состояние)\n\nФункции перехода:\n\n1. Обработка символа \\(a\\):\n\nПри чтении символа \\(a\\) NMPA помещает символ \\(A\\) в стек.\n\n\\( \\delta(q_0, a, Z) = \\{ (q_0, AZ) \\} \\)\n\n\\( \\delta(q_0, a, A) = \\{ (q_0, AA) \\} \\)\n\n2. Обработка символа \\(b\\):\n\nПри чтении символа \\(b\\) NMPA удаляет символ \\(A\\) с вершины стека, если он там есть.\n\n\\( \\delta(q_0, b, A) = \\{ (q_0, \\varepsilon) \\} \\)\n\n3. Обработка пустых символов (принятие пустой строки):\n\n\\( \\delta(q_0, \\varepsilon, Z) = \\{ (q_0, Z) \\} \\)\n\nОписание вакансии НМПА:\n\n- NMPA начинается в состоянии \\(q_0\\) со стеком, содержащим начальный символ \\(Z\\).\n\n- При чтении каждого символа \\(a\\) машина помещает \\(A\\) в стек, увеличивая счетчик \\(a\\).\n\n- При чтении каждого символа \\(b\\) автомат извлекает \\(A\\) с вершины стека, уменьшая счетчик.\n\n- Если после обработки всей входной строки стек возвращается к начальному символу \\(Z\\) (т.е. стек пуст относительно символов \\(A\\)), машина принимает цепочку.\n\n- NMPA принимает строку, если количество символов \\(a\\) равно количеству символов \\(b\\).\n\nСоответствует грамматике \\(G\\):\n\n- Правило \\( S \\rightarrow aSb \\) соответствует увеличению стека \\( A \\) при чтении \\( a \\) и затем его уменьшению при чтении \\( b \\).\n\n- Правило \\( S \\rightarrow SS \\) соответствует недетерминизму NMPA, позволяя разбивать строку на независимо обрабатываемые подстроки.\n\n- Правило \\( S\\rightarrow\\varepsilon\\) соответствует способности NMPA принимать пустую строку без изменения стека."
    },
    {
        "question": "Рассмотрим следующую контекстно-свободную грамматику \\(G\\):\n\n1. \\( S \\rightarrow asSb \\)\n2. \\( S \\rightarrow SS \\)\n3. \\( S \\rightarrow \\varepsilon \\)\nПостройте недетерминированный автомат хранения (NMSA), эквивалентный грамматике \\(G\\).",
        "answer": "____\nЧтобы построить NMPA, распознающий язык \\(L(G)\\), мы можем использовать следующий подход:\n\nВходной алфавит: \\( \\{a, b\\} \\)\n\nАлфавит стека: \\( \\{A\\} \\) (символ для отслеживания количества \\( a \\))\n\nНабор состояний: \\( \\{q_0\\} \\) (начальное и уникальное состояние)\n\nФункции перехода:\n\n1. Обработка символа \\(a\\):\n\n   При чтении символа \\(a\\) NMPA помещает символ \\(A\\) в стек.\n\n   \\( \\delta(q_0, a, Z) = \\{ (q_0, AZ) \\} \\)\n\n   \\( \\delta(q_0, a, A) = \\{ (q_0, AA) \\} \\)\n\n2. Обработка символа \\(b\\):\n\n   При чтении символа \\(b\\) NMPA извлекает символ \\(A\\) с вершины стека, если он там есть.\n\n   \\( \\delta(q_0, b, A) = \\{ (q_0, \\varepsilon) \\} \\)\n\n3. Обработка пустых символов (принятие пустой строки):\n\n   \\( \\delta(q_0, \\varepsilon, Z) = \\{ (q_0, Z) \\} \\)\n\nОписание работы НМПА:\n\n- NMPA начинается в состоянии \\(q_0\\) со стеком, содержащим начальный символ \\(Z\\).\n\n- При чтении каждого символа \\(a\\) машина помещает \\(A\\) в стек, увеличивая число \\(a\\).\n\n- При чтении каждого символа \\(b\\) машина извлекает \\(A\\) из вершины стека, уменьшая счетчик.\n\n- Если после обработки всей входной строки стек возвращается к начальному символу \\(Z\\) (т.е. стек пуст относительно символов \\(A\\)), машина принимает цепочку.\n\n- NMPA принимает строку, если количество символов \\(a\\) равно количеству символов \\(b\\).\n\nСоответствует грамматике \\(G\\):\n\n- Правило \\(S\\rightarrow aSb\\) соответствует увеличению стека \\(A\\) при чтении \\(a\\) и последующему уменьшению при чтении \\(b\\).\n\n- Правило \\(S\\rightarrow SS\\) соответствует недетерминированности NMPA, что позволяет ему делить строку на независимо обрабатываемые подстроки.\n\n- Правило \\( S\\rightarrow\\varepsilon\\) соответствует способности NMPA принимать пустую строку без изменения стека."
    },
    {
        "question": "Рассмотрим следующую контекстно-свободную грамматику \\( G \\):\n\n1. \\( S \\rightarrow aSb \\)\n2. \\( S \\rightarrow SS \\)\n3. \\( S \\rightarrow \\varepsilon \\)\nОбъясните, почему невозможно построить детерминированный магазинный автомат, распознающий язык \\( L(G) \\).",
        "answer": "____\nЯзык \\( L(G) \\) состоит из всех строк над алфавитом \\( \\{a, b\\} \\), в которых количество символов \\( a \\) равно количеству символов \\( b \\). Этот язык не является детерминированным контекстно-свободным.\n\nПричины невозможности построения детерминированного МПА:\n\n1. Отсутствие возможности предсказания:\n\n   Детерминированный МПА должен на каждом шаге однозначно определять действие (переход и операция со стеком) на основе текущего состояния, символа входа и символа на вершине стека.\n\n   В языке \\( L(G) \\) символы \\( a \\) и \\( b \\) могут появляться в любом порядке, при этом решение, когда положить символ в стек или когда извлечь его, не может быть принято однозначно на основе текущей информации.\n\n2. Недетерминированность необходима для балансировки:\n\n   Чтобы определить, соответствует ли данная строка условию \\( |w|_a = |w|_b \\), автомат должен \"заглядывать\" вперед или помнить неопределенное количество информации о прочитанных символах. Это требует недетерминированных выборов.\n\n3. Пример невозможности однозначного перехода:\n\n   Рассмотрим ситуацию, когда автомат прочитал несколько символов \\( a \\) и \\( b \\) в произвольном порядке. При встрече следующего символа автомат не может однозначно решить, следует ли добавить символ в стек или извлечь его, так как не известно, какие символы еще последуют.\n\nЗаключение:\n\nНедетерминированность необходима для распознавания языка \\( L(G) \\), поскольку автомат должен рассматривать все возможные варианты распределения символов \\( a \\) и \\( b \\), обеспечивающих условие равенства их количества. Это невозможно реализовать в детерминированном МПА, где каждый шаг строго определен."
    },
    {
        "question": "Рассмотрим следующую контекстно-свободную грамматику \\( G \\):\n\n1. \\( S \\rightarrow aSb \\)\n2. \\( S \\rightarrow SS \\)\n3. \\( S \\rightarrow \\varepsilon \\)\nОбъясните, почему невозможно построить детерминированный магазинный автомат, распознающий язык \\( L(G) \\).",
        "answer": "____\nЯзык \\( L(G) \\) состоит из всех строк в алфавите \\( \\{a, b\\} \\), в которых количество символов \\( a \\) равно количеству символов \\( b \\). Этот язык не является детерминированным контекстно-свободным.\n\nПричины, по которым невозможно построить детерминированный MFSM:\n\n1. Отсутствие прогнозирования:\n\nДетерминированный MFSM должен однозначно определять действие (переход и операцию стека) на каждом шаге на основе текущего состояния, символа входа и символа на вершине стека.\n\nВ языке \\( L(G) \\) символы \\( a \\) и \\( b \\) могут появляться в любом порядке, и решение о том, когда помещать символ в стек или извлекать его, не может быть принято однозначно на основе текущей информации.\n\n2. Недетерминизм необходим для балансировки:\n\nЧтобы определить, удовлетворяет ли заданная строка условию \\( |w|_a = |w|_b \\), автомат должен «смотреть» вперед или помнить неопределенное количество информации о прочитанных символах. Это требует недетерминированного выбора.\n\n3. Пример невозможности однозначного перехода:\n\nРассмотрим ситуацию, когда автомат прочитал несколько символов \\( a \\) и \\( b \\) в произвольном порядке. Когда он сталкивается со следующим символом, автомат не может однозначно решить, добавлять символ в стек или выталкивать его, так как неизвестно, какие символы последуют за ним.\n\nВывод:\n\nНедетерминизм необходим для распознавания языка \\( L(G) \\), так как автомат должен рассмотреть все возможные варианты распределения символов \\( a \\) и \\( b \\), обеспечивающие условие их равенства по количеству. Это невозможно реализовать в детерминированном МФМ, где каждый шаг строго определен."
    },
    {
        "question": "Рассмотрим следующую контекстно-свободную грамматику \\(G\\):\n\n1. \\( S \\rightarrow asSb \\)\n2. \\( S \\rightarrow SS \\)\n3. \\( S \\rightarrow \\varepsilon \\)\nОбъясните, почему невозможно построить детерминированный автомат-накопитель, распознающий язык \\(L(G)\\).",
        "answer": "____\nЯзык \\( L(G) \\) состоит из всех строк алфавита \\( \\{a, b\\} \\), в которых количество символов \\( a \\) равно количеству символов \\( b\\ ). Этот язык не является детерминированным без контекста.\n\nПричины, по которым невозможно построить детерминированный MSMF:\n\n1. Отсутствие прогнозов:\n\nДетерминированный MFSM должен однозначно определять действие (операцию подключения и стека) на каждом этапе на основе текущего состояния, входного символа и символа на вершине стека.\n\nВ языке \\(L(G)\\) символы \\(a\\) и \\(b\\) могут появляться в любом порядке, и решение о том, когда поместить символ в стек или удалить его, не может появиться. приниматься единым способом. на основе текущей информации.\n\n2. Недетерминизм необходим для того, чтобы сбалансировать:\n\nЧтобы определить, удовлетворяет ли данная строка условию \\( |w|_a = |w|_b \\), машина должна «просмотреть» вперед или запомнить неопределенное количество информации о прочитанных символах. Это требует недетерминированного выбора.\n\n3. Пример невозможности однозначного перехода:\n\nРассмотрим ситуацию, когда машина считывает несколько символов \\(a\\) и \\(b\\) в случайном порядке. Встречая следующий символ, машина не может однозначно решить, добавить ли символ в стек или вытолкнуть его, поскольку неясно, какие символы последуют за ним.\n\nЗаключение:\n\nНедетерминированность необходима для распознавания языка \\(L(G)\\), так как автомат должен рассматривать все возможные варианты распределения символов \\(a\\) и \\(b\\), обеспечивая условие их равенства в количестве. Это невозможно реализовать в детерминированной ММД, где каждый шаг строго определен."
    },
    {
        "question": "Рассмотрим следующую контекстно-свободную грамматику \\(G\\):\n\n1. \\( S \\rightarrow asSb \\)\n2. \\( S \\rightarrow SS \\)\n3. \\( S \\rightarrow \\varepsilon \\)\nОбъясните, почему невозможно построить детерминированный автомат-накопитель, распознающий язык \\(L(G)\\).",
        "answer": "____\nЯзык \\( L(G) \\) состоит из всех строк алфавита \\( \\{a, b\\} \\) в которых количество символов \\( a \\) равно количеству символов \\( b\\ ). Этот язык не является детерминированным без контекста.\n\nПричины невозможности построения детерминированного МПА:\n\n1. Отсутствие способности прогнозировать:\n\n   Детерминированный MPA должен на каждом этапе однозначно определять действие (операцию подключения и стека) на основе текущего состояния, входного символа и символа на вершине стека.\n\n   В языке \\(L(G)\\) символы \\(a\\) и \\(b\\) могут появляться в любом порядке, но решение о том, когда помещать символ в стек или когда его выталкивать, не может быть принято. быть взятым. однозначно на основе текущей информации.\n\n2. Недетерминизм необходим для того, чтобы сбалансировать:\n\n   Чтобы определить, удовлетворяет ли данная строка условию \\( |w|_a = |w|_b \\), машина должна «просмотреть» вперед или запомнить неопределенное количество информации о прочитанных символах. Это требует недетерминированного выбора.\n\n3. Пример невозможности однозначного перехода:\n\n   Рассмотрим ситуацию, когда машина считывает несколько символов \\(a\\) и \\(b\\) в случайном порядке. При встрече следующего символа машина не может однозначно решить, добавить ли символ в стек или вытолкнуть его, поскольку неизвестно, какие символы последуют за ним.\n\nЗаключение:\n\nНедетерминированность необходима для распознавания языка \\( L(G) \\), так как автомат должен учитывать все возможные варианты распределения символов \\( a \\) и \\( b \\), обеспечивая условие d равенства их количество. Это невозможно реализовать в детерминированном MPA, где каждый шаг строго определен."
    },
    {
        "question": "Алгоритм избавления от левой рекурсии",
        "answer": "____\n\nШаги алгоритма устранения левой рекурсии:\n\n1. Идентификация левой рекурсии:\n   - Непосредственная левая рекурсия: Когда правило имеет вид A → Aα | β, где A — нетерминал, α — последовательность символов (непустая), а β — альтернатива, которая не начинается с A.\n   - Косвенная левая рекурсия: Когда последовательность правил приводит к ситуации, где A → Bα, а B может вывести A в качестве первого символа (т.е. B ⇒+ A).\n\n2. Устранение непосредственной левой рекурсии для каждого нетерминала:\n   Для каждого нетерминала A, имеющего правила вида:\n   \n\n   A → Aα₁ | Aα₂ | ... | Aαₙ | β₁ | β₂ | ... | βₘ\n   \n   где β₁, β₂, ..., βₘ — альтернативы, которые не начинаются с A.\n\n   - Создаем новый нетерминал A'.\n   - Переписываем правила следующим образом:\n     \n\n     A  → β₁A' | β₂A' | ... | βₘA'\n     A' → α₁A' | α₂A' | ... | αₙA' | ε\n     \n     Здесь ε обозначает пустую строку (эпсилон).\n\n3. Устранение косвенной левой рекурсии:\n   - Упорядочиваем нетерминалы в некотором порядке A₁, A₂, ..., An.\n   - Для каждого нетерминала Ai от i = 1 до n:\n     - Для каждого правила вида Ai → Ajγ, где j < i:\n       - Заменяем Aj на его правые части.\n     - После замены устраняем непосредственную левую рекурсию из правил для Ai, используя метод из шага 2."
    },
    {
        "question": "Алгоритм избавления от левой рекурсии",
        "answer": "____\n\nШаги алгоритма устранения левой рекурсии:\n\n1. Выявление левой рекурсии:\n- Непосредственная левая рекурсия: когда правило имеет вид A → Aα | β, где A — нетерминал, α — последовательность символов (непустая), а β — альтернатива, которая не начинается с A.\n- Косвенная левая рекурсия: когда последовательность правил приводит к ситуации, когда A → Bα, а B может вывести A как первый символ (т. е. B ⇒+ A).\n\n2. Устранение непосредственной левой рекурсии для каждого нетерминала:\nДля каждого нетерминала A, имеющего правила вида:\n\nA → Aα₁ | Aα₂ | ... | Aαₙ | β₁ | β₂ | ... | βₘ\n\nгде β₁, β₂, ..., βₘ — альтернативы, которые не начинаются с A.\n\n- Создайте новый нетерминал A'.\n- Перепишите правила следующим образом:\n\nA → β₁A' | β₂A' | ... | βₘA'\nA' → α₁A' | α₂A' | ... | αₙA' | ε\n\nЗдесь ε обозначает пустую строку (эпсилон).\n\n3. Устраните косвенную левую рекурсию:\n- Упорядочьте нетерминалы в некотором порядке A₁, A₂, ..., An.\n- Для каждого нетерминала Ai от i = 1 до n:\n- Для каждого правила вида Ai → Ajγ, где j < i:\n- Заменить Aj его правыми частями.\n- После замены исключить немедленную левую рекурсию из правил для Ai, используя метод из шага 2."
    },
    {
        "question": "Алгоритм избавления от левой рекурсии",
        "answer": "____\n\nШаги алгоритма устранения левой рекурсии:\n\n1. Определить левую рекурсию:\n- Прямая рекурсия слева: когда правило имеет вид A → Aα | β, где A — нетерминал, α — (непустая) последовательность символов, а β — альтернатива, не начинающаяся с A.\n- Косвенная левая рекурсия: когда последовательность правил приводит к ситуации, когда A → Bα и B могут отображать A в качестве первого символа (т.е. B ⇒+ A).\n\n2. Устранить немедленную левую рекурсию для каждого нетерминала:\nДля каждого нетерминала А, имеющего правила вида:\n\nА → Aα₁ | Аα₂ | ... | Аαₙ | β₁ | β₂ | ... | βₘ\n\nгде β₁, β₂, ..., βₘ — альтернативы, которые не начинаются с буквы A.\n\n- Создайте новый нетерминал A'.\n- Перепишите правила следующим образом:\n\nА → β₁А' | β₂A' | ... | βₘА'\nА' → α₁А' | α₂А' | ... | αₙА' | ε\n\nЗдесь ε обозначает пустую строку (эпсилон).\n\n3. Устраните косвенную левую рекурсию:\n- Расположите нетерминалы в определенном порядке A₁, A₂, ..., An.\n- Для каждого нетерминала Ai от i = 1 до n:\n- Для каждого правила вида Ai → Ajγ, где j < i:\n- Замените Aj его правыми частями.\n- После замены исключите немедленную левую рекурсию из правил для Ai, используя метод, описанный в шаге 2."
    },
    {
        "question": "Алгоритм избавления от левой рекурсии",
        "answer": "____\n\nШаги алгоритма устранения левой рекурсии:\n\n1. Выявление левой рекурсии:\n   - Прямая рекурсия слева: когда правило имеет вид A → Aα | β, где A — нетерминал, α — (непустая) последовательность символов, а β — альтернатива, не начинающаяся с A.\n   - Косвенная левая рекурсия: когда последовательность правил приводит к ситуации, когда A → Bα и B могут отображать A в качестве первого символа (т.е. B ⇒+ A).\n\n2. Устранить немедленную левую рекурсию для каждого нетерминала:\n   Для каждого нетерминала А, имеющего правила вида:\n   \n\n   А → Aα₁ | Аα₂ | ... | Аαₙ | β₁ | β₂ | ... | βₘ\n   \n   где β₁, β₂, ..., βₘ — альтернативы, которые не начинаются с буквы A.\n\n   - Создайте новый нетерминал A'.\n   - Переписываем правила следующим образом:\n     \n\n     А → β₁А' | β₂A' | ... | βₘА'\n     А' → α₁А' | α₂А' | ... | αₙА' | ε\n     \n     Здесь ε обозначает пустую строку (эпсилон).\n\n3. Устранение левой косвенной рекурсии:\n   - Располагаем нетерминалы в определенном порядке A₁, A₂, ..., An.\n   - Для каждого нетерминала Ai от i = 1 до n:\n     - Для каждого правила вида Ai → Ajγ, где j < i:\n       - Замените Aj его правыми частями.\n     — После замены устраняем непосредственную левую рекурсию правил для Ai методом из шага 2."
    },
    {
        "question": "Различия между контекстно-свободной грамматикой и автоматной грамматикой",
        "answer": "____\nКлючевые различия между контекстно-свободными (КС) грамматиками и автоматными грамматиками\n\nКонтекстно-свободные грамматики (КС-грамматики):\n\nКонтекстно-свободные грамматики являются более мощным инструментом для описания языков по сравнению с регулярными (автоматными) грамматиками. Они используются для определения контекстно-свободных языков и занимают второй уровень в иерархии Хомского (типа 2).\n- Правила имеют вид: \\(A \\rightarrow \\alpha\\), где \\(A\\) — нетерминальный символ, а \\(\\alpha\\) — произвольная строка из терминальных и нетерминальных символов.\n\nАвтоматные грамматики (Регулярные грамматики):\n\nАвтоматные грамматики, также известные как регулярные грамматики, являются самым простым классом грамматик и соответствуют регулярным языкам. Они находятся на самом низком уровне иерархии Хомского (типа 3).\n- Правила имеют вид:\n    - Праволинейные грамматики: \\(A \\rightarrow aB\\) или \\(A \\rightarrow a\\)\n    - Леволинейные грамматики: \\(A \\rightarrow Ba\\) или \\(A \\rightarrow a\\)\n    - Где \\(A\\) и \\(B\\) — нетерминалы, \\(a\\) — терминальный символ.\n\n*Основные различия:\n\n1. **Выразительная мощность:\n   - КС-грамматики способны описывать более сложные языки с рекурсией и вложенностями.\n   - Регулярные грамматики ограничены описанием простых последовательностей без рекурсивных структур.\n\n2. Типы правил производства:\n   - В КС-грамматиках на левой стороне правила всегда один нетерминал, а правая сторона может быть любой строкой из терминалов и нетерминалов.\n   - В регулярных грамматиках правая часть правила ограничена одним терминалом, возможно с последующим нетерминалом (для праволинейных грамматик), или нетерминалом, предшествующим терминалу (для леволинейных грамматик).\n\n3. Соответствующие автоматы:\n   - КС-языки распознаются автоматами с магазинной памятью, которые имеют стек для учета вложенных структур.\n   - Регулярные языки распознаются конечными автоматами без дополнительной памяти.\n\n4.Замкнутость относительно операций:\n   - Регулярные языки замкнуты относительно объединения, конкатенации, замыкания Клини, пересечения и дополнения.\n   - КС-языки замкнуты относительно объединения, конкатенации и замыкания Клини, но не замкнуты относительно пересечения и дополнения."
    },
    {
        "question": "Различия между контекстно-свободной грамматикой и автоматной грамматикой",
        "answer": "____\nКлючевые различия между контекстно-свободными (КС) грамматиками и автоматными грамматиками\n\nКонтекстно-свободные грамматики (КС грамматики):\n\nКонтекстно-свободные грамматики являются более мощным инструментом для описания языков, чем регулярные (автоматные) грамматики. Они используются для определения контекстно-свободных языков и занимают второй уровень в иерархии Хомского (тип 2).\n- Правила имеют вид: \\(A \\rightarrow \\alpha\\), где \\(A\\) — нетерминальный символ, а \\(\\alpha\\) — произвольная строка терминальных и нетерминальных символов.\n\nАвтоматные грамматики (регулярные грамматики):\n\nАвтоматные грамматики, также известные как регулярные грамматики, являются простейшим классом грамматик и соответствуют регулярным языкам. Они находятся на самом нижнем уровне иерархии Хомского (тип 3).\n- Правила имеют вид:\n- Праволинейные грамматики: \\(A \\rightarrow aB\\) или \\(A \\rightarrow a\\)\n- Леволинейные грамматики: \\(A \\rightarrow Ba\\) или \\(A \\rightarrow a\\)\n- Где \\(A\\) и \\(B\\) являются нетерминалами, \\(a\\) является терминальным символом.\n\n*Основные отличия:\n\n1. **Выразительная сила:\n- CFG способны описывать более сложные языки с рекурсией и вложенностью.\n- Регулярные грамматики ограничены описанием простых последовательностей без рекурсивных структур.\n\n2. Типы правил продукции:\n- В CFG левая часть правила всегда является одним нетерминалом, а правая часть может быть любой строкой терминалов и нетерминалов.\n- В регулярных грамматиках правая часть правила ограничена одним терминалом, за которым может следовать нетерминал (для правосторонних грамматик) или нетерминал, предшествующий терминалу (для левосторонних грамматик).\n\n3. Соответствующие автоматы:\n- Языки CF распознаются магазинными автоматами, имеющими стек для учета вложенных структур.\n- Регулярные языки распознаются конечными автоматами без дополнительной памяти.\n\n4. Замкнутость относительно операций:\n- Регулярные языки замкнуты относительно объединения, конкатенации, замыкания Клини, пересечения и дополнения.\n- Языки CF замкнуты относительно объединения, конкатенации и замыкания Клини, но не относительно пересечения и дополнения."
    },
    {
        "question": "Различия между контекстно-свободной грамматикой и автоматной грамматикой",
        "answer": "____\nОсновные различия между контекстно-свободными (CF) грамматиками и автоматными грамматиками\n\nБесконтекстные грамматики (CS-грамматики):\n\nБесконтекстные грамматики — более мощный инструмент описания языков, чем классические (автоматические) грамматики. Они используются для определения языков вне контекста и занимают второй уровень в иерархии Хомского (тип 2).\n- Правила имеют вид: \\(A \\rightarrow \\alpha\\), где \\(A\\) — нетерминальный символ, а \\(\\alpha\\) — произвольная строка терминальных и нетерминальных символов.\n\nАвтоматические грамматики (регулярные грамматики):\n\nГрамматики-автоматы, называемые также регулярными грамматиками, составляют простейший класс грамматик и соответствуют регулярным языкам. Они находятся на самом низком уровне иерархии Хомского (тип 3).\n- Правила выглядят так:\n- Прямолинейные грамматики: \\(A \\rightarrow aB\\) или \\(A \\rightarrow a\\)\n- Леволинейные грамматики: \\(A \\rightarrow Ba\\) или \\(A \\rightarrow a\\)\n- Где \\(A\\) и \\(B\\) — нетерминалы, \\(a\\) — терминальный символ.\n\n*Основные отличия:\n\n1. **Выразительная сила:\n— CFG способны описывать более сложные языки с рекурсией и вложенностью.\n- Регулярные грамматики ограничиваются описанием простых последовательностей без рекурсивных структур.\n\n2. Типы правил продукта:\n- В CFG левая часть правила всегда представляет собой один нетерминал, а правая сторона может быть любой цепочкой терминалов и нетерминалов.\n- В обычных грамматиках правая часть правила ограничена одним терминалом, за которым может следовать нетерминал (для правосторонних грамматик) или нетерминал, предшествующий терминалу (для правосторонних грамматик). левые грамматики). ).\n\n3. Соответствующие машины:\n— Языки CF распознаются машинами хранения, имеющими стек для размещения вложенных структур.\n— Обычные языки распознаются конечными автоматами без дополнительной памяти.\n\n4. Закрытие операций:\n— Обычные языки закрыты при объединении, конкатенации, замыкании Клини, пересечении и дополнении.\n— Языки CF закрыты при объединении, конкатенации и замыкании Клини, но не при пересечении и дополнении."
    },
    {
        "question": "Различия между контекстно-свободной грамматикой и автоматной грамматикой",
        "answer": "____\nОсновные различия между контекстно-свободными (CF) грамматиками и автоматными грамматиками\n\nБесконтекстные грамматики (CS-грамматики):\n\nБесконтекстные грамматики — более мощный инструмент описания языков, чем классические (автоматические) грамматики. Они используются для определения языков вне контекста и занимают второй уровень иерархии Хомского (тип 2).\n- Правила имеют вид: \\(A \\rightarrow \\alpha\\), где \\(A\\) — нетерминальный символ, а \\(\\alpha\\) — произвольная строка терминальных и нетерминальных символов.\n\nАвтоматические грамматики (регулярные грамматики):\n\nГрамматики-автоматы, называемые также регулярными грамматиками, составляют простейший класс грамматик и соответствуют регулярным языкам. Они расположены на самом низком уровне иерархии Хомского (тип 3).\n- Правила выглядят так:\n    - Прямолинейные грамматики: \\(A \\rightarrow aB\\) или \\(A \\rightarrow a\\)\n    - Леволинейные грамматики: \\(A \\rightarrow Ba\\) или \\(A \\rightarrow a\\)\n    - Где \\(A\\) и \\(B\\) — нетерминалы, \\(a\\) — терминальный символ.\n\n*Основные отличия:\n\n1. **Выразительная сила:\n   — CS-грамматики способны описывать более сложные языки с помощью рекурсии и вложенности.\n   - Регулярные грамматики ограничиваются описанием простых последовательностей без рекурсивных структур.\n\n2. Виды правил производства:\n   - В грамматиках CS в левой части правила всегда есть нетерминал, а справа может быть любая строка терминалов и нетерминалов.\n   - В обычных грамматиках правая часть правила ограничена одним терминалом, за которым может следовать нетерминал (для правосторонних грамматик) или нетерминал, предшествующий терминалу (для грамматик LEFT).\n\n3. Соответствующие машины:\n   - Языки CS распознаются автоматами памяти, имеющими стек для учета вложенных структур.\n   — Обычные языки распознаются конечными автоматами без дополнительной памяти.\n\n4. Закрытие операций:\n   — Обычные языки закрыты при объединении, конкатенации, замыкании Клини, пересечении и дополнении.\n   — Языки KS закрыты при объединении, конкатенации и замыкании Клини, но не закрыты при пересечении и дополнении."
    },
    {
        "question": "Что такое сильная и слабая бисимуляция?",
        "answer": "____\n\nСильная бисимуляция\nПусть есть два конечных автомата или системы с переходами, A и B, со множествами состояний S_A и S_B соответственно. Сильная бисимуляция — это отношение R⊆S_A×S_B, которое выполняется, если для любой пары состояний (s_A, s_B)∈R:\n1. Если в A из состояния s_A​ есть переход по метке α в состояние s_A'​, то в B из состояния s_B​ тоже должен быть переход по α в состояние s_B'​, и (s_A', s_B')∈R.\n2. Аналогично, если в B из состояния s_B​ есть переход по α, то в A из состояния s_A также должен быть переход по α, и эти состояния снова должны быть в отношении R.\n\nСлабая бисимуляция\n\nПусть снова есть два конечных автомата или системы с переходами, A и B, со множествами состояний S_A​ и S_B​. Слабая бисимуляция — это отношение R⊆S_A×S_B, где:\n1. Если в A из состояния s_A есть последовательность переходов, включая нулевое или более количество τ-переходов, по метке α в состояние s_A'​, то в B также должна быть последовательность переходов, включая нулевое или более количество τ-переходов, по метке α в состояние s_B', и (s_A', s_B')∈R.\n2. Аналогично, если в B из состояния s_B​ есть последовательность переходов по метке α в состояние s_B'​, то в A должна быть соответствующая последовательность переходов."
    },
    {
        "question": "Что такое сильная и слабая бисимуляция?",
        "answer": "____\n\nСильная бисимуляция\nПусть есть два конечных автомата или системы переходов, A и B, с множествами состояний S_A и S_B соответственно. Сильная бисимуляция — это отношение R⊆S_A×S_B, которое выполняется, если для любой пары состояний (s_A, s_B)∈R:\n1. Если в A есть переход из состояния s_A​ по метке α в состояние s_A'​, то в B также должен быть переход из состояния s_B​ по метке α в состояние s_B'​, и (s_A', s_B')∈R.\n2. Аналогично, если в B есть переход по α из состояния s_B, то в A также должен быть переход по α из состояния s_A, и эти состояния должны снова находиться в отношении R.\n\nСлабая бисимуляция\n\nПусть снова есть два конечных автомата или системы с переходами, A и B, с множествами состояний S_A и S_B. Слабая бисимуляция — это отношение R⊆S_A×S_B, где:\n1. Если в A есть последовательность переходов из состояния s_A, включающая ноль или более τ-переходов, по метке α в состояние s_A', то в B также должна быть последовательность переходов, включающая ноль или более τ-переходов, по метке α в состояние s_B', и (s_A', s_B')∈R.\n2. Аналогично, если в B есть последовательность переходов из состояния s_B​ по метке α в состояние s_B'​, то в A должна быть соответствующая последовательность переходов."
    },
    {
        "question": "Что такое сильная и слабая бисимуляция?",
        "answer": "____\n\nСильная бисимуляция\nРассмотрим два конечных автомата или системы переходов A и B с наборами состояний S_A и S_B соответственно. Сильная бисимуляция — это отношение R⊆S_A×S_B, которое справедливо, если для любой пары состояний (s_A, s_B)εR:\n1. Если в А имеется переход из состояния s_A​ по метке α в состояние s_A'​, то в B также должен быть переход из состояния s_B​ по метке α в состояние s_B'​, и (s_A', s_B ')€R.\n2. Аналогично, если у B есть переход по α из состояния s_B, то у A также должен быть переход по α из состояния s_A, и эти состояния снова должны быть связаны с R.\n\nНизкая бисимуляция\n\nПредположим еще раз, что существуют два конечных автомата или системы переходов, A и B, с наборами состояний S_A и S_B. Слабая бисимуляция – это отношение R⊆S_A×S_B, где:\n1. Если A имеет последовательность переходов из состояния s_A, включающую ноль или более переходов τ, по метке α в состояние s_A', то B также должна иметь последовательность переходов, включающую ноль или несколько переходов τ, по метке α. для обозначения s_B' и (s_A', s_B')εR.\n2. Аналогично, если B имеет последовательность переходов из состояния s_B по метке α в состояние s_B', то A должен иметь соответствующую последовательность переходов."
    },
    {
        "question": "Что такое сильная и слабая бисимуляция?",
        "answer": "____\n\nСильная бисимуляция\nРассмотрим два конечных автомата или системы переходов A и B с наборами состояний S_A и S_B соответственно. Сильная бисимуляция — это отношение R⊆S_A×S_B, которое справедливо, если для любой пары состояний (s_A, s_B)εR:\n1. Если в А из состояния s_A​ имеется переход по метке α в состояние s_A'​, то в B из состояния s_B​ также должен быть переход по α в сторону состояния s_B'​, и (s_A', s_B')€R.\n2. Аналогично, если в B из состояния s_B есть переход по α, то в A из состояния s_A также должен быть переход по α, и эти состояния должны опять же быть связаны с R.\n\nНизкая бисимуляция\n\nПредположим еще раз, что существуют два конечных автомата или системы переходов, A и B, с наборами состояний S_A​ и S_B​. Слабая бисимуляция – это отношение R⊆S_A×S_B, где:\n1. Если в A существует последовательность переходов из состояния s_A, включающая ноль или более чисел τ-переходов, по метке α в состояние s_A'​, то в B также должна существовать последовательность переходов, включающая ноль или более количество τ-переходов по метке α в состояние s_B' и (s_A', s_B')εR.\n2. Аналогично, если в B существует последовательность переходов из состояния s_B​ по метке α в состояние s_B'​, то и в A должна существовать соответствующая последовательность переходов."
    },
    {
        "question": "Что такое поведенческая эквивалентность? В чем отличие от бисимуляции?",
        "answer": "____\n\nПоведенческая эквивалентность — это понятие, используемое в теории конечных автоматов и систем с переходами для описания того, что два состояния (или две системы) ведут себя одинаково с точки зрения наблюдателя. \nДва состояния считаются поведенчески эквивалентными, если при одинаковых входных данных они переходят в эквивалентные состояния и производят одинаковые выходы.\nПоведенческая эквивалентность — это более общее понятие, чем бисимуляция. В случае поведенческой эквивалентности важно только внешнее поведение, а не структура переходов в системе."
    },
    {
        "question": "Что такое поведенческая эквивалентность? Чем она отличается от бисимуляции?",
        "answer": "____\n\nПоведенческая эквивалентность — это концепция, используемая в теории конечных автоматов и систем переходов для описания того, как два состояния (или системы) ведут себя идентично с точки зрения наблюдателя.\n\nГоворят, что два состояния поведенчески эквивалентны, если при одинаковых входных данных они переходят в эквивалентные состояния и производят одинаковые выходные данные.\nПоведенческая эквивалентность — это более общая концепция, чем бисимуляция. В случае поведенческой эквивалентности важно только внешнее поведение, а не структура переходов в системе."
    },
    {
        "question": "Что такое поведенческая эквивалентность? Чем это отличается от бисимуляции?",
        "answer": "____\n\nПоведенческая эквивалентность — это концепция, используемая в теории конечных автоматов и систем переходов для описания того, как два состояния (или системы) ведут себя одинаково с точки зрения наблюдателя.\n\nДва состояния называются поведенчески эквивалентными, если при одних и тех же входных данных они переходят в эквивалентные состояния и производят одинаковые выходные данные.\nПоведенческая эквивалентность — более общее понятие, чем бисимуляция. В случае поведенческой эквивалентности важно только внешнее поведение, а не структура переходов в системе."
    },
    {
        "question": "Что такое поведенческая эквивалентность? В чем разница с бисимуляцией?",
        "answer": "____\n\nПоведенческая эквивалентность — это концепция, используемая в теории конечных автоматов и систем переходов для описания того факта, что два состояния (или две системы) ведут себя одинаково с точки зрения наблюдателя. \nДва состояния считаются поведенчески эквивалентными, если при одних и тех же входных данных они переходят в эквивалентные состояния и дают одинаковые результаты.\nПоведенческая эквивалентность — более общее понятие, чем бисимуляция. В случае поведенческой эквивалентности важно только внешнее поведение, а не структура переходов в системе."
    },
    {
        "question": "Что такое обратная бисимуляция?",
        "answer": "____\n\nОбратная бисимуляция — это разновидность отношения бисимуляции, которая используется для сравнения поведения состояний в системах с переходами, таких как конечные автоматы. \nВ классической бисимуляции сравниваются шаги из одного состояния в другое (переходы), но в обратной бисимуляции мы смотрим на предыдущие шаги, то есть как состояния \"возвращаются\" к предыдущим состояниям через обратные переходы."
    },
    {
        "question": "Что такое обратная бисимуляция?",
        "answer": "____\n\nОбратная бисимуляция — это разновидность отношения бисимуляции, которая используется для сравнения поведения состояний в системах с переходами, таких как конечные автоматы.\n\nВ классической бисимуляции мы сравниваем шаги из одного состояния в другое (переходы), но в обратной бисимуляции мы смотрим на предыдущие шаги, т. е. как состояния «возвращаются» в предыдущие состояния посредством обратных переходов."
    },
    {
        "question": "Что такое обратная бисимуляция?",
        "answer": "____\n\nОбратная бисимуляция — это тип отношения бисимуляции, используемый для сравнения поведения состояний в переходных системах, таких как конечные автоматы.\n\nВ классической бисимуляции мы сравниваем шаги от одного состояния к другому (переходы), но в инверсной бисимуляции мы смотрим на предыдущие шаги, т.е. как состояния «возвращаются» в предыдущие состояния через обратные переходы."
    },
    {
        "question": "Что такое обратная бисимуляция?",
        "answer": "____\n\nОбратная бисимуляция — это тип отношения бисимуляции, используемый для сравнения поведения состояний в переходных системах, таких как конечные автоматы. \nВ классической бисимуляции мы сравниваем шаги от одного состояния к другому (переходы), но в обратной бисимуляции мы смотрим на предыдущие шаги, т.е. как состояния «возвращаются» в предыдущие состояния через обратные переходы."
    },
    {
        "question": "Напиши доказательство теоремы Бржозовского?",
        "answer": "____\n\nУтверждение 1.\nАвтомат является детерминированным тогда и только тогда, когда левые языки его состояний попарно не пересекаются.\nУтверждение 2.\nЕсли A распознает язык L, то r(A) распознает r(L).\nУтверждение 3.\nЕсли левый язык состояния q в A — L_g(q), тогда его левый язык в r(A) — L_d(q). Аналогично для правого языка q.\nУтверждение 4.\nПравый язык состояния q′d(A) эквивалентен объединению правых языков состояний q автомата A, принадлежащих множеству q′.\nУтверждение 5.\nДетерминированный автомат минимален тогда и только тогда, когда правые языки его состояний различны и все состояния достижимы.\n\nПо построению автомат drdr(A) детерминированный. Согласно утверждению 2, он распознает язык L.\nПокажем, что все правые языки drdr(A) различны. Из утверждения 1, левые языки dr(A) попарно не пересекаются. Из утверждения 3, правые языки rdr(A) являются левыми языками dr(A). Таким образом, они попарно не пересекаются. Согласно утверждению 4, правый язык drdr(A) — объединение правых языков rdr(A). Поскольку правые языки rdr(A) попарно не пересекаются, все правые языки drdr(A) различны.\nТак как все правые языки drdr(A) различны, согласно утверждению 5 автомат drdr(A) минимальный."
    },
    {
        "question": "Написать доказательство теоремы Бжозовского?",
        "answer": "____\n\nПредложение 1.\nАвтомат детерминирован тогда и только тогда, когда левые языки его состояний попарно не пересекаются.\nПредложение 2.\nЕсли A распознает язык L, то r(A) распознает r(L).\nПредложение 3.\nЕсли левый язык состояния q в A — это L_g(q), то его левый язык в r(A) — это L_d(q). Аналогично для правого языка q.\nПредложение 4.\nПравый язык состояния q′d(A) эквивалентен объединению правых языков состояний q автомата A, принадлежащих множеству q′.\nПредложение 5.\nДетерминированный автомат минимален тогда и только тогда, когда правые языки его состояний различны и все состояния достижимы.\n\nПо построению автомат drdr(A) детерминирован. По предложению 2 он распознает язык L.\nПокажем, что все правые языки drdr(A) различны. По предложению 1 левые языки dr(A) попарно не пересекаются. По предложению 3 правые языки rdr(A) являются левыми языками rdr(A). Таким образом, они попарно не пересекаются. По предложению 4 правый язык drdr(A) является объединением правых языков rdr(A). Поскольку правые языки rdr(A) попарно не пересекаются, все правые языки rdr(A) различны.\nПоскольку все правые языки rdr(A) различны, по предложению 5 автомат drdr(A) минимален."
    },
    {
        "question": "Напишите доказательство теоремы Бжозовского?",
        "answer": "____\n\nПредложение 1.\nАвтомат детерминирован тогда и только тогда, когда левые языки его состояний не пересекаются по два.\nПредложение 2.\nЕсли A распознает язык L, то r(A) распознает r(L).\nПредложение 3.\nЕсли левый язык состояния q в A — это L_g(q), то его левый язык в состоянии r(A) — это L_d(q). То же самое касается хорошего языка q.\nПредложение 4.\nХороший государственный язык q'd(A) эквивалентен объединению хороших государственных языков q автомата A, принадлежащих множеству q'.\nПредложение 5.\nДетерминированный автомат минимален тогда и только тогда, когда хорошие языки его состояний различны и все состояния достижимы.\n\nПо построению автомат drdr(A) является детерминированным. По предложению 2 он распознает язык L.\nПокажем, что все хорошие языки drdr(A) различны. По предложению 1 левые языки dr(A) не пересекаются попарно. По предложению 3 языки справа rdr(A) являются языками слева rdr(A). Таким образом, они не пересекаются парами. Согласно предложению 4, хороший язык rdr(A) представляет собой объединение хороших языков rdr(A). Поскольку хорошие языки rdr(A) попарно непересекающиеся, все хорошие языки rdr(A) различны.\nПоскольку все хорошие языки rdr(A) различны, по предложению 5 автомат drdr(A) минимален."
    },
    {
        "question": "Напишите доказательство теоремы Бзозовского?",
        "answer": "____\n\nУтверждение 1.\nАвтомат детерминирован тогда и только тогда, когда левые языки его состояний не пересекаются по два.\nУтверждение 2.\nЕсли A распознает язык L, то r(A) распознает r(L).\nДекларация 3.\nЕсли левый язык состояния q в A — это L_g(q), то его левый язык в состоянии r(A) — это L_d(q). То же самое касается хорошего языка q.\nУтверждение 4.\nХороший государственный язык q'd(A) эквивалентен объединению хороших государственных языков q автомата A, принадлежащих множеству q'.\nДекларация 5.\nДетерминированный автомат минимален тогда и только тогда, когда хорошие языки его состояний различны и все состояния достижимы.\n\nПо построению автомат drdr(A) является детерминированным. Согласно утверждению 2, он распознает язык L.\nПокажем, что все хорошие языки drdr(A) различны. Согласно утверждению 1, языки слева dr(A) попарно не пересекаются. Согласно утверждению 3, языки справа rdr(A) — это языки слева dr(A). Таким образом, они не пересекаются парами. Согласно предложению 4, хороший язык rdr(A) представляет собой объединение хороших языков rdr(A). Поскольку хорошие языки rdr(A) попарно не пересекаются, все хорошие языки rdr(A) различны.\nПоскольку все хорошие языки drdr(A) различны, согласно предложению 5 автомат drdr(A) минимален."
    },
    {
        "question": "Опиши алгоритм Ахо-Корасика.",
        "answer": "____\n\nАлгоритм Ахо-Корасика\nОписание:\nАлгоритм Ахо-Корасика используется для поиска нескольких строк в тексте одновременно. \nОн строит автомат, который позволяет эффективно находить все вхождения заданных подстрок (шаблонов) в строке текста за время, пропорциональное длине текста и общему числу символов в шаблонах.\nЭтот алгоритм сочетает в себе элементы автоматного и префиксного дерева (Trie).\nОсновные этапы:\n1. Построение префиксного дерева (Trie): Сначала создается префиксное дерево для всех шаблонов. Каждый узел дерева представляет символ, а путь от корня до узла соответствует префиксу одного из шаблонов.\n2. Добавление переходов: На каждом уровне префиксного дерева добавляются переходы для символов, которые не соответствуют существующим путям, с использованием \"состояний неудачи\", чтобы указать, куда переходить в случае неудачи.\n3. Построение состояний неудачи: Каждому состоянию (узлу) присваивается состояние неудачи, указывающее, на какой узел следует переходить, если соответствующий символ не найден. Это позволяет обрабатывать текст более эффективно, избегая повторных проверок.\n4. Поиск: Текст обрабатывается одним проходом. При чтении каждого символа проверяются возможные переходы в автомате, и при нахождении конца шаблона фиксируется соответствующее вхождение."
    },
    {
        "question": "Опишите алгоритм Ахо-Корасика.",
        "answer": "____\n\nАлгоритм Ахо-Корасика\nОписание:\nАлгоритм Ахо-Корасика используется для поиска нескольких строк в тексте одновременно.\n\nОн создает автомат, который может эффективно находить все вхождения заданных подстрок (шаблонов) в текстовой строке за время, пропорциональное длине текста и общему количеству символов в шаблонах.\nЭтот алгоритм объединяет элементы автомата и префиксного дерева (Trie).\nОсновные шаги:\n1. Создание префиксного дерева (Trie): Сначала строится префиксное дерево для всех шаблонов. Каждый узел в дереве представляет символ, а путь от корня до узла соответствует префиксу одного из шаблонов.\n2. Добавление переходов: На каждом уровне префиксного дерева добавляются переходы для символов, которые не соответствуют существующим путям, с использованием «состояний отказа» для указания, куда идти в случае отказа.\n3. Построение состояний отказа: Каждому состоянию (узлу) назначается состояние отказа, указывающее, к какому узлу перейти, если соответствующий символ не найден. Это позволяет обрабатывать текст более эффективно, избегая повторных проверок. 4. Поиск: Текст обрабатывается за один проход. При чтении каждого символа проверяются возможные переходы в автомате, и при нахождении конца шаблона фиксируется соответствующее вхождение."
    },
    {
        "question": "Опишите алгоритм Ахо-Корасика.",
        "answer": "____\n\nАлгоритм Ахо-Корасика\nОписание:\nАлгоритм Ахо-Корасика используется для одновременного поиска в нескольких строках текста.\n\nОн создает автомат, который может эффективно находить все вхождения заданных подстрок (шаблонов) в текстовую строку за время, пропорциональное длине текста и общему количеству символов в шаблонах.\nЭтот алгоритм сочетает в себе элементы автомата и префиксного дерева (Trie).\nОсновные шаги:\n1. Создание дерева префиксов (Trie). Сначала для всех моделей строится дерево префиксов. Каждый узел в дереве представляет символ, а путь от корня до узла соответствует префиксу одного из шаблонов.\n2. Добавление переходов. На каждом уровне дерева префиксов добавляются переходы для символов, которые не соответствуют существующим путям, с использованием «состояний сбоя», чтобы указать, куда идти в случае сбоя.\n3. Построить состояния отказа. Каждому состоянию (узлу) присваивается состояние отказа, указывающее, к какому узлу следует перейти, если соответствующий символ не найден. Это позволяет более эффективно обрабатывать текст, избегая повторных проверок. 4. Поиск: текст обрабатывается за один проход. По мере считывания каждого символа проверяются возможные переходы в машине, и когда конец шаблона найден, соответствующее вхождение записывается."
    },
    {
        "question": "Опишите алгоритм Ахо-Корасика.",
        "answer": "____\n\nАлгоритм Ахо-Корасика\nОписание:\nАлгоритм Ахо-Корасика используется для одновременного поиска в нескольких строках текста. \nОн строит автомат, позволяющий эффективно находить все вхождения заданных подстрок (шаблонов) в строку текста за время, пропорциональное длине текста и общему количеству символов в шаблонах.\nЭтот алгоритм сочетает в себе элементы автомата и префиксного дерева (Trie).\nОсновные шаги:\n1. Постройте дерево префиксов (Trie). Сначала для всех моделей создается дерево префиксов. Каждый узел в дереве представляет символ, а путь от корня до узла соответствует префиксу одного из шаблонов.\n2. Добавление переходов. На каждом уровне дерева префиксов добавляются переходы для символов, которые не соответствуют существующим путям, с использованием «состояний сбоя», чтобы указать, куда идти в случае сбоя.\n3. Построить состояния отказа. Каждому состоянию (узлу) присваивается состояние отказа, указывающее, к какому узлу следует перейти, если соответствующий символ не найден. Это позволяет более эффективно обрабатывать текст, избегая повторных проверок.\n4. Поиск: текст обрабатывается за один проход. По мере считывания каждого символа проверяются возможные переходы в машине, и когда конец шаблона найден, соответствующее вхождение записывается."
    },
    {
        "question": "Опиши алгоритм Барроуза-Уилера.",
        "answer": "____\n\nАлгоритм, используемый для предварительной обработки данных перед сжатием, разработанный для улучшения эффективности последующего кодирования. \nПреобразование Барроуза — Уилера меняет порядок символов во входной строке таким образом, что повторяющиеся подстроки образуют на выходе идущие подряд последовательности одинаковых символов.\nОписание алгоритма\nПреобразование выполняется в три этапа:\n1. Составляется таблица всех циклических сдвигов входной строки.\n2. Производится лексикографическая (в алфавитном порядке) сортировка строк таблицы.\n3. В качестве выходной строки выбирается последний столбец таблицы преобразования и номер строки, совпадающей с исходной."
    },
    {
        "question": "Опишите алгоритм Барроуза-Уиллера.",
        "answer": "____\n\nАлгоритм, используемый для предварительной обработки данных перед сжатием, призванный повысить эффективность последующего кодирования.\n\nПреобразование Барроуза-Уиллера изменяет порядок символов во входной строке таким образом, чтобы повторяющиеся подстроки образовывали на выходе последовательные последовательности одинаковых символов.\nОписание алгоритма\nПреобразование выполняется в три этапа:\n1. Составляется таблица всех циклических сдвигов входной строки.\n2. Строки таблицы сортируются лексикографически (по алфавиту).\n3. В качестве выходной строки выбирается последний столбец таблицы преобразования и номер строки, соответствующей исходной."
    },
    {
        "question": "Опишите алгоритм Берроуза-Уиллера.",
        "answer": "____\n\nАлгоритм, используемый для предварительной обработки данных перед сжатием для повышения эффективности последующего кодирования.\n\nПреобразование Берроуза-Уилера изменяет порядок символов во входной строке так, что повторяющиеся подстроки создают последовательные последовательности идентичных символов на выходе.\nОписание алгоритма\nПреобразование осуществляется в три этапа:\n1. Составляется таблица всех циклических смещений входной строки.\n2. Строки таблицы сортируются лексикографически (в алфавитном порядке).\n3. В качестве выходной строки выбирается последний столбец таблицы преобразования и номер строки, соответствующий исходному."
    },
    {
        "question": "Опишите алгоритм Берроуза-Уиллера.",
        "answer": "____\n\nАлгоритм предварительной обработки данных перед сжатием, предназначенный для повышения эффективности последующего кодирования. \nПреобразование Берроуза-Уилера изменяет порядок символов во входной строке так, что повторяющиеся подстроки образуют последовательные последовательности идентичных символов на выходе.\nОписание алгоритма\nПреобразование осуществляется в три этапа:\n1. Составляется таблица всех циклических смещений входной строки.\n2. Строки таблицы сортируются лексикографически (в алфавитном порядке).\n3. В качестве выходной строки выбирается последний столбец таблицы преобразования и номер строки, соответствующий исходному."
    },
    {
        "question": "Напишите лемму о разрастании для КС-грамматик.",
        "answer": "____\n\nПусть L — контекстно-свободный язык над алфавитом Σ, тогда существует такое n, что для любого слова ω∈L длины не меньше n найдутся слова u,v,x,y,z∈Σ∗, для которых верно: uvxyz=ω,vy≠ε,|vxy|⩽n и ∀k⩾0 uv_kxy_kz∈L."
    },
    {
        "question": "Напишите лемму о расширении грамматик CF.",
        "answer": "____\n\nПусть L — контекстно-свободный язык над алфавитом Σ, тогда существует n такое, что для любого слова ω∈L длины не менее n существуют слова u,v,x,y,z∈Σ∗, для которых uvxyz=ω,vy≠ε,|vxy|⩽n и ∀k⩾0 uv_kxy_kz∈L."
    },
    {
        "question": "Напишите лемму о расширении CF-грамматик.",
        "answer": "____\n\nПусть L — контекстно-свободный язык алфавита Σ, тогда существует n такое, что для каждого слова ωεL длины не менее n существуют слова u,v,x,y,zاΣ∗, для которых uvxyz=ω ,vy≠ ε,|vxy|⩽n и ∀k⩾0 uv_kxy_kzاL."
    },
    {
        "question": "Напишите лемму о разложении грамматик КС.",
        "answer": "____\n\nПусть L — контекстно-свободный язык алфавита Σ, тогда существует n такое, что для каждого слова ωεL длины не менее n существуют слова u,v,x,y,zεΣ∗, для которых верно : uvxyz=ω, vy≠ε,|vxy|⩽n и ∀k⩾0 uv_kxy_kzاL."
    },
    {
        "question": "Опиши способы получения минимальных автоматов.",
        "answer": "____\n\nТаблица переходов\n\nЕсли заданы таблица переходов и эквивалентное разбиение Σ1..Σň автомата S, то таблица переходов Š может быть построена следующим образом:\n1. Заменить обозначение каждого состояния, имеющегося в таблице S на обозначение класса, которому данное состояние принадлежит.\n2. Из каждой группы строк с одинаковыми обозначениями в клетках основного столбца вычеркнуть все строки, кроме одной.\nПолученная при этом таблица является таблицей переходов Š.\n\nГраф переходов\n\nЕсли заданы граф переходов (диаграмма состояний) и эквивалентное разбиение Σ1..Σň автомата S, то граф переходов Š может быть построен следующим образом:\n1. Заменить обозначение каждого состояния, имеющегося в графе переходов S на обозначение класса, к которому относится данное состояние.\n2. Объединить все одинаково обозначенные состояния (рассматривая дуги графа как «гибкие связи») и представить объединенные состояния одним состоянием, имеющим общее обозначение.\n3. Из каждой группы дуг, имеющих общее исходное и общее конечное состояние вычеркнуть все, кроме одной.\nПолученный в результате граф будет графом Š.\n\nМатрица переходов\n\nЕсли заданы матрица переходов и эквивалентное разбиение Σ1..Σň автомата S, то матрица переходов Š может быть построена следующим образом:\n1. Провести симметрическую перестановку и симметрическое разбиение [S] так, чтобы строки (и столбцы) группировались соответственно классам эквивалентности S (эту же матрицу можно получить при матричном методе эквивалентного разбиения).\n2. Заменить все обозначения строк (и столбцов) каждой группы, представляющей класс эквивалентности, одним обозначением этого класса.\n3. Заменить каждую подматрицу в разбитой матрице одной клеткой, содержащей все пары вход-выход, которые имеются в любой строке этой подматрицы (все строки в любой такой подматрице содержат одно и то же множество пар вход-выход).\nПолученная в результате матрица является матрицей переходов Š."
    },
    {
        "question": "Опишите методы получения минимального количества машин.",
        "answer": "____\n\nТаблица переходов\n\nЕсли даны таблица переходов и эквивалентное разбиение Σ1..Σň автомата S, то таблицу переходов Š можно построить следующим образом:\n1. Заменить обозначение каждого состояния в таблице S на обозначение класса, к которому принадлежит это состояние.\n2. Из каждой группы строк с одинаковыми обозначениями в ячейках основного столбца вычеркнуть все строки, кроме одной.\n\nПолученная таблица — таблица переходов Š.\n\nГраф переходов\n\nЕсли даны граф переходов (диаграмма состояний) и эквивалентное разбиение Σ1..Σň автомата S, то граф переходов Š можно построить следующим образом:\n1. Заменить обозначение каждого состояния в графе переходов S на обозначение класса, к которому принадлежит это состояние.\n2. Объединить все состояния с одинаковым обозначением (рассматривая дуги графа как «гибкие связи») и представить объединенные состояния как единое состояние с общим обозначением.\n3. Из каждой группы дуг с общим начальным и общим конечным состоянием удалить все, кроме одной.\nРезультирующим графом будет граф Š.\n\nМатрица перехода\n\nЕсли даны матрица перехода и эквивалентное разбиение Σ1..Σň автомата S, то матрицу перехода Š можно построить следующим образом:\n1. Выполнить симметричную перестановку и симметричное разбиение [S] так, чтобы строки (и столбцы) были сгруппированы в соответствии с классами эквивалентности S (такую ​​же матрицу можно получить с помощью матричного метода эквивалентного разбиения).\n2. Заменить все обозначения строк (и столбцов) каждой группы, представляющей класс эквивалентности, на одно обозначение этого класса.\n3. Заменить каждую подматрицу в разделенной матрице одной ячейкой, содержащей все пары вход-выход, которые присутствуют в любой строке этой подматрицы (все строки в любой такой подматрице содержат один и тот же набор пар вход-выход).\nПолученная матрица является матрицей перехода Š."
    },
    {
        "question": "Описать способы получения минимального количества автомобилей.",
        "answer": "____\n\nТаблица перехода\n\nЕсли даны таблица переходов и эквивалентное ей разбиение Σ1..Σň автомата S, то таблицу переходов Š можно построить следующим образом:\n1. Заменить обозначение каждого состояния в таблице S на обозначение класса, к которому относится это состояние.\n2. В каждой группе строк с одинаковыми обозначениями в ячейках основного столбца вычеркните все строки, кроме одной.\n\nПолученная таблица является таблицей переходов Š.\n\nСхема перехода\n\nЕсли заданы граф переходов (диаграмма состояний) и эквивалентное разбиение Σ1..Σň автомата S, то граф переходов Š можно построить следующим образом:\n1. Заменить обозначение каждого состояния в графе переходов S на обозначение класса, к которому принадлежит это состояние.\n2. Объединить все состояния с одинаковым обозначением (рассматривая графические дуги как «гибкие связи») и представить объединенные состояния как единое состояние с общим обозначением.\n3. Из каждой группы ребер, имеющих общее начальное и общее конечное состояние, удалите все, кроме одного.\nПолученный график будет графиком Š.\n\nМатрица перехода\n\nЕсли заданы матрица перехода и эквивалентное ей разбиение Σ1..Σň автомата S, то матрицу перехода Š можно построить следующим образом:\n1. Выполнить симметричную перестановку и симметричное разбиение [S] так, чтобы строки (и столбцы) были сгруппированы в соответствии с классами эквивалентности S (та же матрица может быть получена с использованием метода матричного эквивалентного разделения).\n2. Замените все обозначения строк (и столбцов) в каждой группе, представляющей класс эквивалентности, на обозначения этого класса.\n3. Заменить каждую подматрицу разбитой матрицы на одну ячейку, содержащую все пары ввода-вывода, присутствующие в любой строке этой подматрицы (все строки такой подматрицы содержат одинаковый набор пар ввода-вывода).\nПолученная матрица является матрицей перехода Š."
    },
    {
        "question": "Описать методы получения минимальных автоматов.",
        "answer": "____\n\nТаблица перехода\n\nЕсли заданы таблица переходов и эквивалентное ей разбиение Σ1..Σň автомата S, то таблицу переходов Š можно построить следующим образом:\n1. Заменить обозначение каждого состояния в таблице S на обозначение класса, к которому относится это состояние.\n2. Из каждой группы строк с одинаковыми обозначениями в ячейках основного столбца вычеркните все, кроме одной строки.\nПолученная таблица является таблицей переходов Š.\n\nСхема перехода\n\nЕсли заданы граф переходов (диаграмма состояний) и эквивалентное разбиение Σ1..Σň автомата S, то граф переходов Š можно построить следующим образом:\n1. Заменить обозначение каждого состояния, присутствующего в графе переходов S, на обозначение класса, к которому принадлежит это состояние.\n2. Объединить все одинаково обозначенные состояния (рассматривая графические дуги как «гибкие связи») и представить объединенные состояния как единое состояние с общим обозначением.\n3. В каждой группе дуг, имеющих общее начальное состояние и общее конечное состояние, вычеркните все, кроме одной.\nПолученный график будет графиком Š.\n\nМатрица перехода\n\nЕсли заданы матрица перехода и эквивалентное ей разбиение Σ1..Σň автомата S, то матрицу перехода Š можно построить следующим образом:\n1. Выполнить симметричную перестановку и симметричное разбиение [S] так, чтобы строки (и столбцы) были сгруппированы по классам эквивалентности S (та же матрица может быть получена методом матричного эквивалентного разбиения).\n2. Заменить все обозначения строк (и столбцов) в каждой группе, представляющей класс эквивалентности, одним обозначением этого класса.\n3. Заменить каждую подматрицу разделенной матрицы одной ячейкой, содержащей все пары ввода-вывода, присутствующие в любой строке этой подматрицы (все строки такой подматрицы содержат одинаковый набор пар ввода-вывода).\nПолученная матрица является матрицей перехода Š."
    },
    {
        "question": "Напиши свойства минимального автомата.",
        "answer": "____\n\nЕсли Š является минимальной формой автомата S, то:\n1. Š является единственной минимальной формой с точностью до обозначения состояний\n2. Š=S\n3. Никакие два состояния Š не являются эквивалентными\n4. Не существует автомата, эквивалентного S и меньшего (с меньшим числом состояний), чем Š."
    },
    {
        "question": "Напишите свойства минимального автомата.",
        "answer": "____\n\nЕсли Š — минимальная форма автомата S, то:\n1. Š — единственная минимальная форма с точностью до обозначения состояний\n2. Š=S\n3. Никакие два состояния Š не эквивалентны\n4. Не существует автомата, эквивалентного S и меньшего (с меньшим количеством состояний), чем Š."
    },
    {
        "question": "Напишите свойства минимального автомата.",
        "answer": "____\n\nЕсли Š — минимальная форма автомата S, то:\n1. Š — единственная минимальная форма до обозначения состояний.\n2. Ш=С\n3. Никакие два государства не эквивалентны\n4. Не существует автомата, эквивалентного S и меньшего (с меньшим количеством состояний), чем Š."
    },
    {
        "question": "Напишите свойства минимального автомата.",
        "answer": "____\n\nЕсли Š — минимальная форма автомата S, то:\n1. Š — единственная минимальная форма до обозначения состояния.\n2. Ш=С\n3. Не существует двух эквивалентных состояний Š.\n4. Не существует автомата, эквивалентного S и меньшего (с меньшим количеством состояний), чем Š."
    },
    {
        "question": "Напиши определение правоконтекстной грамматики.",
        "answer": "____\n\nПравоконтекстная грамматика — это тип грамматики в теории формальных языков, где правила переписывания зависят от контекста символов, стоящих справа от переписываемого нетерминала. \nТакие грамматики формализуются следующим образом:\nПравило грамматики имеет вид: αAβ→αγβ, где A — это нетерминальный символ, α и β — строки из терминалов и нетерминалов, а γ — строка, которая заменяет A. \nВажно, что заменяемый символ A может быть переписан только в случае, если справа от него стоит строка β, что и придает контекстность правилам."
    },
    {
        "question": "Напишите определение грамматики правого контекста.",
        "answer": "____\n\nПравоконтентная грамматика — это тип грамматики в формальной теории языка, где правила переписывания зависят от контекста символов справа от переписываемого нетерминала.\n\nТакие грамматики формализуются следующим образом:\nПравило грамматики имеет вид: αAβ→αγβ, где A — нетерминальный символ, α и β — строки терминалов и нетерминалов, а γ — строка, которая заменяет A.\n\nВажно, что заменяемый символ A может быть переписан только в том случае, если справа от него есть строка β, которая дает контекст правилам."
    },
    {
        "question": "Напишите определение правильной контекстной грамматики.",
        "answer": "____\n\nГрамматика с правым содержанием — это тип грамматики в теории формального языка, где правила перезаписи зависят от контекста символов справа от переписываемого нетерминала.\n\nТакие грамматики формализуются следующим образом:\nГрамматическое правило: αAβ→αγβ, где A — нетерминальный символ, α и β — терминальные и нетерминальные строки, а γ — строка, заменяющая A.\n\nВажно отметить, что замененный символ A можно переписать только в том случае, если справа от него есть строка β, которая дает контекст правилам."
    },
    {
        "question": "Напишите определение правильной контекстной грамматики.",
        "answer": "____\n\nГрамматика правого контекста — это тип грамматики в теории формального языка, где правила перезаписи зависят от контекста символов справа от переписываемого нетерминала. \nТакие грамматики формализуются следующим образом:\nГрамматическое правило: αAβ→αγβ, где A — нетерминальный символ, α и β — строки терминалов и нетерминалов, а γ — строка, заменяющая A. \nВажно отметить, что замененный символ A можно переписать только в том случае, если справа от него есть строка β, которая дает контекст правилам."
    },
    {
        "question": "Опиши алгоритм Кока-Янгера-Касами.",
        "answer": "____\n\nАлгоритм Кока-Янгера-Касами — алгоритм, позволяющий по слову узнать, выводимо ли оно в заданной КС-грамматике в нормальной форме Хомского. Любую КС-грамматику можно привести к НФХ, поэтому алгоритм является универсальным для любой КС-грамматики.\nШаги алгоритма:\n1. Инициализация таблицы:\n\nПусть строка w имеет длину n. Создаём двумерную таблицу T размером n×n, где T[i,j] будет содержать множество нетерминалов, которые могут породить подстроку строки w, начиная с позиции i и имеющую длину j.\n\n2. Заполнение таблицы для подстрок длины 1:\n\nДля каждой подстроки длиной 1 (каждого символа строки), если есть правило вида A→a, где a — символ подстроки, то заполняем соответствующую ячейку таблицы T[i,1] нетерминалом A. Это инициализирует таблицу, заполняя её для самых маленьких подстрок (индивидуальных символов).\n\n3. Заполнение таблицы для подстрок большей длины:\n\nДля каждого l от 2 до n (длина подстроки), для каждой позиции i (начальная позиция подстроки) и для каждой k от 1 до l−1, проверяем возможные разбиения подстроки на две части.\nЕсли есть правило A→BC в грамматике, и если нетерминал B может породить левую часть подстроки (то есть T[i,k] содержит B), а C может породить правую часть подстроки (то есть T[i+k,l−k] содержит C), то добавляем A в T[i,l].\n\n4. Результат:\n\nЕсли в ячейке T[1,n] (которая соответствует всей строке длины n) содержится стартовый символ грамматики, то строка принадлежит языку. В противном случае строка не может быть порождена грамматикой."
    },
    {
        "question": "Опишите алгоритм Коки-Янгера-Касами.",
        "answer": "____\n\nАлгоритм Кока-Янгера-Касами — это алгоритм, который позволяет узнать, заданное слово, выводимо ли оно в заданном CFG в нормальной форме Хомского. Любой CFG можно свести к NFH, поэтому алгоритм универсален для любого CFG.\nШаги алгоритма:\n1. Инициализация таблицы:\n\nПусть строка w имеет длину n. Создайте двумерную таблицу T размером n×n, где T[i,j] будет содержать набор нетерминалов, которые могут генерировать подстроку строки w, начиная с позиции i и имеющую длину j.\n\n2. Заполнение таблицы для подстрок длины 1:\n\nДля каждой подстроки длины 1 (каждого символа строки), если есть правило вида A→a, где a — символ подстроки, то заполняем соответствующую ячейку таблицы T[i,1] нетерминалом A. Это инициализирует таблицу, заполняя ее для наименьших подстрок (отдельных символов).\n\n3. Заполнение таблицы для подстрок большей длины:\n\nДля каждого l от 2 до n (длина подстроки), для каждой позиции i (начальная позиция подстроки) и для каждого k от 1 до l−1 проверяем возможные разбиения подстроки на две части.\nЕсли в грамматике есть правило A→BC, и если нетерминал B может производить левую часть подстроки (т. е. T[i,k] содержит B), а C может производить правую часть подстроки (т. е. T[i+k,l−k] содержит C), то добавляем A к T[i,l].\n\n4. Результат:\n\nЕсли ячейка T[1,n] (соответствующая всей строке длины n) содержит начальный символ грамматики, то строка принадлежит языку. В противном случае строка не может быть произведена грамматикой."
    },
    {
        "question": "Опишите алгоритм Коки-Янгера-Касами.",
        "answer": "____\n\nАлгоритм Кока-Янгера-Касами — это алгоритм, который определяет, можно ли данное слово напечатать в данной CFG в нормальной форме Хомского. Любой CFG можно свести к NFH, поэтому алгоритм универсален для любого CFG.\nШаги алгоритма:\n1. Инициализация таблицы:\n\nПусть строка w имеет длину n. Создайте двумерный массив T размера n×n, где T[i,j] будет содержать набор нетерминалов, которые могут генерировать подстроку строки w, начиная с позиции i и имеющей длину j.\n\n2. Заполнение таблицы для подстрок длины 1:\n\nДля каждой подстроки длины 1 (каждого символа строки), если существует правило вида A→a, где a – символ подстроки, то заполняем соответствующую ячейку таблицы T[ i,1] с нетерминалом A. Это инициализирует таблицу, заполняя ее наименьшими подстроками (отдельными символами).\n\n3. Заполнение таблицы для подстрок большей длины:\n\nДля каждого l от 2 до n (длина подстроки), для каждой позиции i (начальная позиция подстроки) и для каждого k от 1 до l−1 проверяем возможные разделения подстроки, состоящей из двух частей.\nЕсли в грамматике действует правило A→BC, и нетерминал B может создавать левую часть подстроки (т. е. T[i,k] содержит B), а C может создавать правую часть подстроки (т. е. T[i++ k] ,l−k] содержит C), то мы добавляем A к T[i,l].\n\n4. Результат:\n\nЕсли ячейка T[1,n] (соответствующая всей строке длины n) содержит начальный символ грамматики, то строка принадлежит языку. В противном случае строка не может быть создана грамматикой."
    },
    {
        "question": "Опишите алгоритм Кока-Янгера-Касами.",
        "answer": "____\n\nАлгоритм Кока-Янгера-Касами — это алгоритм, который позволяет нам узнать по слову, выводимо ли оно в данной грамматике KS в нормальной форме Хомского. Любую грамматику КС можно свести к NFC, поэтому алгоритм универсален для любой грамматики КС.\nШаги алгоритма:\n1. Инициализация таблицы:\n\nПусть строка w имеет длину n. Мы создаем двумерный массив T размера n×n, где T[i,j] будет содержать набор нетерминалов, которые могут генерировать подстроку строки w, начинающуюся с позиции i и имеющую длину j.\n\n2. Заполнение таблицы для подстрок длины 1:\n\nДля каждой подстроки длины 1 (каждого символа строки), если существует правило вида A→a, где a – символ подстроки, то заполняем соответствующую ячейку таблицы T[ i,1] с нетерминалом A. Это инициализирует таблицу, заполняя ее наименьшими подстроками (отдельными символами).\n\n3. Заполнение таблицы для подстрок большей длины:\n\nДля каждого l от 2 до n (длина подстроки), для каждой позиции i (начальная позиция подстроки) и для каждого k от 1 до l−1 проверяем возможные разделения подстроки, состоящей из двух частей.\nЕсли в грамматике существует правило A→BC и нетерминал B может создавать левую часть подстроки (т. е. T[i,k] содержит B), а C может создавать правую часть подстроки (т. е. T [i+k,l−k ] содержит C), то мы добавляем A к T[i,l].\n\n4. Результат:\n\nЕсли ячейка T[1,n] (которая соответствует всей строке длины n) содержит начальный символ грамматики, то строка принадлежит языку. В противном случае строка не может быть сгенерирована грамматикой."
    },
    {
        "question": "Напишите определение леммы о разрастании в общем виде.",
        "answer": "____\n\nЕсли язык L является регулярным, то существует число n⩾1 такое что для любого слова uwv из языка L, где |w|⩾n может быть записано в форме uwv=uxyzv, где слова x, y и z такие, что |xy|⩽n, |y|⩾1 и ux(y^i)zv принадлежит языку L для любого целого числа i⩾0."
    },
    {
        "question": "Напишите общее определение леммы о расширении.",
        "answer": "____\n\nЕсли L — регулярный язык, то существует число n⩾1 такое, что для любого слова uwv в L, где |w|⩾n, можно записать в виде uwv=uxyzv, где x, y и z таковы, что |xy|⩽n, |y|⩾1, и ux(y^i)zv принадлежит L для любого целого числа i⩾0."
    },
    {
        "question": "Напишите общее определение леммы о продолжении.",
        "answer": "____\n\nЕсли L — регулярный язык, то существует число n⩾1 такое, что для каждого слова uwv в L, где |w|⩾n, можно записать uwv=uxyzv, где x, y и z таковы, что |xy | ⩽ n, |y|⩾1 и ux(y^i)zv принадлежит L для любого целого числа i⩾0."
    },
    {
        "question": "Напишите определение леммы о росте в общем виде.",
        "answer": "____\n\nЕсли язык L регулярен, то существует число n⩾1 такое, что для каждого слова uwv языка L, где |w|⩾n, можно записать в виде uwv=uzyzv, где слова x, y и z таковы, что |xy| ⩽n, |y|⩾1 и ux(y^i)zv принадлежат языку L для любого целого числа i⩾0."
    },
    {
        "question": "Контекстно-свободная (КС) грамматика это",
        "answer": "____\nКС грамматика - это грамматика, у которой в левых частях всех правил стоят только одиночные нетерминалы.\nЯзык, задаваемый контекстно-свободной грамматикой, называется контекстно-свободным языком.\nКС-грамматика: G = <N, ∑, P, S>, где правила имеют вид: A → β, где β ∈ (N + ∑)*"
    },
    {
        "question": "Контекстно-свободная (CF) грамматика — это",
        "answer": "____\nКонтекстно-свободная грамматика — это грамматика, в которой левые части всех правил содержат только одиночные нетерминалы.\nЯзык, определенный контекстно-свободной грамматикой, называется контекстно-свободным языком.\nКонтекстно-свободная грамматика: G = <N, ∑, P, S>, где правила: A → β, где β ∈ (N + ∑)*"
    },
    {
        "question": "Контекстно-свободная грамматика (CF) – это",
        "answer": "____\nКонтекстно-свободная грамматика — это такая грамматика, в которой левые части всех правил содержат только один нетерминал.\nЯзык, определяемый контекстно-свободной грамматикой, называется контекстно-свободным языком.\nГрамматика вне контекста: G = <N, ∑, P, S>, где правила: A → β, где β ∈ (N + ∑)*"
    },
    {
        "question": "Контекстно-свободная грамматика (CF) – это",
        "answer": "____\nГрамматика KS — это такая грамматика, в которой левые части всех правил содержат только уникальные нетерминалы.\nЯзык, определяемый контекстно-свободной грамматикой, называется контекстно-свободным языком.\nГрамматика КС: G = <N, ∑, P, S>, где правила: A → β, где β ∈ (N + ∑)*"
    },
    {
        "question": "Левосторонний (Левый) вывод в КС грамматике это",
        "answer": "____\nВывод в КС-грамматике левосторонний (левый), если на каждом шаге вывода заменяется самое левое из всех вхождений нетерминальных символов, \nто есть каждый шаг вывода имеет вид: uAθ —> uβθ, где (A → β) ∈ P, A ∈ N и θ ∈ (N U ∑)*, u ∈ ∑*.\nЛевосторонний вывод однозначно восстанавливается по дереву вывода."
    },
    {
        "question": "Левосторонний (левый) вывод в грамматике CS — это",
        "answer": "____\nВыход в CFG является левосторонним (левосторонним), если на каждом шаге вывода заменяется самое левое из всех вхождений нетерминальных символов, \nто есть каждый шаг вывода имеет вид: uAθ —> uβθ, где (A → β) ∈ P, A ∈ N и θ ∈ (N U ∑)*, u ∈ ∑*.\nЛевосторонний выход однозначно восстанавливается из выходного дерева."
    },
    {
        "question": "Левый (левый) вывод в грамматике CS:",
        "answer": "____\nВывод в CFG является левым (левым), если на каждом этапе вывода заменяется самый левый из всех вхождений нетерминальных символов, \nт. е. каждый выходной шаг имеет вид: uAθ -> uβθ, где (A → β) ∈ P, A ∈ N и θ ∈ (N U ∑)*, u ∈ ∑*.\nЛевый вывод однозначно восстанавливается из выходного дерева."
    },
    {
        "question": "Левосторонний (левый) вывод в грамматике KS:",
        "answer": "____\nВывод в грамматике KS является левым (левым), если на каждом шаге заменяется самый левый вывод всех вхождений нетерминальных символов, \nт. е. каждый выходной шаг имеет вид: uAθ -> uβθ, где (A → β) ∈ P, A ∈ N и θ ∈ (N U ∑)*, u ∈ ∑*.\nВыходные данные левой части однозначно восстанавливаются из дерева вывода."
    },
    {
        "question": "Леворекурсивная КС грамматика это",
        "answer": "____\nЛеворекурсивная грамматика - это грамматика, в которой есть нетерминал, который может быть заменен на себя самого в левом направлении, то есть грамматика, имеющая хотя бы один леворекурсивный нетерминал."
    },
    {
        "question": "Леворекурсивная грамматика CS — это",
        "answer": "____\nЛеворекурсивная грамматика — это грамматика, в которой есть нетерминал, который может быть заменен самим собой в левом направлении, то есть грамматика, которая имеет по крайней мере один леворекурсивный нетерминал."
    },
    {
        "question": "Леворекурсивная грамматика CS:",
        "answer": "____\nЛеворекурсивная грамматика — это грамматика, имеющая нетерминал, который можно заменить самой собой в левом направлении, то есть грамматика, имеющая хотя бы один леворекурсивный нетерминал."
    },
    {
        "question": "Леворекурсивная грамматика KS:",
        "answer": "____\nЛеворекурсивная грамматика — это та, в которой существует нетерминал, который можно заменить самим собой в левом направлении, то есть грамматика, имеющая хотя бы один леворекурсивный нетерминал."
    },
    {
        "question": "Праворекурсивная КС грамматика это",
        "answer": "____\nПраворекурсивная грамматика - это грамматика, в которой есть нетерминал, который может быть заменен на себя самого в правом направлении, то есть грамматика, имеющая хотя бы один праворекурсивный нетерминал."
    },
    {
        "question": "Праворекурсивная грамматика CS — это",
        "answer": "____\nПраворекурсивная грамматика — это грамматика, в которой есть нетерминал, который может быть заменен самим собой в правильном направлении, то есть грамматика, в которой есть хотя бы один праворекурсивный нетерминал."
    },
    {
        "question": "Правильная рекурсивная грамматика CS:",
        "answer": "____\nПраворекурсивная грамматика — это грамматика, в которой есть нетерминал, который можно заменить самим собой в правильном направлении, то есть грамматика, в которой есть хотя бы один рекурсивный нетерминал справа."
    },
    {
        "question": "Правильная рекурсивная грамматика KS:",
        "answer": "____\nПраворекурсивная грамматика — это грамматика, в которой есть нетерминал, который можно заменить самим собой в нужном направлении, то есть грамматика, имеющая хотя бы один праворекурсивный нетерминал."
    },
    {
        "question": "Рекурсивная КС грамматика это",
        "answer": "____\nРекурсивная грамматика - это грамматика,  в которой все нетерминалы рекурсивные (кроме, может быть, S)."
    },
    {
        "question": "Рекурсивная грамматика CS — это",
        "answer": "____\nРекурсивная грамматика — это грамматика, в которой все нетерминалы рекурсивны (за исключением, возможно, S)."
    },
    {
        "question": "Рекурсивная грамматика CS",
        "answer": "____\nРекурсивная грамматика — это такая грамматика, в которой все нетерминалы рекурсивны (за исключением, возможно, S)."
    },
    {
        "question": "Рекурсивная грамматика KS",
        "answer": "____\nРекурсивная грамматика — это такая грамматика, в которой все нетерминалы рекурсивны (за исключением, возможно, S)."
    },
    {
        "question": "Бесполезный символ (нетерминал) в КС грамматике это",
        "answer": "____\nСимвол D (нетерминал) - бесполезный, если в грамматике нет вывода вида S → *wDy → *wvy, где v, w, y ∈ ∑*"
    },
    {
        "question": "Бесполезный символ (нетерминал) в грамматике CS — это",
        "answer": "____\nСимвол D (нетерминал) бесполезен, если грамматика не имеет вывода вида S → *wDy → *wvy, где v, w, y ∈ ∑*"
    },
    {
        "question": "Ненужный (нетерминальный) символ в грамматике CS — это",
        "answer": "____\nСимвол D (нетерминальный) бесполезен, если грамматика не имеет вывода в виде S → *wDy → *wvy, где v, w, y ∈ ∑*"
    },
    {
        "question": "Ненужным (нетерминальным) символом в грамматике KS является",
        "answer": "____\nСимвол D (нетерминальный) бесполезен, если грамматика не имеет вывода вида S → *wDy → *wvy, где v, w, y ∈ ∑*"
    },
    {
        "question": "Неукорачивающая КС грамматика это",
        "answer": "____\nНеукорачивающая КС грамматика -  это грамматика, которая может производить бесконечно длинные строки, то есть грамматика без ε-правил. Пример неукорачивающей КС грамматики: S → aSb | a."
    },
    {
        "question": "Неконтрактная грамматика KS — это",
        "answer": "____\nНеконтрактная грамматика CS — это грамматика, которая может производить бесконечно длинные строки, т. е. грамматика без ε-правил. Пример неконтрактной грамматики CS: S → aSb | a."
    },
    {
        "question": "Внедоговорная грамматика KS – это",
        "answer": "____\nНедоговорная грамматика CS — это грамматика, которая может создавать бесконечно длинные строки, то есть грамматика без ε правил. Пример бездоговорной грамматики CS: S → aSb | А."
    },
    {
        "question": "Неусеченная грамматика KS",
        "answer": "____\nCS-грамматика без сокращения — это грамматика, которая может создавать бесконечно длинные строки, то есть грамматика без ε-правил. Пример грамматики CS без сокращения: S → aSb | А."
    },
    {
        "question": "КС грамматика с цепным правилом это",
        "answer": "____\nКС грамматика с цепным правилом - это КС грамматика, в которой есть правило вида A → B, где A, B ∈ N. Имеет правило замены, которое содержит цепочку нетерминалов.\nПример КС грамматики с цепным правилом: \nS → aBb | ε\nB → bB | a"
    },
    {
        "question": "Грамматика KS с цепным правилом",
        "answer": "____\nЦепная грамматика CS — это грамматика CS, которая имеет правило вида A → B, где A, B ∈ N. Она имеет правило подстановки, которое содержит цепочку нетерминалов.\nПример цепной грамматики CS:\nS → aBb | ε\nB → bB | a"
    },
    {
        "question": "Грамматика KS с цепным правилом",
        "answer": "____\nСтроковая грамматика CS — это грамматика CS, имеющая правило вида A → B, где A, B ∈ N. Она имеет правило подстановки, содержащее строку нетерминалов.\nПример строковой грамматики CS:\nS → abBb | ε\nБ → ББ | А"
    },
    {
        "question": "Грамматика KS с правилом цепочки:",
        "answer": "____\nCS-грамматикой с цепным правилом называется CS-грамматика, в которой существует правило вида A → B, где A, B ∈ N. Она имеет правило замены, содержащее цепочку нетерминалов.\nПример грамматики CS с цепным правилом: \nS → abBb | ε\nБ → ББ | А"
    },
    {
        "question": "КС грамматика без циклов",
        "answer": "____\nКС грамматика без циклов - это КС грамматика, в которой нет правила: A → +A. То есть грамматика, которая не содержит циклов (кроме возможных циклов в терминальных символах), то есть, нетерминалы не могут быть заменены на себя самого через любое количество шагов.\nПример КС грамматики без циклов:\nS → aAb | ε\nA → b | c"
    },
    {
        "question": "Грамматика КС без циклов",
        "answer": "____\nГрамматика KS без циклов — это грамматика KS, в которой нет правила: A → +A. То есть грамматика, в которой нет циклов (за исключением возможных циклов в терминальных символах), то есть нетерминалы не могут быть заменены самими собой после любого количества шагов.\nПример грамматики KS без циклов:\nS → aAb | ε\nA → b | c"
    },
    {
        "question": "CS-грамматика без циклов",
        "answer": "____\nГрамматика КС без циклов — это грамматика КС, в которой нет правила: A → +A. То есть грамматика, в которой нет циклов (за исключением возможных циклов в терминальных символах), т.е. нетерминалы не могут быть заменены самими собой после определенного количества шагов.\nПример грамматики KS без циклов:\nS → аАб | ε\nА → б | с"
    },
    {
        "question": "Грамматика КС без циклов",
        "answer": "____\nГрамматика КС без циклов — это грамматика КС, в которой нет правила: A → +A. То есть грамматика, не содержащая циклов (за исключением возможных циклов в терминальных символах), т.е. нетерминалы не могут быть ими заменены - даже через определенное количество шагов.\nПример грамматики CS без циклов:\nS → аАб | ε\nА → б | с"
    },
    {
        "question": "Приведённая КС грамматика это",
        "answer": "____\nПриведённая КС грамматика - это грамматика без циклов, без бесполезных символов и без цепных правил."
    },
    {
        "question": "Грамматика, данная КС, такова:",
        "answer": "____\nГрамматика, данная КС, — это грамматика без циклов, без бесполезных символов и без цепочечных правил."
    },
    {
        "question": "Грамматика, заданная QS, такова:",
        "answer": "____\nГрамматика, данная К.С., представляет собой грамматику без петель, лишних символов и цепных правил."
    },
    {
        "question": "Грамматика, данная KS,",
        "answer": "____\nГрамматика, данная К.С., — это грамматика без циклов, без лишних символов и без цепных правил."
    },
    {
        "question": "Алгоритм удаления бесполезных (непорождающих) символов в КС грамматике",
        "answer": "____\n1. Берём все правила, в правой части которых есть хотя бы один терминал. Берём оттуда\nмножество всех терминалов и нетерминалов слева.\n2. Берём все правила, в правой части которых встречаются нетерминалы только из нашего\nмножества. Добавляем нетерминалы слева в наше множество. Повторяем.\n3. На каком то шаге множество стабилизируется (все выводимые правила будут учтены). В нашем\nмножестве остались терминалы и все небесполезные нетерминалы.\n4. Берём разность всех нетерминалов и нетерминалов из нашего построенного множества. Это\nбудут бесполезные нетерминалы.\n5. Удаляем все правила, в которых встречаются бесполезные нетерминалы"
    },
    {
        "question": "Алгоритм удаления бесполезных (негенерирующих) символов в грамматике КС",
        "answer": "____\n1. Берем все правила, которые имеют хотя бы один терминал в правой части. Берем оттуда\nмножество всех терминалов и нетерминалов слева.\n2. Берем все правила, которые имеют нетерминалы только из нашего\nмножества в правой части. Добавляем нетерминалы слева в наше множество. Повторяем.\n3. На каком-то этапе множество стабилизируется (все выведенные правила будут учтены). Терминалы и все полезные нетерминалы остаются в нашем\nмножестве.\n4. Берем разницу между всеми нетерминалами и нетерминалами из нашего построенного множества. Это будут бесполезные нетерминалы.\n5. Удаляем все правила, которые содержат бесполезные нетерминалы"
    },
    {
        "question": "Алгоритм удаления ненужных (негенерирующих) символов в КС-грамматике",
        "answer": "____\n1. Возьмите все линейки, у которых есть хотя бы одна клемма с правой стороны. Пойдем оттуда\nнабор всех терминалов и нетерминалов слева.\n2. Все правила, имеющие нетерминалы, берем только из нашего\nразмещается с правой стороны. Добавляем в наш набор нетерминалы слева. Повторяем.\n3. В какой-то момент все стабилизируется (будут учтены все производные правила). Терминалы и все полезные нетерминалы остаются у нас.\nмного.\n4. Берём разницу между всеми нетерминалами и нетерминалами в нашем построенном множестве. Это будут бесполезные нетерминалы.\n5. Удалить все правила, содержащие ненужные нетерминалы."
    },
    {
        "question": "Алгоритм удаления ненужных (негенерирующих) символов в КС-грамматике",
        "answer": "____\n1. Возьмите все линейки, у которых есть хотя бы одна клемма с правой стороны. Пойдем оттуда\nнабор всех терминалов и нетерминалов слева.\n2. Берём все правила, в правой части которых есть нетерминалы только нашего\nмножества. Добавляем в наш набор нетерминалы слева. Повторяем.\n3. В какой-то момент все стабилизируется (будут учтены все производные правила). В нашем\nТерминалов и всего полезного нетерминала еще полно.\n4. Возьмите разницу всех нетерминалов и нетерминалов в нашем построенном множестве. Этот\nбудут ненужные нетерминалы.\n5. Удалить все правила, содержащие ненужные нетерминалы."
    },
    {
        "question": "Алгоритм удаления недостижимых символов",
        "answer": "____\n1. Берём множество, состоящее из S.\n2. Добавляем в наше множество все нетерминалы и терминалы, которые стоят в правой части\nправил, в левой части которых нетерминалы из нашего множества.\n3. На каком-то шаге множество стабилизируется (все выводимые правила будут учтены). В нашем\nмножестве остались только достижимые символы (терминалы и нетерминалы).\n4. Берём разность всех нетерминалов и нетерминалов из нашего построенного множества. Это\nбудут бесполезные нетерминалы. То же самое и с терминалами.\n5. Удаляем все правила, в которых встречаются бесполезные нетерминалы. То же самое и с терминалами."
    },
    {
        "question": "Алгоритм удаления недоступных символов",
        "answer": "____\n1. Возьмем набор, состоящий из S.\n2. Добавим к нашему набору все нетерминалы и терминалы, которые находятся справа от правил, которые имеют нетерминалы из нашего набора слева.\n3. На каком-то шаге набор стабилизируется (будут учтены все выводимые правила). В нашем наборе останутся только достижимые символы (терминалы и нетерминалы).\n4. Возьмем разницу между всеми нетерминалами и нетерминалами из нашего построенного набора. Это будут бесполезные нетерминалы. То же самое с терминалами.\n5. Удалим все правила, которые содержат бесполезные нетерминалы. То же самое с терминалами."
    },
    {
        "question": "Алгоритм удаления недоступных символов",
        "answer": "____\n1. Возьмем набор, состоящий из S.\n2. Добавим в наш набор все нетерминалы и терминалы, находящиеся справа от правил, у которых слева есть нетерминалы из нашего набора.\n3. В данный момент целое стабилизируется (будут учтены все производные правила). В нашем наборе останутся только доступные символы (терминальные и нетерминальные).\n4. Рассмотрим разницу между всеми нетерминалами и нетерминалами в нашем построенном множестве. Это будут бесполезные нетерминалы. То же самое и с терминалами.\n5. Удалить все правила, содержащие ненужные нетерминалы. То же самое и с терминалами."
    },
    {
        "question": "Алгоритм удаления недоступных символов",
        "answer": "____\n1. Возьмем набор, состоящий из S.\n2. Добавляем в наш набор все неклеммы и клеммы, которые находятся с правой стороны\nправила, в левой части которых находятся нетерминалы нашего набора.\n3. В какой-то момент все стабилизируется (будут учтены все производные правила). В нашем\nВ наборе остаются только доступные символы (терминальные и нетерминальные).\n4. Возьмите разницу всех нетерминалов и нетерминалов в нашем построенном множестве. Этот\nбудут ненужные нетерминалы. То же самое и с терминалами.\n5. Удалить все правила, содержащие ненужные нетерминалы. То же самое и с терминалами."
    },
    {
        "question": "Алгоритм удаления ε-правил",
        "answer": "____\n1. Нашли все ε-правила. Добавили в множество нетерминалы из левых частей этих ε-правил.\n2. Заменили во всех правилах нетерминалы из нашего множества на ε.\n3. Убрали все ε (ε^n = ε).\n4. Повторяем с шага 1, пока можем найти новые ε-правила.\n5. Для всех правил вида A → B, где для B существует ε-правило, добавим правила вида A → ε, если таких еще нет.\n6. Удаляем все изначальные ε-правила (т.е. те, которые нашли на 1-ом шаге)."
    },
    {
        "question": "Алгоритм удаления ε-правил",
        "answer": "____\n1. Нашли все ε-правила. Добавили нетерминалы из левых частей этих ε-правил в набор.\n2. Заменили нетерминалы из нашего набора на ε во всех правилах.\n3. Удалили все ε (ε^n = ε).\n4. Повторяем с шага 1, пока не найдем новые ε-правила.\n5. Для всех правил вида A → B, где есть ε-правило для B, добавляем правила вида A → ε, если их еще нет.\n6. Удалили все начальные ε-правила (т. е. найденные на шаге 1)."
    },
    {
        "question": "Алгоритм удаления ε правил",
        "answer": "____\n1. Найдены все ε правил. Мы добавили в набор нетерминалы левых частей этих ε-правил.\n2. Замена нетерминалов нашего множества на ε во всех правилах.\n3. Удаление всех ε (ε^n = ε).\n4. Повторяем начиная с шага 1, пока не найдем новые ε правила.\n5. Ко всем правилам вида A → B, где существует ε-правило для B, добавить правила вида A → ε, если они еще не существуют.\n6. Удалите все исходные правила ε (т. е. те, которые были найдены на шаге 1)."
    },
    {
        "question": "Алгоритм удаления ε правил",
        "answer": "____\n1. Найдены все ε правил. Мы добавили в набор нетерминалы левых частей этих ε-правил.\n2. Замена нетерминалов нашего множества на ε во всех правилах.\n3. Удаление всех ε (ε^n = ε).\n4. Повторяем шаг 1, пока не найдем новые правила ε.\n5. Ко всем правилам вида A → B, где существует ε-правило для B, добавим правила вида A → ε, если они еще не существуют.\n6. Удаляем все исходные ε-правила (т.е. найденные на 1-м шаге)."
    },
    {
        "question": "Алгоритм удаления цепного правила",
        "answer": "____\nЕсли встретилось цепное правило A → B, и в P есть правило вида B → α, α ∈ (N + ∑)*, то добавим правило A → α, а правило A → B вычеркнем."
    },
    {
        "question": "Алгоритм удаления цепного правила",
        "answer": "____\nЕсли встречается цепочка правил A → B, и P содержит правило вида B → α, α ∈ (N + ∑)*, то мы добавляем правило A → α и вычеркиваем правило A → B."
    },
    {
        "question": "Алгоритм удаления правил цепочки",
        "answer": "____\nЕсли мы встречаем цепочку правил A → B и P содержит правило вида B → α, α ∈ (N + ∑)*, то добавляем правило A → α и вычеркиваем правило A → B."
    },
    {
        "question": "Алгоритм удаления правил цепочки",
        "answer": "____\nЕсли мы встречаем цепное правило A → B и P имеет правило вида B → α, α ∈ (N + ∑)*, то мы добавляем правило A → α и удаляем правило A → B."
    },
    {
        "question": "Что такое язык Лукасевича",
        "answer": "____\nЯзыком Лукасевича над n + 1 буквами называется контекстно-свободный\nязык над алфавитом {a0, a1,...,an}, порождаемый грамматикой\nS -> a0, S -> a1S, S -> a2SS, ..., S -> anSn\nЗамечание: При любом n ∈ N грамматика является однозначной."
    },
    {
        "question": "На каком языке говорит Лукасевич?",
        "answer": "____\nЯзык Лукасевича над n + 1 буквой — это контекстно-свободный\nязык над алфавитом {a0, a1,...,an}, сгенерированный грамматикой\nS -> a0, S -> a1S, S -> a2SS, ..., S -> anSn\nПримечание: для любого n ∈ N грамматика однозначна."
    },
    {
        "question": "На каком языке говорит Лукасевич?",
        "answer": "____\nЯзык Лукасевича на n + 1 буквах является контекстно-свободным.\nязык на алфавите {a0, a1,...,an}, порожденном грамматикой\nS -> a0, S -> a1S, S -> a2SS, ..., S -> anSn\nПримечание: для всех n ∈ N грамматика однозначна."
    },
    {
        "question": "Какой язык у Лукасевича?",
        "answer": "____\nГоворят, что язык Лукасевича, состоящий из n + 1 букв, не имеет контекста.\nязык на алфавите {a0, a1,...,an}, порожденном грамматикой\nS -> a0, S -> a1S, S -> a2SS, ..., S -> anSn\nПримечание. Для всех n ∈ N грамматика однозначна."
    },
    {
        "question": "Что такое язык Дика",
        "answer": "____\nЯзыком Дика над 2n\nбуквами называется контекстно-свободный язык над алфавитом\n{a1, b1, a2, b2,...,an, bn}, порождаемый грамматикой S → ε,\nS → a1Sb1S, ..., S → anSbnS.\nЗамечание: Словами этого языка являются последовательности правильно вложенных скобок n типов.\nЗамечание: При любом n ∈ N грамматика является однозначной."
    },
    {
        "question": "На каком языке говорит Дик?",
        "answer": "____\nЯзык Дик над 2n\nбуквами — это контекстно-свободный язык над алфавитом\n{a1, b1, a2, b2,...,an, bn}, порожденный грамматикой S → ε,\nS → a1Sb1S, ..., S → anSbnS.\nПримечание: слова этого языка представляют собой последовательности правильно вложенных скобок n типов.\nПримечание: для любого n ∈ N грамматика однозначна."
    },
    {
        "question": "На каком языке говорит Дик?",
        "answer": "____\nЧлен с языком на 2n\nбуквы - это язык без контекста в алфавите\n{a1, b1, a2, b2,...,an, bn}, порожденный грамматикой S → ε,\nS → a1Sb1S, ..., S → anSbnS.\nПримечание. Слова в этом языке представляют собой последовательности из n типов правильно вложенных круглых скобок.\nПримечание: для всех n ∈ N грамматика однозначна."
    },
    {
        "question": "Что такое язык Дика?",
        "answer": "____\nЯзык Дика за 2н.\nбуквы называются контекстно-свободным языком по сравнению с алфавитом\n{a1, b1, a2, b2,...,an, bn}, порожденный грамматикой S → ε,\nS → a1Sb1S, ..., S → anSbnS.\nПримечание. Слова в этом языке представляют собой последовательность правильно вложенных круглых скобок n типов.\nПримечание. Для всех n ∈ N грамматика однозначна."
    },
    {
        "question": "Что такое автомат Мили",
        "answer": "____\nАвтомат Мили - это 6-ка (Q, Σ, Λ, δ, λ, q₀), где:\nQ - множество состояний автомата\nΣ - конечный входной алфавит\nΛ - конечный выходной алфавит\nδ - функция перехода, которая принимает текущее состояние и входной символ, и возвращает следующее состояние\nλ - функция вывода, которая принимает текущее состояние и входной символ, и возвращает выходной символ\nq₀ - начальное состояние"
    },
    {
        "question": "Что такое машина Мили?",
        "answer": "____\nАвтомат Мили — это 6-кортеж (Q, Σ, Λ, δ, λ, q₀), где:\nQ — множество состояний автомата\nΣ — конечный входной алфавит\nΛ — конечный выходной алфавит\nδ — функция перехода, которая принимает текущее состояние и входной символ и возвращает следующее состояние\nλ — выходная функция, которая принимает текущее состояние и входной символ и возвращает выходной символ\nq₀ — начальное состояние"
    },
    {
        "question": "Что такое машина Мили?",
        "answer": "____\nМашина Мили — это набор из 6 элементов (Q, Σ, Λ, δ, λ, q₀), где:\nQ - набор состояний машины\nΣ — последний входной алфавит\nΛ — конечный выходной алфавит\nδ — функция перехода, которая принимает текущее состояние и входной символ и возвращает следующее состояние.\nλ — выходная функция, которая принимает текущее состояние и входной символ и возвращает выходной символ.\nq₀ - исходное состояние"
    },
    {
        "question": "Что такое машина Мили?",
        "answer": "____\nМашина Мили — это 6 (Q, Σ, Λ, δ, λ, q₀), где:\nQ - множество состояний автомата\nΣ - последний входной алфавит\nΛ - окончательный выходной алфавит\nδ — функция перехода, которая принимает текущее состояние и входной символ и возвращает следующее состояние.\nλ — выходная функция, которая принимает текущее состояние и входной символ и возвращает выходной символ.\nq₀ - исходное состояние"
    },
    {
        "question": "Какие есть свойства у класса детерминнированых контекстно-свободных языков",
        "answer": "____\nТеорема: Каждый автоматный язык является детерминированным контекстно-свободным языком.\nТеорема: Язык L ⊆ Σ∗ является детерминированным\nконтекстно-свободным языком тогда и только тогда, когда\nнайдётся такой детерминированный МП-автомат M' = <Q', Σ, Γ', ∆', I', F'>, что\nL={w∈Σ∗ | <s,w,ε> |*-- <q,ε,α> для некоторых s∈I', q∈F', α∈Γ'∗}.\nТеорема: Пусть L — детерминированный контекстно-свободный язык. Тогда язык L не является существенно\nнеоднозначным.\nТеорема: Дополнение каждого детерминированного\nконтекстно-свободного языка является детерминированным\nконтекстно-свободным языком.\nПример 12.10. Язык L = {a^kb^mc^n | k != m или m != n}\nнад алфавитом {a, b, c} не является детерминированным контекстно-свободнымязыком, так как его дополнение не является\nконтекстно-свободным\nТеорема: Неверно, что для любых детерминированных контекстно-свободных языков L1 и L2 язык L1 ∩ L2\nтоже является детерминированным контекстно-свободным\nязыком.\nТеорема: Неверно, что для любых детерминированных контекстно-свободных языков L1 и L2 язык L1 ∪ L2\nтоже является детерминированным контекстно-свободным языком."
    },
    {
        "question": "Каковы свойства класса детерминированных контекстно-свободных языков?",
        "answer": "____\nТеорема: Каждый автоматный язык является детерминированным контекстно-свободным языком.\nТеорема: Язык L ⊆ Σ∗ является детерминированным контекстно-свободным языком тогда и только тогда,\nкогда существует детерминированный MP-автомат M' = <Q', Σ, Γ', ∆', I', F'> такой, что\nL={w∈Σ∗ | <s,w,ε> |*-- <q,ε,α> для некоторых s∈I', q∈F', α∈Γ'∗}.\nТеорема: Пусть L — детерминированный контекстно-свободный язык. Тогда L не является существенно неоднозначным.\nТеорема: Дополнение каждого детерминированного контекстно-свободного языка является детерминированным контекстно-свободным языком.\nПример 12.10. Язык L = {a^kb^mc^n | k != m или m != n}\nнад алфавитом {a, b, c} не является детерминированным контекстно-свободным языком, поскольку его дополнение не является\nконтекстно-свободным\nТеорема: Неверно, что для любых детерминированных контекстно-свободных языков L1 и L2 язык L1 ∩ L2\nтакже является детерминированным контекстно-свободным\nязыком.\nТеорема: Неверно, что для любых детерминированных контекстно-свободных языков L1 и L2 язык L1 ∪ L2\nтакже является детерминированным контекстно-свободным\nязыком."
    },
    {
        "question": "Каковы свойства класса контекстно-свободных детерминированных языков?",
        "answer": "____\nТеорема: Любой автоматный язык является контекстно-свободным детерминированным языком.\nТеорема: Язык L ⊆ Σ∗ является контекстно-свободным детерминированным языком тогда и только тогда, когда\nкогда существует детерминированный МП-автомат M' = <Q', Σ, Γ', ∆', I', F'> такой, что\nL={wεΣ∗ | <s,w,ε> |*-- <q,ε,α> для некоторых sεI', qεF', αεΓ'∗}.\nТеорема: Пусть L — детерминированный язык вне контекста. Тогда L не является по существу двусмысленным.\nТеорема: Дополнением к любому контекстно-свободному детерминированному языку является контекстно-свободный детерминированный язык.\nПример 12.10. Язык L = {a^kb^mc^n | k != m или m != n}\nв алфавите {a, b, c} не является детерминированным языком вне контекста, поскольку его дополнение не является\nбез контекста\nТеорема: Неверно, что для любого детерминированного языка вне контекста L1 и L2 язык L1 ∩ L2\nтакже детерминирован без контекста\nязык.\nТеорема: Неверно, что для любого детерминированного языка без контекста L1 и L2 язык L1 ∪ L2\nтакже детерминирован без контекста\nязык."
    },
    {
        "question": "Какими свойствами обладает класс контекстно-свободных детерминированных языков?",
        "answer": "____\nТеорема: Любой автоматный язык является контекстно-свободным детерминированным языком.\nТеорема: Язык L ⊆ Σ∗ детерминирован.\nконтекстно-свободный язык тогда и только тогда, когда\nсуществует детерминированный автомат МП M' = <Q', Σ, Γ', ∆', I', F'> такой, что\nL={wεΣ∗ | <s,w,ε> |*-- <q,ε,α> для некоторых sεI', qεF', αεΓ'∗}.\nТеорема: Пусть L — детерминированный язык вне контекста. Таким образом, язык L по существу не является\nдвусмысленный.\nТеорема: дополнение каждого детерминиста\nконтекстно-свободный язык детерминирован\nязык без контекста.\nПример 12.10. Язык L = {a^kb^mc^n | k != m или m != n}\nв алфавите {a, b, c} не является детерминированным языком вне контекста, поскольку его дополнение не является\nбез контекста\nТеорема: Неверно, что для любого детерминированного языка вне контекста L1 и L2 язык L1 ∩ L2\nтакже детерминирован без контекста\nязык.\nТеорема: Неверно, что для любого детерминированного языка без контекста L1 и L2 язык L1 ∪ L2\nтакже является детерминированным контекстно-свободным языком."
    },
    {
        "question": "Сформулируй теорему Клини",
        "answer": "____\nТеорема Клини: Язык L является регулярным тогда и только тогда, когда он является автоматным\nЯзык L называется автоматным, если существует конечный автомат, распознающий этот язык."
    },
    {
        "question": "Теорема Клини",
        "answer": "____\nТеорема Клини: Язык L регулярен тогда и только тогда, когда он автоматен\nЯзык L называется автоматным, если существует конечный автомат, распознающий этот язык."
    },
    {
        "question": "Теорема Клини",
        "answer": "____\nТеорема Клини: язык L регулярен тогда и только тогда, когда он автоматен.\nЯзык L называется автоматом, если существует конечный автомат, распознающий этот язык."
    },
    {
        "question": "Государственная теорема Клини",
        "answer": "____\nТеорема Клини: язык L регулярен тогда и только тогда, когда он автоматен.\nЯзык L называется автоматом, если существует конечный автомат, распознающий этот язык."
    },
    {
        "question": "Что такое гомоморфизм афлавитов",
        "answer": "____\nПусть Σ1 и Σ2 — алфавиты. Если отображение h: Σ∗1 → Σ∗2 удовлетворяет условию h(x · y) = h(x)· h(y)\nдля всех слов x ∈ Σ∗1 и y ∈ Σ∗1, то отображение h называется\nгомоморфизмом (морфизмом).\nЗамечание: Если h — гомоморфизм, то h(ε) = ε.\nПример: Пусть Σ1 = {a, b} и Σ2 = {c}. Тогда\nотображение h: Σ∗1 → Σ∗2, заданное равенством h(w) = c^(2|w|), является гомоморфизмом.\nЗамечание: Каждый гомоморфизм однозначно определяется своими значениями на однобуквенных словах.\nОпределение 1.37. Если h: Σ∗1 → Σ∗2 — гомоморфизм и L ⊆ Σ∗1, то через h(L) обозначается язык {h(w) | w ∈ L}.\nПример: Пусть Σ = {a, b} и гомоморфизм h: Σ∗ → Σ∗ задан равенствами h(a) = abba и h(b) = ε. Тогда\nh({baa, bb}) = {abbaabba, ε}.\nОпределение 1.39. Если h: Σ∗1 → Σ∗2 — гом ом орфизм и L ⊆ Σ∗2, то через h^(−1)(L) обозначается язык {w ∈ Σ∗1 | h(w) ∈ L}.\nПример: Рассмотрим алфавит Σ = {a, b}. Пусть гом оморфизм h: Σ∗ → Σ∗ задан равенствами h(a) = ab и h(b) = abb.\nТогда h^(−1)({ε, abbb, abbab, ababab}) = {ε, ba, aaa}."
    },
    {
        "question": "Что такое гомоморфизм афлавита?",
        "answer": "____\nПусть Σ1 и Σ2 — алфавиты. Если отображение h: Σ∗1 → Σ∗2 удовлетворяет условию h(x y) = h(x) h(y)\nдля всех слов x ∈ Σ∗1 и y ∈ Σ∗1, то отображение h называется\nгомоморфизмом (морфизмом).\nЗамечание: Если h — гомоморфизм, то h(ε) = ε.\nПример: Пусть Σ1 = {a, b} и Σ2 = {c}. Тогда\nотображение h: Σ∗1 → Σ∗2, заданное формулой h(w) = c^(2|w|), является гомоморфизмом.\nЗамечание: Каждый гомоморфизм однозначно определяется своими значениями на однобуквенных словах.\nОпределение 1.37. Если h: Σ∗1 → Σ∗2 — гомоморфизм и L ⊆ Σ∗1, то h(L) обозначает язык {h(w) | w ∈ L}.\nПример: Пусть Σ = {a, b} и гомоморфизм h: Σ∗ → Σ∗ задан формулами h(a) = abba и h(b) = ε. Тогда h({baa, bb}) = {abbaabba, ε}.\nОпределение 1.39. Если h: Σ∗1 → Σ∗2 — однородный орфизм и L ⊆ Σ∗2, то h^(−1)(L) обозначает язык {w ∈ Σ∗1 | h(w) ∈ L}.\nПример: Рассмотрим алфавит Σ = {a, b}. Пусть гомоморфизм h: Σ∗ → Σ∗ задан равенствами h(a) = ab и h(b) = abb. Тогда h^(−1)({ε, abbb, abbab, ababab}) = {ε, ba, aaa}."
    },
    {
        "question": "Что такое гомоморфизм афлавита?",
        "answer": "____\nПусть Σ1 и Σ2 — алфавиты. Если отображение h: Σ∗1 → Σ∗2 удовлетворяет условию h(x y) = h(x) h(y)\nдля всех слов x ∈ Σ∗1 и y ∈ Σ∗1 отображение h называется\nгомоморфизм (морфизм).\nПримечание. Если h — гомоморфизм, то h(ε) = ε.\nПример: Пусть Σ1 = {a, b} и Σ2 = {c}. ТАК\nотображение h : Σ∗1 → Σ∗2, заданное формулой h(w) = c^(2|w|), является гомоморфизмом.\nПримечание. Каждый гомоморфизм однозначно определяется его значением в однобуквенных словах.\nОпределение 1.37. Если h : Σ∗1 → Σ∗2 — гомоморфизм и L ⊆ Σ∗1, то h(L) обозначает язык {h(w) | w ∈ L}.\nПример: Пусть Σ = {a, b} и гомоморфизм h: Σ∗ → Σ∗ задан формулами h(a) = abba и h(b) = ε. Тогда h({baa, bb}) = {abbaabba, ε}.\nОпределение 1.39. Если h : Σ∗1 → Σ∗2 — однородный орфизм и L ⊆ Σ∗2, то h^(−1)(L) обозначает язык {w ∈ Σ∗1 | h(w) ∈L}.\nПример: рассмотрим алфавит Σ = {a, b}. Пусть гомоморфизм h: Σ∗ → Σ∗ задается равенствами h(a) = ab и h(b) = abb. Тогда h^(−1)({ε, abbb, abbab, abab}) = {ε, ba, aaa}."
    },
    {
        "question": "Что такое гомоморфизм афлавита?",
        "answer": "____\nПусть Σ1 и Σ2 — алфавиты. Если отображение h: Σ∗1 → Σ∗2 удовлетворяет условию h(x y) = h(x) h(y)\nдля всех слов x ∈ Σ∗1 и y ∈ Σ∗1 отображение h называется\nгомоморфизм (морфизм).\nПримечание. Если h — гомоморфизм, то h(ε) = ε.\nПример: Пусть Σ1 = {a, b} и Σ2 = {c}. ТАК\nотображение h: Σ∗1 → Σ∗2, определенное равенством h(w) = c^(2|w|), является гомоморфизмом.\nПримечание. Каждый гомоморфизм однозначно определяется его значением в однобуквенных словах.\nОпределение 1.37. Если h : Σ∗1 → Σ∗2 — гомоморфизм и L ⊆ Σ∗1, то h(L) обозначает язык {h(w) | w ∈ L}.\nПример. Пусть Σ = {a, b} и гомоморфизм h: Σ∗ → Σ∗, заданный формулами h(a) = abba и h(b) = ε. ТАК\nh({baa, bb}) = {abbaabba, ε}.\nОпределение 1.39. Если h : Σ∗1 → Σ∗2 — однородный орфизм и L ⊆ Σ∗2, то h^(−1)(L) обозначает язык {w ∈ Σ∗1 | h(w) ∈L}.\nПример: рассмотрим алфавит Σ = {a, b}. Пусть гомоморфизм h: Σ∗ → Σ∗ задается равенствами h(a) = ab и h(b) = abb.\nТогда h^(−1)({ε, abbb, abbab, abab}) = {ε, ba, aaa}."
    },
    {
        "question": "Что такое алгебра контекстно-свободных языков",
        "answer": "____\nАлгебраические свойства КС-языков:\nЕсли L — контекстно-свободный язык, то\nL∗ тоже контекстно-свободный язык.\nЕсли L1 и L2 — контекстно-свободные языки над алфавитом Σ, то L1 · L2 тоже контекстно-свободный\nязык.\nЕсли L1 и L2 — контекстно-свободные языки над алфавитом Σ, то L1 ∪ L2 тоже контекстно-свободный\nязык.\nЕсли L — контекстно-свободный язык, то\nL^R тоже контекстно-свободный язык.\nЕсли L — КС-язык, а R — регулярный язык, то L ∩ R — КС-язык.\nДополнение КС-языка в общем случае не является КС-языком."
    },
    {
        "question": "Что такое контекстно-свободная языковая алгебра?",
        "answer": "____\nАлгебраические свойства контекстно-свободных языков:\nЕсли L — контекстно-свободный язык, то\nL∗ — также контекстно-свободный язык.\nЕсли L1 и L2 — контекстно-свободные языки над алфавитом Σ, то L1 · L2 — также контекстно-свободный\nязык.\nЕсли L1 и L2 — контекстно-свободные языки над алфавитом Σ, то L1 ∪ L2 — также контекстно-свободный\nязык.\nЕсли L — контекстно-свободный язык, то\nL^R — также контекстно-свободный язык.\nЕсли L — контекстно-свободный язык, а R — регулярный язык, то L ∩ R — контекстно-свободный язык.\nДополнение контекстно-свободного языка в общем случае не является контекстно-свободным языком."
    },
    {
        "question": "Что такое контекстно-свободная языковая алгебра?",
        "answer": "____\nАлгебраические свойства контекстно-свободных языков:\nЕсли L — контекстно-свободный язык, то\nL∗ также является контекстно-свободным языком.\nЕсли L1 и L2 — контекстно-свободные языки на алфавите Σ, то L1·L2 также является контекстно-свободным.\nязык.\nЕсли L1 и L2 — контекстно-свободные языки на алфавите Σ, то L1 ∪ L2 также являются контекстно-свободными.\nязык.\nЕсли L — контекстно-свободный язык, то\nL^R также является контекстно-свободным языком.\nЕсли L — контекстно-свободный язык, а R — регулярный язык, то L ∩ R — контекстно-свободный язык.\nДополнение контекстно-свободного языка, как правило, не является контекстно-свободным языком."
    },
    {
        "question": "Что такое алгебра контекстно-свободных языков?",
        "answer": "____\nАлгебраические свойства языков CS:\nЕсли L — контекстно-свободный язык, то\nL∗ также является контекстно-свободным языком.\nЕсли L1 и L2 — контекстно-свободные языки на алфавите Σ, то L1·L2 также является контекстно-свободным.\nязык.\nЕсли L1 и L2 — контекстно-свободные языки на алфавите Σ, то L1 ∪ L2 также являются контекстно-свободными.\nязык.\nЕсли L — контекстно-свободный язык, то\nL^R также является контекстно-свободным языком.\nЕсли L — язык KS, а R — регулярный язык, то L ∩ R — язык KS.\nДобавление языка KS обычно не является языком KS."
    },
    {
        "question": "Что такое деревья вывода",
        "answer": "____\nВыводам в контекстно-свободной грамматике соответствуют так называемые деревья вывода (или деревья\nразбора) — некоторые упорядоченные деревья, вершины которых помечены символами алфавита N ∪Σ.\nКорень дерева отвечает начальному символу. Каждому символу слова w1, на которую заменяется начальный символ на первом\nшаге вывода, ставится в соответствие вершина дерева, и к ней\nпроводится дуга из корня. Полученные таким образом непосредственные потомки корня упорядочены согласно порядку их меток\nв слове w1. Для тех из полученных вершин, которые помечены символами из множества N, делается аналогичное построение\nи т. д. Кроной дерева вывода называется слово, записанное в\nвершинах, помеченных символами из алфавита Σ.\nПример: Рассмотрим контекстно-свободную грамматику\nS -> SS, S -> ab, S -> aSb. Выводу S -> SS -> Sab -> SSab -> abSab -> ababab соответствует следующее дерево вывода:\n        S\n       / \\\n      S   S\n     / \\  |\\\n    S   S a b\n   /|   |\\\n  a b   a b"
    },
    {
        "question": "Что такое деревья вывода?",
        "answer": "____\nВыходы в контекстно-свободной грамматике соответствуют так называемым выходным деревьям (или деревьям разбора) — некоторым упорядоченным деревьям, вершины которых помечены символами из алфавита N ∪ Σ.\nКорень дерева соответствует начальному символу. Каждому символу слова w1, который заменяет начальный символ на первом шаге вывода, сопоставляется вершина дерева, и от корня к ней проводится дуга. Полученные таким образом непосредственные потомки корня упорядочиваются в соответствии с порядком их меток\nв слове w1. Для тех из полученных вершин, которые помечены символами из множества N, выполняется аналогичное построение,\nи так далее. Короной выходного дерева является слово, записанное в вершинах, помеченных символами из алфавита Σ.\nПример: Рассмотрим контекстно-свободную грамматику\nS -> SS, S -> ab, S -> aSb. Выход S -> SS -> Sab -> SSab -> abSab -> ababab соответствует следующему выходному дереву:\nS\n/ \\\nS S\n/ \\ |\\\nS S a b\n/| |\\\na b a b"
    },
    {
        "question": "Что такое деревья вывода?",
        "answer": "____\nВыходные данные в контекстно-свободной грамматике соответствуют так называемым выходным деревьям (или деревьям разбора) – упорядоченным деревьям, вершины которых отмечены символами алфавита N ∪ Σ.\nКорень дерева соответствует начальному персонажу. Каждому символу слова w1, заменяющему исходный символ на первом шаге вывода, ставится в соответствие вершина дерева, и от корня к ней проводится дуга. Непосредственные результирующие дочерние элементы корня упорядочены в соответствии с порядком их меток.\nв слове w1. Для тех из полученных вершин, которые отмечены символами из множества N, производится аналогичное построение:\nи так далее. Венцом выходного вала является слово, написанное в вершинах, отмеченных символами алфавита Σ.\nПример. Рассмотрим контекстно-свободную грамматику.\nS -> SS, S -> ab, S -> aSb. Выход S -> SS -> Sab -> SSab -> abSab -> ababab соответствует следующему выходному дереву:\nС\n/\\\nSS\n/\\|\\\nС С а б\n/| |\\\nа б а б"
    },
    {
        "question": "Что такое деревья вывода",
        "answer": "____\nВыводы в контекстно-свободной грамматике соответствуют тому, что мы называем деревьями вывода (или\nсинтаксический анализ) представляют собой упорядоченные деревья, вершины которых отмечены символами алфавита N ∪Σ.\nКорень дерева соответствует начальному символу. Каждый символ слова w1, который заменяется начальным символом первого\nшаге вывода присваивается вершина дерева, а ей\nот корня рисуется дуга. Непосредственные результирующие дочерние элементы корня упорядочены в соответствии с порядком их меток.\nв слове w1. Для тех из получившихся вершин, которые отмечены символами из множества N, проводится аналогичное построение\nи т. д. Крона дерева умозаключений — это слово, написанное на\nвершины отмечены символами алфавита Σ.\nПример. Рассмотрим контекстно-свободную грамматику.\nS -> SS, S -> ab, S -> aSb. Выход S -> SS -> Sab -> SSab -> abSab -> ababab соответствует следующему выходному дереву:\n        С\n       /\\\n      SS\n     /\\|\\\n    С С а б\n   /|   |\\\n  а б а б"
    },
    {
        "question": "Что такое неукорачивающиеся грамматики",
        "answer": "____\nОпределение: Порождающая грамматика называется\nнеукорачивающей, если для каждого правила (α -> β) ∈ P\nвыполняется неравенство |α| <= |β|.\nТеорема: Существует алгоритм, позволяющий по\nпроизвольной неукорачивающей грамматике G и по слову w\nузнать, верно ли, что w ∈ L(G).\nТеорема: Каждая контекстная грамматика является неукорачивающей. Каждая неукорачивающая грамматика\nэквивалентна некоторой контекстной грамматике.\nПример: Грамматика S -> AST A, S -> AbA, A -> a,\nbT -> bb, AT -> TA эквивалентна контекстной грамматике S -> ASTA, S -> AbA, A -> a,\nbT -> bb, AT -> UT, UT -> UV, UV -> TV, TV -> TA."
    },
    {
        "question": "Что такое неконтрактные грамматики?",
        "answer": "____\nОпределение: Генеративная грамматика называется\nнеконтрактной, если для каждого правила (α -> β) ∈ P\nвыполняется неравенство |α| <= |β|.\nТеорема: Существует алгоритм, который,\nесли задана произвольная неконтрактная грамматика G и слово w,\nнаходит, является ли w ∈ L(G).\nТеорема: Каждая контекстная грамматика является неконтрактной. Каждая неконтрактная грамматика\nэквивалентна некоторой контекстной грамматике.\nПример: Грамматика S -> AST A, S -> AbA, A -> a,\nbT -> bb, AT -> TA эквивалентна контекстной грамматике S -> ASTA, S -> AbA, A -> a,\nbT -> bb, AT -> UT, UT -> UV, UV -> TV, TV -> TA."
    },
    {
        "question": "Что такое недоговорные грамматики?",
        "answer": "____\nОпределение: Генеративной грамматикой называется\nнедоговорный, если для каждого правила (α -> β) ∈ P\nнеравенство |α| <= |β|.\nТеорема: существует алгоритм, который\nесли мы дадим ему произвольную недоговорную грамматику G и слово w,\nопределяет, является ли w ∈ L(G).\nТеорема: Вся контекстная грамматика является недоговорной. Любая внедоговорная грамматика\nэквивалентно контекстуальной грамматике.\nПример: Грамматика S -> AST A, S -> AbA, A -> a,\nbT -> bb, AT -> TA эквивалентно контекстной грамматике S -> ASTA, S -> AbA, A -> a,\nбТ -> бб, АТ -> УТ, УТ -> УФ, УФ -> ТВ, ТВ -> ТА."
    },
    {
        "question": "Что такое несокращенные грамматики",
        "answer": "____\nОпределение: порождающая грамматика называется\nнесокращение, если для каждого правила (α -> β) ∈ P\nнеравенство |α| <= |β|.\nТеорема: Существует алгоритм, позволяющий\nпроизвольная неусеченная грамматика G и слово w\nвыяснить, верно ли, что w ∈ L(G).\nТеорема: Вся контекстная грамматика несокращена. Вся грамматика не усечена\nэквивалентно контекстуальной грамматике.\nПример: Грамматика S -> AST A, S -> AbA, A -> a,\nbT -> bb, AT -> TA эквивалентно контекстной грамматике S -> ASTA, S -> AbA, A -> a,\nбТ -> бб, АТ -> УТ, УТ -> УФ, УФ -> ТВ, ТВ -> ТА."
    },
    {
        "question": "Перечисли свойства регулярных выражений",
        "answer": "____\nРегулярные выражения образуют ассоциативное полукольцо с операциями (0, +, 1, ·), то есть для любых\nрегулярных выражений e, f и g выполняются следующие тождества:\n1. e+f = f+e,\n2. e+0 = e,\n3. (e+f)+g = e+(f+g),\n4. e·1 = e,\n5. 1·e = e,\n6. (e·f)·g = e·(f·g),\n7. e·(f+g) = e·f+e·g,\n8. (f+g)·e = f·e+g·e,\n9. e·0=0,\n10. 0·e = 0.\nРавенство понимается как равенство языков, задаваемых\nрегулярными выражениями.\nДля любых регулярных выражений e и f\nвыполняются следующие тождества:\n1. e+e = e,\n2. (1+e+ee+ ... +e^(n−1))(e^n)∗ = e∗ для любого n >= 1,\n3. (e∗f)∗e∗ = (e+f)∗,\n4. 1+e(fe)∗f = (ef)∗.\nЛемма: Для любых регулярных выражений e, f и g,\nесли e = ef+g и ε !∈ L(f), то e = gf∗."
    },
    {
        "question": "Перечислите свойства регулярных выражений.",
        "answer": "____\nРегулярные выражения образуют ассоциативное полукольцо с операциями (0, +, 1, ·), то есть для любых\nрегулярных выражений e, f и g выполняются следующие тождества:\n1. e+f = f+e,\n2. e+0 = e,\n3. (e+f)+g = e+(f+g),\n4. e·1 = e,\n5. 1·e = e,\n6. (e·f)·g = e·(f·g),\n7. e·(f+g) = e·f+e·g,\n8. (f+g)·e = f·e+g·e,\n9. e·0=0,\n10. 0·e = 0.\nРавенство понимается как равенство языков, определяемых\nрегулярными выражениями.\nДля любых регулярных выражений e и f\nвыполняются следующие тождества:\n1. e+e = e,\n2. (1+e+ee+ ... +e^(n−1))(e^n)∗ = e∗ для любого n >= 1,\n3. (e∗f)∗e∗ = (e+f)∗,\n4. 1+e(fe)∗f = (ef)∗.\nЛемма: Для любых регулярных выражений e, f и g,\nесли e = ef+g и ε !∈ L(f), то e = gf∗."
    },
    {
        "question": "Перечислите свойства регулярных выражений.",
        "answer": "____\nРегулярные выражения образуют ассоциативное полукольцо с операциями (0, +, 1, ·), т.е. для всех\nрегулярные выражения e, f и g удовлетворяют следующим тождествам:\n1. е+е = е+е,\n2. е+0 = е,\n3. (е+е)+г = е+(е+г),\n4. е 1 = е,\n5. 1 е = е,\n6. (эф)г = е(ф г),\n7. е·(f+g) = е·f+e·g,\n8. (f+g)e = fe+ge,\n9. е·0=0,\n10. 0 е = 0.\nПод равенством понимается равенство определенных языков.\nрегулярные выражения.\nДля всех регулярных выражений e и f\nимеют место следующие личности:\n1. е+е = е,\n2. (1+e+ee+ ... +e^(n−1))(e^n)∗ = e∗ для всех n >= 1,\n3. (e∗f)∗e∗ = (e+f)∗,\n4. 1+e(fe)∗f = (ef)∗.\nЛемма: для любого регулярного выражения e, f и g\nесли e = ef+g и ε !ε L(f), то e = gf∗."
    },
    {
        "question": "Список свойств регулярных выражений",
        "answer": "____\nРегулярные выражения образуют ассоциативное полукольцо с операциями (0, +, 1, ·), т.е. для всех\nрегулярные выражения e, f и g удовлетворяют следующим тождествам:\n1. е+е = е+е,\n2. е+0 = е,\n3. (е+е)+г = е+(е+г),\n4. е 1 = е,\n5. 1 е = е,\n6. (эф)г = е(ф г),\n7. е·(f+g) = е·f+e·g,\n8. (f+g)e = fe+ge,\n9. е·0=0,\n10. 0 е = 0.\nПод равенством понимается равенство данных языков.\nрегулярные выражения.\nДля всех регулярных выражений e и f\nимеют место следующие личности:\n1. е+е = е,\n2. (1+e+ee+ ... +e^(n−1))(e^n)∗ = e∗ для всех n >= 1,\n3. (e∗f)∗e∗ = (e+f)∗,\n4. 1+e(fe)∗f = (ef)∗.\nЛемма: для любого регулярного выражения e, f и g\nесли e = ef+g и ε !ε L(f), то e = gf∗."
    },
    {
        "question": "Что такое перевод конечного автомата в регулярное выражение",
        "answer": "____\nОпределение: Регулярное выражение над алфавитом Σ определяется рекурсивно следующимобразом: 0 является регулярнымвыражением; 1 является регулярным выражением; если\na ∈ Σ, то a является регулярным выражением; если e и f являются регулярными выражениями, то (e+f), (e·f) и e∗ тоже\nявляются регулярными выражениями. Вместо e·f часто пишут просто ef.\nПример. Пусть Σ = {a, b}. Тогда ((a·b)∗·(1+a)) является\nрегулярнымвыражениемнад алфавитом Σ.\nОпределение: Конечный автомат — это пятёрка M = <Q, Σ, ∆,I,F>, где\nΣ — конечный алфавит, Q и ∆ — конечные м ножества,\n∆ ⊆ Q × Σ∗ × Q, I ⊆ Q, F ⊆ Q. Элем енты Q называются состояниями, элементы I — начальными (initial) состояниями,\nэлементы F — заключительными или допускающими состояниями. Если <p, x, q> ∈ ∆, то <p, x, q> называется\nпереходом из p в q, а слово x — меткой этого\nперехода.\nПример: Пусть Q = {1, 2}, Σ = {a, b}, I = {2},\nF = {2}, ∆ = {<1, aaa, 1>, <1, ab, 2>, <1, b, 2>, <2, ε, 1>}. Тогда\n<Q, Σ, ∆,I,F> — конечный автом автомат.\nАлгоритм Томпсона (Данный алгоритм преобразовывает НКА в эквивалентный ДКА)\nАлгоритм преобразования ДКА в РВ:\nАлгебраический метод Бжозовского\nПри преобразовании ДКА в регулярное выражение создается система регулярных выражений \nдля каждого состояния в ДКА, а затем она решается для регулярных выражений Ri, связанных \nс терминальным состояниями qi. Построение уравнения происходит следующим образом: для каждого состояния qi уравнение Ri\nявляется объединением переходов, ведущих в это состояние. Переход a из qi в qj обозначается за aRi. Если qi\n- терминальное состояние, то в Ri добавляется ε. Это приводит к системе уравнений вида:\n\nR1=a1∗R1+a2∗R2+a3∗R3+...\nR2=a1∗R1+a2∗R2+a3∗R3+...+ε\n...\nRm=a1∗R1+a2∗R2+a3∗R3+...+ε\n\nгде ax = ∅ если нет перехода от Ri к Rj. Система может быть решена с помощью простой подстановки, \nза исключением случаев, когда неизвестное появляется как в правой, так и в левой части уравнения. \nДля этого можно воспользоваться теоремой Ардена:\n\nУравнение вида R=Q+RP, где P≠ε, имеет решение R=QP∗."
    },
    {
        "question": "Что такое конечный автомат для перевода регулярных выражений?",
        "answer": "____\nОпределение: Регулярное выражение над алфавитом Σ определяется рекурсивно следующим образом: 0 — регулярное выражение; 1 — регулярное выражение; если\na ∈ Σ, то a — регулярное выражение; если e и f — регулярные выражения, то (e+f), (e f) и e∗ также являются\nрегулярными выражениями. e f часто просто записывается как ef.\nПример: Пусть Σ = {a, b}. Тогда ((a b)∗ (1+a)) — регулярное выражение над алфавитом Σ.\nОпределение: Конечный автомат — это пятерка M = <Q, Σ, ∆, I, F>, где \nΣ — конечный алфавит, Q и ∆ — конечные множества, \n∆ ⊆ Q × Σ∗ × Q, I ⊆ Q, F ⊆ Q. Элементы Q называются состояниями, элементы I называются начальными состояниями, а элементы F называются конечными или принимающими состояниями. Если <p, x, q> ∈ ∆, то <p, x, q> называется переходом от p к q, а слово x называется меткой этого перехода. Пример: Пусть Q = {1, 2}, Σ = {a, b}, I = {2},\nF = {2}, ∆ = {<1, aaa, 1>, <1, ab, 2>, <1, b, 2>, <2, ε, 1>}. Тогда\n<Q, Σ, ∆,I,F> — конечный автомат.\nАлгоритм Томпсона (Этот алгоритм преобразует НКА в эквивалентный ДКА)\nАлгоритм преобразования ДКА в регулярное выражение:\nАлгебраический метод Бжозовского\nПри преобразовании ДКА в регулярное выражение создается система регулярных выражений\nдля каждого состояния в ДКА, а затем она решается для регулярных выражений Ri, связанных\nс конечными состояниями qi. Уравнение строится следующим образом: для каждого состояния qi уравнение Ri\nявляется объединением переходов, ведущих в это состояние. Переход a из qi в qj обозначается как aRi. Если qi\nявляется конечным состоянием, то к Ri добавляется ε. Это приводит к системе уравнений вида:\n\nR1=a1∗R1+a2∗R2+a3∗R3+...\nR2=a1∗R1+a2∗R2+a3∗R3+...+ε\n...\nRm=a1∗R1+a2∗R2+a3∗R3+...+ε\n\nгде ax = ∅, если нет перехода из Ri в Rj. Систему можно решить простой подстановкой, \nза исключением случаев, когда неизвестное появляется как в правой, так и в левой части уравнения. \nДля этого можно воспользоваться теоремой Ардена:\n\nУравнение вида R=Q+RP, где P≠ε, имеет решение R=QP∗."
    },
    {
        "question": "Что такое конечный автомат для перевода регулярных выражений?",
        "answer": "____\nОпределение: Регулярное выражение в алфавите Σ определяется рекурсивно следующим образом: 0 – регулярное выражение; 1 – регулярное выражение; Если\na ∈ Σ, то a — регулярное выражение; если e и f — регулярные выражения, то (e+f), (ef) и e∗ также являются\nрегулярные выражения. e f часто пишется просто как ef.\nПример: Пусть Σ = {a, b}. Тогда ((a b)∗ (1+a)) — регулярное выражение в алфавите Σ.\nОпределение: Конечный автомат — это пятерка M = <Q, Σ, ∆, I, F>, где \nΣ — конечный алфавит, Q и ∆ — конечные множества, \n∆ ⊆ Q × Σ∗ × Q, I ⊆ Q, F ⊆ Q. Элементы Q называются состояниями, элементы I называются начальными состояниями, а элементы F называются конечными или принимающими состояниями. Если <p, x, q> ∈ ∆, то <p, x, q> называется переходом от p к q, а слово x называется меткой этого перехода. Пример: Пусть Q = {1, 2}, Σ = {a, b}, I = {2},\nF = {2}, ∆ = {<1, ааа, 1>, <1, ab, 2>, <1, b, 2>, <2, ε, 1>}. ТАК\n<Q, Σ, ∆,I,F> — конечный автомат.\nАлгоритм Томпсона (этот алгоритм преобразует NFA в эквивалентный DFA)\nАлгоритм преобразования DFA в регулярное выражение:\nАлгебраический метод Бжозовского\nПреобразование DFA в регулярное выражение создает систему регулярных выражений\nдля каждого состояния DFA, затем он решается для связанных с ним регулярных выражений Ri\nс конечными состояниями ци. Уравнение строится следующим образом: для каждого состояния qi уравнение Ri\nесть объединение переходов, приводящих к этому состоянию. Переход от a от qi к qj обозначается aRi. Если ци\nявляется конечным состоянием, то к Ri добавляется ε. Это приводит к системе уравнений вида:\n\nR1=a1∗R1+a2∗R2+a3∗R3+...\nR2=a1∗R1+a2∗R2+a3∗R3+...+ε\n...\nRm=a1∗R1+a2∗R2+a3∗R3+...+ε\n\nгде ax = ∅, если нет перехода от Ri к Rj. Система решается простой заменой: \nза исключением случаев, когда неизвестное появляется справа и слева от уравнения. \nДля этого можно воспользоваться теоремой Ардена:\n\nУравнение вида R=Q+RP, где P≠ε, имеет решение R=QP∗."
    },
    {
        "question": "Что такое преобразование конечного автомата в регулярное выражение",
        "answer": "____\nОпределение: регулярное выражение в алфавите Σ определяется рекурсивно следующим образом: 0 — регулярное выражение; 1 — регулярное выражение; Если\na ∈ Σ, то a — регулярное выражение; если e и f — регулярные выражения, то (e+f), (ef) и e∗ также являются\nявляются регулярными выражениями. Вместо e·f часто пишут просто ef.\nПример. Пусть Σ = {a, b}. Тогда ((a b)∗ (1+a)) есть\nрегулярное выражение в алфавите Σ.\nОпределение: Конечный автомат – это пятерка M = <Q, Σ, ∆,I,F>, где\nΣ — конечный алфавит, Q и ∆ — конечные множества,\n∆ ⊆ Q × Σ∗ × Q, I ⊆ Q, F ⊆ Q. Элементы Q называются состояниями, элементы I называются начальными состояниями,\nэлементы F являются окончательными или разрешающими состояниями. Если <p, x, q> ∈ ∆, то <p, x, q> называется\nпереход от p к q, а слово x является меткой этого\nпереход.\nПример: Пусть Q = {1, 2}, Σ = {a, b}, I = {2},\nF = {2}, ∆ = {<1, ааа, 1>, <1, ab, 2>, <1, b, 2>, <2, ε, 1>}. ТАК\n<Q, Σ, ∆,I,F> — конечный автомат.\nАлгоритм Томпсона (этот алгоритм преобразует NFA в эквивалентный DFA)\nАлгоритм преобразования DFA в RT:\nАлгебраический метод Бжозовского\nПреобразование DFA в регулярное выражение создает систему регулярных выражений \nдля каждого состояния DFA, затем он решается для связанных с ним регулярных выражений Ri \nс терминальными состояниями ци. Уравнение строится следующим образом: для каждого состояния qi уравнение Ri\nесть объединение переходов, приводящих к этому состоянию. Переход a от qi к qj обозначается aRi. Если ци\nявляется терминальным состоянием, то к Ri добавляется ε. Это приводит к системе уравнений вида:\n\nR1=a1∗R1+a2∗R2+a3∗R3+...\nR2=a1∗R1+a2∗R2+a3∗R3+...+ε\n...\nRm=a1∗R1+a2∗R2+a3∗R3+...+ε\n\nгде ax = ∅, если нет перехода от Ri к Rj. Эту систему можно решить простой заменой: \nза исключением случаев, когда неизвестное появляется справа и слева от уравнения. \nДля этого можно воспользоваться теоремой Ардена:\n\nУравнение вида R=Q+RP, где P≠ε, имеет решение R=QP∗."
    },
    {
        "question": "Двоичное префиксное кодирование",
        "answer": "____\nэто гомоморфизм h : Σ+ → {0, 1}+ такой, что ∀ a, b ∈ Σ ∀ w ∈ {0, 1}∗(h(a) != h(b)w)."
    },
    {
        "question": "Двоичное префиксное кодирование",
        "answer": "____\nявляется гомоморфизмом h : Σ+ → {0, 1}+ таким, что ∀ a, b ∈ Σ ∀ w ∈ {0, 1}∗(h(a) != h(b)w)."
    },
    {
        "question": "Кодирование двоичного префикса",
        "answer": "____\nявляется гомоморфизмом h : Σ+ → {0, 1}+ такой, что ∀ a, b ∈ Σ ∀ w ∈ {0, 1}∗(h(a) != h(b)w)."
    },
    {
        "question": "Кодирование двоичного префикса",
        "answer": "____\nявляется гомоморфизмом h : Σ+ → {0, 1}+ такой, что ∀ a, b ∈ Σ ∀ w ∈ {0, 1}∗(h(a) != h(b)w)."
    },
    {
        "question": "Формальная грамматика",
        "answer": "____\nэто способ описания формального языка, представляющий собой четверку\nΓ=⟨Σ,N,S∈N,P⊂((Σ∪N)∗N(Σ∪N)∗)×(Σ∪N)∗⟩, где:\nΣ — алфавит, элементы которого называют терминалами (англ. terminals);\nN — множество, элементы которого называют нетерминалами (англ. nonterminals);\nS — начальный символ грамматики (англ. start symbol);\nP — набор правил вывода (англ. production rules или productions) α -> β."
    },
    {
        "question": "Формальная грамматика",
        "answer": "____\n— способ описания формального языка, который представляет собой четверку\nΓ=⟨Σ,N,S∈N,P⊂((Σ∪N)∗N(Σ∪N)∗)×(Σ∪N)∗⟩, где:\nΣ — алфавит, элементы которого называются терминалами;\nN — множество, элементы которого называются нетерминалами;\nS — начальный символ грамматики;\nP — множество правил продукции (или продукции) α -> β."
    },
    {
        "question": "Формальная грамматика",
        "answer": "____\n- способ описания формального языка, представляющего четверку\nΓ=⟨Σ,N,SεN,P⊂((Σ∪N)∗N(Σ∪N)∗)×(Σ∪N)∗⟩, где:\nΣ — алфавит, элементы которого называются терминалами;\nN — множество, элементы которого называются нетерминальными;\nS – начальный грамматический символ;\nP — множество правил производства (или производства) α -> β."
    },
    {
        "question": "Формальная грамматика",
        "answer": "____\nэто способ описания формального языка, представляющий четверку\nΓ=⟨Σ,N,SεN,P⊂((Σ∪N)∗N(Σ∪N)∗)×(Σ∪N)∗⟩, где:\nΣ — алфавит, элементы которого называются терминалами;\nN — множество, элементы которого называются нетерминальными;\nS – символ начала грамматики;\nP — множество правил вывода (англ. продукционных правил или продукций) α -> β."
    },
    {
        "question": "Сентенциальная форма",
        "answer": "____\nэто последовательность терминалов и нетерминалов, выводимых из начального символа."
    },
    {
        "question": "Форма предложения",
        "answer": "____ — это последовательность терминалов и нетерминалов, полученная из начального символа."
    },
    {
        "question": "Форма предложения",
        "answer": "____ — это последовательность терминалов и нетерминалов, производная от исходного символа."
    },
    {
        "question": "Форма предложения",
        "answer": "____\nэто последовательность терминалов и нетерминалов, полученных из исходного символа."
    },
    {
        "question": "Грамматика для правильной скобочной последовательности",
        "answer": "____\nΣ={(,)}\nS -> (S)\nS -> SS\nS -> ε"
    },
    {
        "question": "Грамматика для правильной последовательности скобок",
        "answer": "____ Σ={(,)} S -> (S) S -> SS S -> ε"
    },
    {
        "question": "Грамматика правильной последовательности скобок",
        "answer": "____ Σ={(,)} S -> (S) S -> SS S -> ε"
    },
    {
        "question": "Грамматика правильной последовательности скобок",
        "answer": "____\nΣ={(,)}\nС -> (С)\nС -> СС\nS -> ε"
    },
    {
        "question": "Регулярная (праволинейная) грамматика это",
        "answer": "____\nэто грамматика, которая содержит правила вида S -> ε (причем S не встречается в правых частях никаких правил), T_i -> a_i, T_i -> a_iT_j."
    },
    {
        "question": "Регулярная (праволинейная) грамматика — это",
        "answer": "____ — это грамматика, которая содержит правила вида S -> ε (где S не встречается в правых частях ни одного правила), T_i -> a_i, T_i -> a_iT_j."
    },
    {
        "question": "Регулярная (праволинейная) грамматика – это",
        "answer": "____ — это грамматика, содержащая правила вида S -> ε (где S не появляется справа от любого правила), T_i -> a_i, T_i -> a_iT_j."
    },
    {
        "question": "Регулярная (праволинейная) грамматика – это",
        "answer": "____\nэто грамматика, которая содержит правила вида S -> ε (и S не появляется справа от любого правила), T_i -> a_i, T_i -> a_iT_j."
    },
    {
        "question": "G_1 и G_2 - праволинейные. Построить G: L(G) = L(G_1) U L(G_2) (объединение):",
        "answer": "____\n1. Переименовать нетерминалы из N_1 и N_2, чтобы стало N_1 ∩ N_2 = ∅ (сделать α-преобразование). Применить переименовку к правилам G_1 и G_2\n2. Объявить стартовым символом свежий нетерминал S и для всех правил G_1 вида S_1 -> α и правил G_2 вида S_2 -> β, добавить правила S -> α, S-> β в правила G\n3. Добавить в правила G остальные правила из G_1 и G_2."
    },
    {
        "question": "G_1 и G_2 — прямолинейные. Построить G: L(G) = L(G_1) U L(G_2) (объединение):",
        "answer": "____\n1. Переименовать нетерминалы из N_1 и N_2 так, чтобы N_1 ∩ N_2 = ∅ (выполнить α-преобразование). Применить переименование к правилам G_1 и G_2\n2. Объявить новый нетерминал S начальным символом и для всех правил G_1 вида S_1 -> α и правил G_2 вида S_2 -> β добавить правила S -> α, S-> β к правилам G\n3. Добавить оставшиеся правила из G_1 и G_2 к правилам G."
    },
    {
        "question": "G_1 и G_2 прямые. Постройте G: L(G) = L(G_1) UL(G_2) (объединение):",
        "answer": "____\n1. Переименуйте нетерминалы N_1 и N_2 так, что N_1 ∩ N_2 = ∅ (выполните α-преобразование). Применить переименование к правилам G_1 и G_2\n2. Объявить новый нетерминал S в качестве начального символа и для всех правил G_1 вида S_1 -> α и правил G_2 вида S_2 -> β к правилам G добавить правила S -> α, S-> β.\n3. Добавьте оставшиеся правила из G_1 и G_2 в правила G."
    },
    {
        "question": "G_1 и G_2 линейны вправо. Постройте G: L(G) = L(G_1) UL(G_2) (объединение):",
        "answer": "____\n1. Переименуйте нетерминалы N_1 и N_2, чтобы они стали N_1 ∩ N_2 = ∅ (выполните α-преобразование). Применить переименование к правилам G_1 и G_2\n2. Объявить новый нетерминал S стартовым символом и для всех правил G_1 вида S_1 -> α и правил G_2 вида S_2 -> β добавить к правилам G правила S -> α, S-> β.\n3. Добавьте оставшиеся правила из G_1 и G_2 в правила G."
    },
    {
        "question": "G_1 и G_2 - праволинейные. Построить G: L(G) = L(G_1)L(G_2) (конкатенация):",
        "answer": "____\n1. Переименовать нетерминалы из N_1 и N_2, чтобы стало N_1 ∩ N_2 = ∅ (сделать α-преобразование).\n2. Построить из G_1 ее вариант без ε-правил\n3. По всякому прваилу из G_1 вида A -> a строим правило G вида A -> aS_2, где S_2 - стартовый нетерминал G_2\n4. Добавить в правила G остальные правила из G_1 и G_2. Объявить S_1 стартовым\n5. Если ε ∈ L(G_1) (до шага 2), то по всем S_2 -> β добавить правило S_1 -> β."
    },
    {
        "question": "G_1 и G_2 — прямолинейные. Построить G: L(G) = L(G_1)L(G_2) (конкатенация):",
        "answer": "____\n1. Переименовать нетерминалы из N_1 и N_2 так, чтобы N_1 ∩ N_2 = ∅ (выполнить α-преобразование).\n2. Построить его версию без ε-правил из G_1\n3. Для каждого правила из G_1 вида A -> a построить правило G вида A -> aS_2, где S_2 — начальный нетерминал G_2\n4. Добавить оставшиеся правила из G_1 и G_2 к правилам G. Объявить S_1 начальным\n5. Если ε ∈ L(G_1) (до шага 2), то для всех S_2 -> β добавить правило S_1 -> β."
    },
    {
        "question": "G_1 и G_2 прямые. Постройте G: L(G) = L(G_1)L(G_2) (конкатенация):",
        "answer": "____\n1. Переименуйте нетерминалы N_1 и N_2 так, что N_1 ∩ N_2 = ∅ (выполните α-преобразование).\n2. Постройте свою версию без ε-правил из G_1.\n3. Для каждого правила G_1 вида A -> a построить правило G вида A -> aS_2, где S_2 — начальный нетерминал G_2.\n4. Добавьте оставшиеся правила G_1 и G_2 к правилам G. Объявите S_1 исходным правилом.\n5. Если ε ∈ L(G_1) (до шага 2), то для всех S_2 -> β добавить правило S_1 -> β."
    },
    {
        "question": "G_1 и G_2 линейны вправо. Постройте G: L(G) = L(G_1)L(G_2) (конкатенация):",
        "answer": "____\n1. Переименуйте нетерминалы N_1 и N_2, чтобы они стали N_1 ∩ N_2 = ∅ (выполните α-преобразование).\n2. Построить по G_1 его версию без ε-правил.\n3. Для каждого правила G_1 вида A -> a строим правило G вида A -> aS_2, где S_2 — стартовый нетерминал G_2.\n4. Добавьте оставшиеся правила G_1 и G_2 к правилам G. Объявите S_1 как начало.\n5. Если ε ∈ L(G_1) (до шага 2), то для всех S_2 -> β добавить правило S_1 -> β."
    },
    {
        "question": "G_1 - праволинейная. Построить G: L(G) = L(G_1)+ (положительная итерация Клини):",
        "answer": "____\n1. Построить из G_1 её вариант без ε-правил\n2. По всякому правилу из G_1 вида A → a строим правило G вида A → aS_1, где S_1 — стартовый нетерминал G_1\n3. Добавить в правила G все (включая вида A → a) правила из G_1. Объявить S_1 стартовым\n4. Если ε ∈ L(G_1) (до шага 2), добавить правило S_1 → ε и вывести S1 из рекурсии"
    },
    {
        "question": "G_1 является праволинейной. Построение G: L(G) = L(G_1)+ (положительная итерация Клини):",
        "answer": "____\n1. Построить его версию без ε-правил из G_1\n2. Для каждого правила из G_1 вида A → a построить правило G вида A → aS_1, где S_1 — начальный нетерминал G_1\n3. Добавить все правила из G_1 (включая правила вида A → a) к правилам G. Объявить S_1 начальным\n4. Если ε ∈ L(G_1) (до шага 2), добавить правило S_1 → ε и вывести S1 из рекурсии"
    },
    {
        "question": "G_1 прямолинейный. Построение G: L(G) = L(G_1)+ (положительная итерация Клини):",
        "answer": "____\n1. Постройте свою версию без ε-правил из G_1.\n2. Для каждого правила G_1 вида A → a построить правило G вида A → aS_1, где S_1 — начальный нетерминал G_1.\n3. Добавить все правила G_1 (включая правила вида A → a) к правилам G. Объявить S_1 начальным\n4. Если ε ∈ L(G_1) (до шага 2), добавьте правило S_1 → ε и выведите S1 из рекурсии"
    },
    {
        "question": "G_1 - линейный правый. Постройте G: L(G) = L(G_1)+ (положительная итерация Клини):",
        "answer": "____\n1. Построить из G_1 его версию без ε-правил.\n2. Для любого правила G_1 вида A → a построим правило G вида A → aS_1, где S_1 — стартовый нетерминал G_1.\n3. Добавить к правилам G все правила (включая тип A → a) из G_1. Объявить S_1 как запуск\n4. Если ε ∈ L(G_1) (до шага 2), добавьте правило S_1 → ε и выведите S1 из рекурсии"
    },
    {
        "question": "G — праволинейная. Построить G′ без правил вида A → ε такую, что L(G′) = L(G) или L(G′) ∪ {ε} = L(G):",
        "answer": "____\n1. Перенести в G′ все правила G, не имеющие вид A → ε\n2. Если существует правило A → ε, то по всем правилам вида B → aA дополнительно строим правила B → a."
    },
    {
        "question": "G — праволинейный. Постройте G′ без правил вида A → ε так, чтобы L(G′) = L(G) или L(G′) ∪ {ε} = L(G):",
        "answer": "____\n1. Переносим в G′ все правила G, не имеющие вида A → ε\n2. Если есть правило A → ε, то для всех правил вида B → aA дополнительно строим правила B → a."
    },
    {
        "question": "Г – линейный правый. Построим G′ без правил вида A → ε так, чтобы L(G′) = L(G) или L(G′) ∪ {ε} = L(G):",
        "answer": "____\n1. Перенесем в G′ все правила G, не имеющие вида A → ε\n2. Если существует правило A → ε, то для всех правил вида B → aA дополнительно строим правила B → a."
    },
    {
        "question": "Г – линейный правый. Построим G′ без правил вида A → ε такой, что L(G′) = L(G) или L(G′) ∪ {ε} = L(G):",
        "answer": "____\n1. Перенести в G′ все правила G, не имеющие вида A → ε\n2. Если существует правило A → ε, то по всем правилам вида B → aA дополнительно строим правила B → a."
    },
    {
        "question": "G_1, G_2 — праволинейные. Построить G′ такую, что L(G′) = L(G_1) ∩ L(G_2):",
        "answer": "____\n1. Построить стартовый символ G′ — пару ⟨S_1, S_2⟩, где S_i — стартовый символ грамматики G_i\n2. Поместить ⟨S_1, S_2⟩ в множество U неразобранных нетерминалов. Множество T разобранных нетерминалов объявить пустым\n3. Для каждого очередного нетерминала ⟨A_1, A_2⟩ ∈ U:\n\t- если A_1 → a ∈ G_1, A_2 → a ∈ G_2, тогда добавить в G′ правило ⟨A_1, A_2⟩ → a;\n\t- если A_1 → aA_3 ∈ G_1, A_2 → aA_4 ∈ G_2, тогда добавить в G′ правило ⟨A_1, A_2⟩ → a⟨A_3, A_4⟩, а в U — нетерминал ⟨A_3, A_4⟩, если его ещё нет в множестве T;\n\t- если все пары правил, указанные выше, были обработаны, тогда переместить ⟨A_1, A_2⟩ из U в T\n4 Повторять шаг 3, пока множество U не пусто\n5 Если ε ∈ L(G_1) & ε ∈ L(G_2), тогда добавить в G′ правило ⟨S_1, S_2⟩ → ε."
    },
    {
        "question": "G_1, G_2 — праволинейные. Построим G′ так, чтобы L(G′) = L(G_1) ∩ L(G_2):",
        "answer": "____\n1. Построить начальный символ G′ — пару ⟨S_1, S_2⟩, где S_i — начальный символ грамматики G_i\n2. Поместить ⟨S_1, S_2⟩ в множество U неразобранных нетерминалов. Объявить множество T разобранных нетерминалов пустым\n3. Для каждого последующего нетерминала ⟨A_1, A_2⟩ ∈ U:\n- если A_1 → a ∈ G_1, A_2 → a ∈ G_2, то добавить правило ⟨A_1, A_2⟩ → a в G′;\n- если A_1 → aA_3 ∈ G_1, A_2 → aA_4 ∈ G_2, то добавляем в G′ правило ⟨A_1, A_2⟩ → a⟨A_3, A_4⟩, а в U — нетерминал ⟨A_3, A_4⟩, если его еще нет в множестве T;\n- если все пары правил, указанные выше, обработаны, то перемещаем ⟨A_1, A_2⟩ из U в T\n4 Повторяем шаг 3, пока множество U не опустеет\n5 Если ε ∈ L(G_1) & ε ∈ L(G_2), то добавляем в G′ правило ⟨S_1, S_2⟩ → ε."
    },
    {
        "question": "G_1, G_2 - линейный правый. Построим G′ так, что L(G′) = L(G_1) ∩ L(G_2):",
        "answer": "____\n1. Построить исходный символ G′ - пару ⟨S_1, S_2⟩, где S_i – начальный символ грамматики G_i.\n2. Поместите ⟨S_1, S_2⟩ в множество U неразобранных нетерминалов. Объявить пустым множество T анализируемых нетерминалов\n3. Для каждого следующего нетерминала ⟨A_1, A_2⟩ ∈ U:\n- если A_1 → a ∈ G_1, A_2 → a ∈ G_2, то добавить правило ⟨A_1, A_2⟩ → a в G′;\n- если A_1 → aA_3 ∈ G_1, A_2 → aA_4 ∈ G_2, то к G' добавить правило ⟨A_1, A_2⟩ → a⟨A_3, A_4⟩, а к U - нетерминал ⟨A_3, A_4⟩, если это это еще не так в множестве T;\n- если все указанные выше пары правил обработаны, то переместим ⟨A_1, A_2⟩ из U в T\n4 Повторяйте шаг 3, пока набор U не станет пустым.\n5 Если ε ∈ L(G_1) и ε ∈ L(G_2), то мы добавляем правило ⟨S_1, S_2⟩ → ε в G′."
    },
    {
        "question": "G_1, G_2 - линейный правый. Построим G′ такой, что L(G′) = L(G_1) ∩ L(G_2):",
        "answer": "____\n1. Построить стартовый символ G′ - пару ⟨S_1, S_2⟩, где S_i – стартовый символ грамматики G_i.\n2. Поместите ⟨S_1, S_2⟩ в множество U неразобранных нетерминалов. Множество анализируемых нетерминалов T объявляется пустым.\n3. Для каждого следующего нетерминала ⟨A_1, A_2⟩ ∈ U:\n\t- если A_1 → a ∈ G_1, A_2 → a ∈ G_2, то добавить к G′ правило ⟨A_1, A_2⟩ → a;\n\t- если A_1 → aA_3 ∈ G_1, A_2 → aA_4 ∈ G_2, то к G⟩ добавить правило ⟨A_1, A_2⟩ → a⟨A_3, A_4⟩, а к U - нетерминал ⟨A_3, A_4⟩, если это это еще не так в множестве T;\n\t- если все пары правил выше обработаны, переместите ⟨A_1, A_2⟩ из U в T\n4 Повторяйте шаг 3, пока набор U не станет пустым.\n5 Если ε ∈ L(G_1) и ε ∈ L(G_2), то добавьте правило ⟨S_1, S_2⟩ → ε в G′."
    },
    {
        "question": "Автоматы называются изоморфными",
        "answer": "____\nесли существует биекция между их вершинами такая, что сохраняются все переходы, терминальные состояния соответствуют терминальным, а начальные — начальным."
    },
    {
        "question": "Автоматы называются изоморфными.",
        "answer": "____\nесли между их вершинами существует биекция, при которой сохраняются все переходы, то конечные состояния соответствуют конечным, а начальные — начальным."
    },
    {
        "question": "Автоматы называются изоморфными.",
        "answer": "____\nесли между их вершинами существует биекция, в которой сохраняются все переходы, то конечные состояния соответствуют конечным состояниям, а начальные состояния соответствуют начальным состояниям."
    },
    {
        "question": "Автоматы называются изоморфными.",
        "answer": "____\nесли между их вершинами существует биекция, такая что все переходы сохраняются, терминальные состояния соответствуют терминальным состояниям, а начальные состояния соответствуют начальным состояниям."
    },
    {
        "question": "Задано два детерминированных конечных автомата. Определить, изоморфны ли они друг другу. Гарантируется, что все состояния автоматов достижимы.",
        "answer": "____\nАлгоритм\nИз определения следует, что если автоматы изоморфны, то можно их состояния занумеровать одним способом так, что вершины из разных автоматов с одинаковыми номерами будут равны — то есть в каждом из этих двух состояний существует переход в какое-то состояние с таким же номером, что и переход по этой же букве в другом состоянии. Поэтому мы можем зафиксировать какую-то нумерацию, например, в порядке обхода в глубину по символам в лексикографическом порядке и просто проверить состояния с одинаковыми номерами на равенство. Если все состояния будут равны, то автоматы будут равны, в нашем случае будет следовать изоморфизм двух автоматов. Асимптотика алгоритма совпадает с асимптотикой обхода в глубину, то есть O(N+M), где N — суммарное число вершин в автоматах, M — суммарное число ребер.\n\nПсевдокод\nTransitions — множество пар ⟨a, T⟩ , где a∈Σ, T∈Q\nAssotiations — массив, где каждому состоянию первого автомата соответствует найденное состояние второго автомата.\n\nboolean dfs(u: Vertex, v: Vertex): \n   visited[u] = true   // заметим, что достаточно только одного массива visited на два автомата\n   \n   if (v.terminal != u.terminal)\n     return false   \n   associations[u] = v\n   boolean result = true\n   for (⟨c,q⟩ : u.transitions)      \n     Vertex t1 = u.transitions.getVertex(c)\n     Vertex t2 = v.transitions.getVertex(c)\n     if одна из вершин t1, t2 дьявольская, а другая — нет\n       return false\n     if (visited[t1]) \n       result = result and t2 == associations[t1]\n     else\n       result = result and dfs(t1, t2)                \n         \n   return result"
    },
    {
        "question": "Даны два детерминированных конечных автомата, определить, являются ли они изоморфными друг другу. Гарантируется, что все состояния автоматов достижимы.",
        "answer": "____\nАлгоритм\nИз определения следует, что если автоматы изоморфны, то их состояния можно пронумеровать одним способом так, чтобы вершины из разных автоматов с одинаковыми номерами были равны — то есть в каждом из этих двух состояний был переход в некоторое состояние с тем же номером, что и переход по той же букве в другом состоянии. Поэтому мы можем зафиксировать некоторую нумерацию, например, в порядке обхода в глубину по символам в лексикографическом порядке и просто проверять состояния с одинаковыми номерами на равенство. Если все состояния равны, то и автоматы будут равны, в нашем случае будет изоморфизм двух автоматов. Асимптотика алгоритма совпадает с асимптотикой обхода в глубину, то есть O(N+M), где N — общее число вершин в автоматах, M — общее число ребер.\n\nПсевдокод\nПереходы — это набор пар ⟨a, T⟩, где a∈Σ, T∈Q\nАссоциации — это массив, где каждое состояние первого автомата соответствует найденному состоянию второго автомата.\n\nboolean dfs(u: Vertex, v: Vertex): \nvisited[u] = true // обратите внимание, что для двух автоматов достаточно только одного посещенного массива\n\nif (v.terminal != u.terminal)\nreturn false \nassociations[u] = v\nboolean result = true\nfor (⟨c,q⟩ : u.transitions) \nVertex t1 = u.transitions.getVertex(c)\nVertex t2 = v.transitions.getVertex(c)\nесли одна из вершин t1, t2 дьявольская, а другая нет\nreturn false\nif (visited[t1]) \nresult = result and t2 == associations[t1]\nelse\nresult = result and dfs(t1, t2) \n\nreturn result"
    },
    {
        "question": "Даны два детерминированных конечных автомата. Определите, изоморфны ли они друг другу. Гарантируется, что все состояния автоматов доступны.",
        "answer": "____\nАлгоритм\nИз определения следует, что если автоматы изоморфны, то их состояния можно пронумеровать так, чтобы вершины разных автоматов с одинаковыми номерами были равны, т. е. в каждом из этих двух состояний произошел переход в состояние с тем же номером, что и переход по той же букве в другое состояние. Поэтому мы можем подкорректировать нумерацию, например, в порядке обхода в глубину по символам в лексикографическом порядке, и просто проверить равенство состояний с одинаковыми номерами. Если все состояния равны, то и автоматы будут равны; в нашем случае будет изоморфизм двух автоматов. Асимптотика алгоритма совпадает с асимптотикой обхода в глубину, т.е. O(N+M), где N — общее количество вершин в автоматах, M — общее количество ребер.\n\nПсевдокод\nПереходы представляют собой набор пар ⟨a, T⟩, где aεΣ, TεQ\nАссоциации представляют собой таблицу, где каждому состоянию первого автомата соответствует найденное состояние второго автомата.\n\nлогическое значение dfs (u: вершина, v: вершина): \nvisit[u] = true // обратите внимание, что для двух машин достаточно одной посещенной таблицы\n\nесли (v.терминал != u.терминал)\nвернуть ложь \nассоциации[u] = v\nлогический результат = истина\nдля (⟨c,q⟩: u.transitions) \nВершина t1 = u.transitions.getVertex(c)\nВершина t2 = v.transitions.getVertex(c)\nесли одна из вершин t1, t2 злая, а другая нет\nвернуть ложь\nесли (посещение[t1]) \nрезультат = результат и t2 == ассоциации[t1]\nдругой\nрезультат = результат и dfs(t1, t2) \n\nвернуть результат"
    },
    {
        "question": "Указаны два детерминированных конечных автомата. Определите, изоморфны ли они друг другу. Гарантируется, что все состояния автоматов доступны.",
        "answer": "____\nАлгоритм\nИз определения следует, что если автоматы изоморфны, то их состояния можно пронумеровать так, чтобы вершины разных автоматов с одинаковыми номерами были равны, т. е. в каждом из этих двух состояний происходит переход в состояние с тем же номером, что и переход по той же букве в другое состояние. Поэтому мы можем зафиксировать какую-то нумерацию, например, в порядке обхода символов в глубину в лексикографическом порядке и просто проверять равенство состояний с одинаковыми номерами. Если все состояния равны, то и автоматы будут равны; в нашем случае будет следовать изоморфизм двух автоматов. Асимптотика алгоритма совпадает с асимптотикой обхода в глубину, т. е. O(N+M), где N — общее количество вершин в автоматах, M — общее количество ребер.\n\nПсевдокод\nПереходы — совокупность пар ⟨a, T⟩, где aεΣ, TεQ\nАссоциации — это таблица, где каждому состоянию первого автомата соответствует найденное состояние второго автомата.\n\nлогическое значение dfs (u: вершина, v: вершина): \n   visit[u] = true // обратите внимание, что одного посещенного массива достаточно для двух машин\n   \n   если (v.терминал != u.терминал)\n     вернуть ложь   \n   ассоциации[u] = v\n   логический результат = истина\n   для (⟨c,q⟩: u.transitions)      \n     Вершина t1 = u.transitions.getVertex(c)\n     Вершина t2 = v.transitions.getVertex(c)\n     если одна из вершин t1, t2 злая, а другая нет\n       вернуть ложь\n     если (посещение[t1]) \n       результат = результат и t2 == ассоциации[t1]\n     другой\n       результат = результат и dfs(t1, t2)                \n         \n   вернуть результат"
    },
    {
        "question": "Полукольцо S = ⟨A, ⊕, ⊗, 0⟩ над носителем A",
        "answer": "____\nэто алгебраическая структура такая, что:\nS — коммутативный моноид по ⊕;\nS — полугруппа по ⊗;\n0 — это id по сложению и ноль по умножению;\nвыполнены левая и правая дистрибутивности."
    },
    {
        "question": "Полукольцо S = ⟨A, ⊕, ⊗, 0⟩ над носителем A",
        "answer": "____\nявляется алгебраической структурой, такой что:\nS является коммутативным моноидом относительно ⊕;\nS является полугруппой относительно ⊗;\n0 является id относительно сложения и нулем относительно умножения;\nсправедливы левая и правая дистрибутивности."
    },
    {
        "question": "Полукольцо S = ⟨A, ⊕, ⊗, 0⟩ на носителе A",
        "answer": "____\nявляется алгебраической структурой такой, что:\nS — моноид, коммутативный относительно ⊕;\nS — полугруппа относительно ⊗;\n0 — идентификатор при сложении и ноль при умножении;\nсправедливы как левые, так и правые распределения."
    },
    {
        "question": "Полукольцо S = ⟨A, ⊕, ⊗, 0⟩ на носителе A",
        "answer": "____\nявляется алгебраической структурой такой, что:\nS — моноид, коммутативный относительно ⊕;\nS — полугруппа относительно ⊗;\n0 — идентификатор сложения и ноль — умножения;\nлевая и правая дистрибутивность соблюдена."
    },
    {
        "question": "Алгебра Клини ⟨Σ, |, ·, ∗, ∅, ε⟩",
        "answer": "____\nидемпотентное полукольцо с единицей, удовлетворяющее следующим аксиомам:\n1) x∗x + 1 = x∗ = 1 + xx∗(аксиома развёртки)\n2) (формализация Саломаа, Sal): ∀p, q, x ((p | qx = x ⇒ x = q∗p) & (p | xq = x ⇒ x = pq∗)), где q не распознаёт ε — левая и правая леммы Ардена;\n3) (формализация Козена, Koz): ∀p, q, x ((q | px <= x ⇒ p∗q <= x) & (q | xp <= x ⇒ qp∗ <= x)), где x <= y ⇔ x | y = y, x = y ⇔ x <= y & y <= x.\n\nАксиома -- Сокращение\nx | x = x -- (Idm)\nε | xx∗ = x∗,  ε | x∗x = x∗ -- (Unfold) \n(x | y)z = xz | yz, x(y | z) = xy | xz -- (Dstr) \nq | px <= x ⇒ p∗q <= x, q | xp <= x ⇒ qp∗ <= x -- (Koz)"
    },
    {
        "question": "Алгебра Клини ⟨Σ, |, ·, ∗, ∅, ε⟩",
        "answer": "____\nидемпотентное полукольцо с единицей, удовлетворяющее следующим аксиомам:\n1) x∗x + 1 = x∗ = 1 + xx∗(аксиома развёртывания)\n2) (формализация Саломаа, Sal): ∀p, q, x ((p | qx = x ⇒ x = q∗p) & (p | xq = x ⇒ x = pq∗)), где q не распознаёт ε — левая и правая леммы Ардена;\n3) (формализация Козена, Koz): ∀p, q, x ((q | px <= x ⇒ p∗q <= x) & (q | xp <= x ⇒ qp∗ <= x)), где x <= y ⇔ x | y = y, x = y ⇔ x <= y & y <= x.\n\nАксиома -- Аббревиатура x | Икс знак равно Икс -- (Idm) ε | xx∗ = x∗, ε | x∗x = x∗ -- (Развернуть) (x | y)z = xz | yz, x(y | z) = xy | xz -- (Dstr)q | px <= x ⇒ p∗q <= x, q | xp <= x ⇒ qp∗ <= x -- (Коз)"
    },
    {
        "question": "Алгебра Клини ⟨Σ, |, ·, ∗, ∅, ε⟩",
        "answer": "____\nидемпотентное полукольцо с единицей, удовлетворяющей следующим аксиомам:\n1) x∗x + 1 = x∗ = 1 + xx∗ (аксиома разворачивания)\n2) (формализация Саломаа, Сала): ∀p, q, x ((p | qx = x ⇒ x = q∗p) & (p | xq = x ⇒ x = pq∗)), где q не распознает ε - левая и правая леммы Ардена;\n3) (формализация Козена, Коза): ∀p, q, x ((q | px <= x ⇒ p∗q <= x) & (q | xp <= x ⇒ qp∗ <= x)), где x <= у ⇔ х | y = y, x = y ⇔ x <= y & y <= x.\n\nАксиома -- Аббревиатура x | Икс знак равно Икс -- (Idm) ε | xx∗ = x∗, ε | x∗x = x∗ -- (Развернуть) (x | y)z = xz | yz, x(y | z) = xy | xz -- (Dstr)q | px <= x ⇒ p∗q <= x, q | xp <= x ⇒ qp∗ <= x -- (Коза)"
    },
    {
        "question": "Алгебра Клини ⟨Σ, |, ·, ∗, ∅, ε⟩",
        "answer": "____\nидемпотентное полукольцо с единицей, удовлетворяющей следующим аксиомам:\n1) x∗x + 1 = x∗ = 1 + xx∗ (аксиома сканирования)\n2) (формализация Саломаа, Сала): ∀p, q, x ((p | qx = x ⇒ x = q∗p) & (p | xq = x ⇒ x = pq∗)), где q не распознает ε - левая и правая леммы Ардена;\n3) (формализация Козена, Коза): ∀p, q, x ((q | px <= x ⇒ p∗q <= x) & (q | xp <= x ⇒ qp∗ <= x)), где x <= у ⇔ х | y = y, x = y ⇔ x <= y & y <= x.\n\nАксиома – сокращение\nХ | х = х -- (То же самое)\nε | xx∗ = x∗, ε | x∗x = x∗ -- (Развернуть) \n(х | у)z = xz | yz, x(y | z) = xy | xz -- (Дстр) \nд | px <= x ⇒ p∗q <= x, q | xp <= x ⇒ qp∗ <= x -- (Коз)"
    },
    {
        "question": "Некоторые теоремы алгебры Клини и их приминения",
        "answer": "____\n(Bsm) ax = xb ⇒ a∗x = xb∗ (Бисимуляция)\n(Sld) x(yx)∗ = (xy)∗x (Сдвиг)\n(Dnst) x∗(yx∗)∗ = (x | y)∗ (Уплощение)\n\nЗаконы сдвига и уплощения используются в оптимизациях\nрегулярных событий: закон сдвига позволяет перестраивать циклы с поствычислениями в циклы с предвычислениями; закон уплощения позволяет перестраивать друг в друга вложенные циклы и циклы с условиями внутри итерации."
    },
    {
        "question": "Некоторые теоремы алгебры Клини и их приложения",
        "answer": "____\n(Bsm) ax = xb ⇒ a∗x = xb∗ (Бисимуляция)\n(Sld) x(yx)∗ = (xy)∗x (Сдвиг)\n(Dnst) x∗(yx∗)∗ = (x | y)∗ (Сглаживание)\n\nЗаконы сдвига и выравнивания используются при оптимизации\nрегулярных событий: закон сдвига позволяет циклам с последующими вычислениями перестраиваться в циклы с предварительными вычислениями; закон выравнивания позволяет вложенным циклам и циклам с условиями внутри итерации перестраиваться друг в друга."
    },
    {
        "question": "Некоторые теоремы алгебры Клини и их приложения",
        "answer": "____\n(Bsm) ax = xb ⇒ a∗x = xb∗ (бисимуляция)\n(Sld) x(yx)∗ = (xy)∗x (Сдвиг)\n(Dnst) x∗(yx∗)∗ = (x | y)∗ (Сглаживание)\n\nЗаконы сдвига и выравнивания используются при оптимизации.\nрегулярные события: закон сдвига позволяет реорганизовать циклы с последующими вычислениями в циклы с предшествующими вычислениями; Закон выравнивания позволяет вложенным циклам и циклам с условиями внутри итерации перестраиваться друг в друге."
    },
    {
        "question": "Некоторые теоремы алгебры Клини и их приложения",
        "answer": "____\n(Bsm) ax = xb ⇒ a∗x = xb∗ (бисимуляция)\n(Sld) x(yx)∗ = (xy)∗x (Сдвиг)\n(Dnst) x∗(yx∗)∗ = (x | y)∗ (сглаживание)\n\nЗаконы сдвига и эксцесса используются при оптимизации.\nрегулярные события: закон сдвига позволяет перестраивать циклы с пострасчетами в циклы с предрасчетами; Закон сглаживания позволяет переставлять вложенные циклы и циклы с условиями внутри итерации друг в друга."
    },
    {
        "question": "Теорема о полноте Sal и Koz (формализация Саломаа и Козена)",
        "answer": "____\nЛюбое равенство регулярных выражений выводимо из аксиоматики Sal и аксиоматики Koz."
    },
    {
        "question": "Теорема о полноте Сала и Коза (формализация Саломаа и Козена)",
        "answer": "____\nЛюбое равенство регулярных выражений выводится из аксиоматики Сала и аксиоматики Коза."
    },
    {
        "question": "Теорема Салы и Коза о полноте (формализация Саломаа и Коза)",
        "answer": "____\nВсе равенства регулярных выражений выводятся из аксиоматики Сала и аксиоматики Коза."
    },
    {
        "question": "Теорема о пополнении Сала и Коза (формализация Саломаа и Козена)",
        "answer": "____\nЛюбое равенство регулярных выражений можно вывести из аксиоматики Сала и аксиоматики Коза."
    },
    {
        "question": "Смысл леммы Ардена и Козена",
        "answer": "____\nНеподвижная точка функции f(x) — такое x, что f(x) = x.\nПусть X = (pX) | q, где X — неизвестное RE, а p, q — известные, причём ε не принадлежит L(p). Тогда X = (p)∗q.\nТо есть p∗q — наименьшая (но не единственная) неподвижная точка выражения px | q по отношению <=, и единственная, если ε не принадлежит L(p).\nРассмотрим систему уравнений:\nX1 = (A_11X_1) | (A_12X_2) | . . . | B_1\nX2 = (A_21X_1) | (A_22X_2) | . . . | B_2\n. . .\nXn = (A_n1X_1) | (A_n2X_2) | . . . | B_n\nПоложим ε не принадлежит A_ij. Выразим X_1 через X_2, . . . , X_n, X_2 через X_3. . . X_n и т.д. Получим регулярное выражение для X_n (и после обратных подстановок также для X_n-1,. . . ,X_1)."
    },
    {
        "question": "Значение леммы Ардена и Козена",
        "answer": "____\nНеподвижная точка f(x) — это x, такой что f(x) = x.\nПусть X = (pX) | q, где X — неизвестное RE, а p, q известны, и ε не принадлежит L(p). Тогда X = (p)∗q.\nТо есть, p∗q — наименьшая (но не единственная) неподвижная точка px | q относительно <=, и единственная, если ε не принадлежит L(p).\nРассмотрим систему уравнений:\nX1 = (A_11X_1) | (A_12X_2) | . . . | B_1\nX2 = (A_21X_1) | (A_22X_2) | . . . | B_2\n. . .\nXn = (A_n1X_1) | (A_n2X_2) | . . . | B_n\nПредположим, что ε не принадлежит A_ij. Выразим X_1 через X_2, . . , X_n, X_2 через X_3. . . X_n и т. д. Получим регулярное выражение для X_n (а после обратных подстановок и для X_n-1,. . . ,X_1)."
    },
    {
        "question": "Смысл леммы Ардена и Козена.",
        "answer": "____\nНеподвижная точка f(x) — это x такая, что f(x) = x.\nПусть X = (pX) | q, где X — неизвестная RE, p, q известны и ε не принадлежит L(p). Тогда X = (p)∗q.\nДругими словами, p∗q — это наименьшая (но не единственная) неподвижная точка px | q относительен <= и уникален, если ε не принадлежит L(p).\nРассмотрим систему уравнений:\nХ1 = (А_11Х_1) | (A_12X_2) | . . . | Б_1\nХ2 = (А_21Х_1) | (A_22X_2) | . . . | Б_2\n. . .\nХп = (А_n1X_1) | (А_n2X_2) | . . . | Б_н\nПредположим, что ε не принадлежит A_ij. Выразим X_1 в X_2, . . , X_n, от X_2 до X_3. . . Х_н и т. д. Получаем регулярное выражение для X_n (и после обратных замен на X_n-1,...,X_1)."
    },
    {
        "question": "Смысл леммы Ардена и Козена.",
        "answer": "____\nНеподвижной точкой функции f(x) является такой x, что f(x) = x.\nПусть X = (pX) | q, где X — неизвестная RE, p, q известны и ε не принадлежит L(p). Тогда X = (p)∗q.\nДругими словами, p∗q — это наименьшая (но не единственная) неподвижная точка выражения px | q относительно <= и единственно, если ε не принадлежит L(p).\nРассмотрим систему уравнений:\nХ1 = (А_11Х_1) | (A_12X_2) | . . . | Б_1\nХ2 = (А_21Х_1) | (A_22X_2) | . . . | Б_2\n. . .\nХп = (А_n1X_1) | (А_n2X_2) | . . . | Б_н\nПредположим, что ε не принадлежит A_ij. Выразим X_1 в X_2, . . . , X_n, от X_2 до X_3. . . Х_н и т. д. Получаем регулярное выражение для X_n (а после обратных подстановок и для X_n-1,...,X_1)."
    },
    {
        "question": "формальные определения LR(k)-грамматик",
        "answer": "____\nLR(k)-грамматика - это вид грамматики, которая использует два вида productions (правил):\n1. Left-to-right (LR) - справа налево, где каждый символ справа в левой части правила должен быть заменен символом слева в правой части правила.\n2. Right-to-left (RL) - слева направо, где каждый символ слева в правой части правила должен быть заменен символом справа в левой части правила.\n\n LR(k)-грамматика имеет следующее формальное определение:\n\n* Начало грамматики: S\n* Контекст-независимые терминалы: T\n* Контекст-зависимые терминалы: V\n* Non-terminal symbols (символы не терминалов): N\n* Productions (правила): P\n\n LR(k)-грамматика определяется как 5-튜пл (S, T, V, N, P), где:\n\n1. S - начало грамматики (initial symbol)\n2. T - контекст-независимые терминалы (terminals)\n3. V - контекст-зависимые терминалы (non-terminals)\n4. N - не терминалы (non-terminals)\n5. P - productions (правила)\n\n LR(k)-грамматика называется к-ограниченной, если для любого правила P в грамматике существуют такие числа i и j, что:\n\n1. P: A → αβ, где α ∈ (V ∪ T)* и β ∈ (V ∪ T)k+1\n2. i ≤ |α| ≤ k и j ≤ |β| ≤ k+1\n\nВот несколько примеров LR(1)-грамматики:\n\n1. S → aA | bB\nA → aA | ε\nB → bB | ε\n\n2. S → aA | bB\nA → aAa | aa\nB → bBb | bb\n\nВ этих примерах LR(1)-грамматика определяется как 5-튜пл (S, T, V, N, P), где:\n\n* S - начало грамматики (initial symbol)\n* T - контекст-независимые терминалы (terminals): {a, b}\n* V - контекст-зависимые терминалы (non-terminals): {A, B}\n* N - не терминалы (non-terminals): {A, B}\n* P - productions (правила):\n\n1. P1: S → aA\nP2: S → bB\nP3: A → aA\nP4: A → ε\nP5: B → bB\nP6: B → ε\n\n LR(1)-грамматика используется в компиляторах для анализа синтаксиса языка программирования и для generation кода компилятора."
    },
    {
        "question": "формальные определения LR(k)-грамматик",
        "answer": "____\nLR(k)-грамматика — это тип грамматики, который использует два типа производств (правил):\n1. Слева направо (LR) — справа налево, где каждый символ справа левой стороны правила должен быть заменен символом слева правой стороны правила.\n2. Справа налево (RL) — слева направо, где каждый символ слева правой стороны правила должен быть заменен символом справа левой стороны правила.\n\nLR(k)-грамматика имеет следующее формальное определение:\n\n* Начальный символ грамматики: S\n* Контекстно-свободные терминалы: T\n* Контекстно-зависимые терминалы: V\n* Нетерминальные символы: N\n* Продукции: P\n\nLR(k)-грамматика определяется как 5-терминальная грамматика (S, T, V, N, P), где:\n\n1. S — начальный символ грамматики\n2. T — контекстно-свободные терминалы\n3. V — контекстно-зависимые терминалы\n4. N — нетерминалы\n5. P — продукции\n\nLR(k)-грамматика называется k-ограниченной, если для любого правила P в грамматике существуют такие числа i и j, что:\n\n1. P: A → αβ, где α ∈ (V ∪ T)* и β ∈ (V ∪ T)k+1\n2. i ≤ |α| ≤ k и j ≤ |β| ≤ k+1\n\nВот несколько примеров грамматики LR(1):\n\n1. S → aA | bB\nA → aA | ε\nB → bB | ε\n\n2. S → aA | bB\nA → aAa | aa\nB → bBb | bb\n\nВ этих примерах грамматика LR(1) определяется как 5-튜пл (S, T, V, N, P), где:\n\n* S — начальный символ грамматики\n* T — контекстно-свободные терминалы: {a, b}\n* V — контекстно-зависимые терминалы (нетерминалы): {A, B}\n* N — нетерминалы: {A, B}\n* P — продукции (правила):\n\n1. P1: S → aA\nP2: S → bB\nP3: A → aA\nP4: A → ε\nP5: B → bB\nP6: B → ε\n\nГрамматика LR(1) используется в компиляторах для анализа синтаксиса языка программирования и генерации кода компилятора."
    },
    {
        "question": "формальные определения LR(k)-грамматик",
        "answer": "____\nГрамматика LR(k) — это тип грамматики, который использует два типа продукций (правил):\n1. Слева направо (LR) — справа налево, где каждый символ справа от левой стороны линейки должен быть заменен символом слева от правой стороны линейки.\n2. Справа налево (RL) — слева направо, где каждый символ слева от правой стороны линейки должен быть заменен символом справа от левой стороны линейки.\n\nГрамматика LR(k) имеет следующее формальное определение:\n\n* Начальный грамматический символ: S\n*Терминалы без контекста:T\n*Контекстные терминалы:V\n*Нетерминальные символы: N\n*Продукты: П\n\nГрамматика LR(k) определяется как грамматика с 5 терминалами (S, T, V, N, P), где:\n\n1. S – начальный грамматический символ\n2. Т – контекстно-свободные терминалы\n3. V – контекстные терминалы\n4. Н – нетерминалы\n5. П-продукты\n\nГрамматика LR(k) называется k-ограниченной, если для любого правила P в грамматике существуют числа i и j такие, что:\n\n1. P: A → αβ, где α ∈ (V ∪ T)* и β ∈ (V ∪ T)k+1.\n2. я ≤ |α| ≤ k и j ≤ |β| ≤к+1\n\nВот несколько примеров грамматики LR(1):\n\n1. S → аА | ББ\nА → аА | ε\nБ → ББ | ε\n\n2. S → аА | ББ\nА → аАа | аа\nБ → бБб | бб\n\nВ этих примерах грамматика LR(1) определяется как 5-튜pl (S, T, V, N, P), где:\n\n*S — символ начала грамматики\n* T — контекстно-свободные терминалы: {a, b}\n* V — контекстные терминалы (нетерминалы): {A, B}\n* N - нетерминалы: {A, B}\n* П – продукция (правила):\n\n1. P1: S → аА\nP2: S → bB\nP3: А → аА\nP4: А → ε\nP5: B → bB\nP6: B → ε\n\nГрамматика LR(1) используется в компиляторах для анализа синтаксиса языка программирования и генерации кода компилятора."
    },
    {
        "question": "формальные определения LR(k)-грамматик",
        "answer": "____\nLR(k)-грамматика — это тип грамматики, использующий два типа продукций (правил):\n1. Слева направо (LR) – справа налево, где каждый символ справа на левой стороне линейки должен быть заменен на символ слева на правой стороне линейки.\n2. Справа налево (RL) – слева направо, где каждый символ слева в правой части линейки должен быть заменен символом справа в левой части линейки.\n\n Грамматика LR(k) имеет следующее формальное определение:\n\n* Начало грамматики: S\n* Контекстно-независимые терминалы: T\n*Контекстные терминалы:V\n*Нетерминальные символы: N\n* Постановки (правила): P\n\n Грамматика LR(k) определяется как 5-튜pl (S, T, V, N, P), где:\n\n1. S – начало грамматики (начальный символ)\n2. Т – контекстно-независимые терминалы\n3. V – контекстно-зависимые терминалы (нетерминалы)\n4. Н – нетерминалы\n5. П – постановки (правила)\n\n Грамматика LR(k) называется k-ограниченной, если для любого правила P в грамматике существуют числа i и j такие, что:\n\n1. P: A → αβ, где α ∈ (V ∪ T)* и β ∈ (V ∪ T)k+1.\n2. я ≤ |α| ≤ k и j ≤ |β| ≤к+1\n\nВот несколько примеров грамматики LR(1):\n\n1. S → аА | ББ\nА → аА | ε\nБ → ББ | ε\n\n2. S → аА | ББ\nА → аАа | аа\nБ → бБб | бб\n\nВ этих примерах грамматика LR(1) определяется как 5-튜pl (S, T, V, N, P), где:\n\n*S - начало грамматики (начальный символ)\n* T — контекстно-независимые терминалы: {a, b}\n* V - контекстно-зависимые терминалы (нетерминалы): {A, B}\n* N - нетерминалы: {A, B}\n* П - постановки (правила):\n\n1. P1: S → аА\nP2: S → bB\nP3: А → аА\nP4: А → ε\nP5: B → bB\nP6: B → ε\n\n Грамматика LR(1) используется в компиляторах для анализа синтаксиса языка программирования и генерации кода компилятора."
    },
    {
        "question": "Гарранитрует ли  LR(k)-грамматика однозначность разбора ?",
        "answer": "____\nLR(k)-грамматика не обязательно гарантирует однозначность разбора.\n\nLR(k)-грамматика — это тип грамматики, который обеспечивает левую рекурсию и является рекурсивным по правой части. Это означает, что LR(k)-грамматика может иметь правые рекурсивные правила, которые повторяются на каждой правой части, а также левую рекурсию, что означает, что правая часть может быть повторена в более глубокой грамматике. LR-обработчик (алийзер) использует для анализа вводимые к эндавардам.LR-предполагает, что анализ будет производиться шаг за шагом вправо, а использование не требуется.LR(к)-грамматика – это расширение LR-обработчика, которое поддерживает к-корпуса или c-корпуса в правой части правила. Это позволяет обработчику посмотреть на k символов вперед и принимать решения о том, следует ли продолжать анализ в текущем положении или сделать сброс.\n\nОднако LR(k)-грамматика не гарантирует однозначности разбора, поскольку грамматика может иметьAmbiguous syntax илиConflicting parses. Это означает, что может быть несколько возможных синтаксических анализов того же потока символов. В таких случаях LR-обработчик должен использовать некоторую стратегию для выбора, какой анализ использовать или какие решения принять в связи с конфликтом.\n\nLR-обработчик может использовать стратегии, такие как FIRST/FOLLOW-приведение, шаблон первого случая, программирование двумя конфликтами и другие, чтобы справиться с случаями конфликта. Актуальность использования грамматики LR(к) в программе обработки определяется ее практическими потребностями."
    },
    {
        "question": "Гарантирует ли грамматика LR(k) однозначный синтаксический анализ?",
        "answer": "____\nГрамматика LR(k) не обязательно гарантирует однозначный разбор.\n\nГрамматика LR(k) — это тип грамматики, которая является левой рекурсией и правой рекурсией. Это означает, что грамматика LR(k) может иметь правые рекурсивные правила, которые повторяются в каждой правой части, а также левую рекурсию, что означает, что правая часть может повторяться в более глубокой грамматике. Процессор LR использует входные k конечных слов для разбора. LR предполагает, что разбор будет выполняться пошагово вправо, и использование конечных слов не требуется. Грамматика LR(k) — это расширение процессора LR, которое поддерживает k-корпуса или c-корпуса в правой части правила. Это позволяет процессору просматривать k символов вперед и принимать решения о том, продолжать ли разбор в текущей позиции или выполнить сброс.\n\nОднако грамматика LR(k) не гарантирует однозначного разбора, поскольку грамматика может иметь неоднозначный синтаксис или конфликтующие разборы. Это означает, что может быть несколько возможных разборов одного и того же потока символов. В таких случаях процессор LR должен использовать некоторую стратегию для выбора того, какой разбор использовать или какие решения принимать в ответ на конфликт.\n\nПроцессор LR может использовать такие стратегии, как приведение FIRST/FOLLOW, шаблон первого случая, программирование с двойным конфликтом и другие, чтобы справляться с конфликтными случаями. Актуальность использования грамматики LR(k) в программе процессора определяется ее практическими потребностями."
    },
    {
        "question": "Гарантирует ли грамматика LR(k) однозначный анализ?",
        "answer": "____\nГрамматика LR(k) не обязательно гарантирует однозначный анализ.\n\nГрамматика LR(k) — это тип грамматики, которая представляет собой левую и правую рекурсию. Это означает, что грамматика LR(k) может иметь правила праворекурсии, которые повторяются в каждой правой части, а также левую рекурсию, что означает, что правая часть может повторяться в более глубокой грамматике. Процессор LR использует для анализа последние k входных слов. LR предполагает, что анализ будет выполняться шаг за шагом вправо и что использование конечных слов не требуется. Грамматика LR(k) является расширением процессора LR, которое поддерживает k-корпуса или c-корпуса в правой части правила. Это позволяет процессору дождаться k символов и принять решение о том, продолжать ли сканирование в текущей позиции или выполнить сброс.\n\nОднако грамматика LR(k) не гарантирует однозначный синтаксический анализ, поскольку грамматика может иметь неоднозначный синтаксис или противоречивый синтаксический анализ. Это означает, что может быть несколько возможных анализов одного и того же потока символов. В таких случаях процессор LR должен использовать стратегию, чтобы выбрать, какой анализ использовать или какие решения принять в ответ на конфликт.\n\nПроцессор LR может использовать такие стратегии, как преобразование FIRST/FOLLOW, шаблон первого случая, программирование двойного конфликта и другие для обработки случаев конфликта. Актуальность использования LR(k)-грамматики в процессорной программе определяется ее практическими потребностями."
    },
    {
        "question": "Гарантирует ли грамматика LR(k) однозначный анализ?",
        "answer": "____\nГрамматика LR(k) не обязательно гарантирует однозначный анализ.\n\nГрамматика LR(k) — это тип грамматики, который обеспечивает левую рекурсию и является праворекурсивной. Это означает, что грамматика LR(k) может иметь правила праворекурсии, которые повторяются с каждой правой стороны, а также левую рекурсию, что означает, что правая часть может повторяться в более глубокой грамматике. Обработчик LR (alizer) использует входные данные до конца для анализа. LR предполагает, что анализ будет выполняться пошагово вправо и использование не требуется. Грамматика LR(k) является расширением менеджера LR. поддерживает k-корпуса или c-корпуса в правой части правила. Это позволяет обработчику просматривать k символов вперед и принимать решения о том, продолжать ли сканирование в текущей позиции или выполнить сброс.\n\nОднако грамматика LR(k) не гарантирует однозначный синтаксический анализ, поскольку грамматика может иметь неоднозначный синтаксис или противоречивый синтаксический анализ. Это означает, что может быть несколько возможных анализов одного и того же потока символов. В таких случаях процессор LR должен использовать некоторую стратегию, чтобы выбрать, какой анализ использовать или какие решения принять в отношении конфликта.\n\nМенеджер LR может использовать такие стратегии, как преобразование FIRST/FOLLOW, модель первого случая, планирование двух конфликтов и другие, для обработки конфликтных ситуаций. Уместность использования LR(k)-грамматики в программе лечения определяется ее практическими потребностями."
    },
    {
        "question": "Степень недетерминизма языка",
        "answer": "____\nЕсли PDA A допускает декомпозицию на DPDA, между\nкоторыми есть максимум k недетерминированных\nпереходов, но не допускает такую декомпозицию при i < k\nпереходов, скажем, что A задаёт КС-язык с\nk-недетерминированностью"
    },
    {
        "question": "Степень недетерминированности языка",
        "answer": "____\nЕсли PDA A допускает разложение на DPDA, между которыми существует не более k недетерминированных\nпереходов, но не допускает такого разложения для i < k\nпереходов, мы говорим, что A определяет язык CF с\nk-недетерминированностью"
    },
    {
        "question": "Степень недетерминированности языка",
        "answer": "____\nЕсли ПДА А допускает разложение на ДПДА, между которыми имеется не более k недетерминистов\nпереходов, но не допускает такого разложения при i < k\nпереходов мы говорим, что A определяет язык CF с\nk-неопределенность"
    },
    {
        "question": "Степень недетерминированности языка",
        "answer": "____\nЕсли ПДА А допускает разложение на ДПДА, то между\nкоторые имеют не более k недетерминированных\nпереходов, но не допускает такого разложения при i < k\nпереходы, скажем, что A определяет язык KS с\nk-неопределенность"
    },
    {
        "question": "Исправление недетерминированности КС языка",
        "answer": "____\nИсправление недетерминированности КС языка - это процесс, который позволяет преобразовать КС язык в детерминированный язык, сохранив его свойства и семантику.\n\nКС язык (Context-Sensitive language) - это язык, который может быть описан с помощью контекст-зависимых грамматик. КС языки имеют недетерминированность, что означает, что алгоритм, описывающий язык, не может быть однозначно определен.\n\nИсправление недетерминированности КС языка может быть выполнено с помощью следующих методов:\n\n1. **Determinization**: это процесс, который позволяет преобразовать КС язык в детерминированный язык, сохранив его свойства и семантику. Для этого используются алгоритмы, такие как алгоритм Курано, алгоритм Рейдера и т.д.\n2. **Regularization**: это процесс, который позволяет преобразовать КС язык в регулярный язык, сохранив его свойства и семантику. Для этого используются алгоритмы, такие как алгоритм Регулярного выражения и т.д.\n3. **Approximation**: это процесс, который позволяет приблизительно определить КС язык, сохранив его свойства и семантику. Для этого используются алгоритмы, такие как алгоритм APPROX и т.д.\n\nВ целом, исправление недетерминированности КС языка является важным шагом в разработке алгоритмов и автоматов для языков, которые имеют высокую степень недетерминированности.\n\nНекоторые примеры алгоритмов, которые могут быть использованы для исправления недетерминированности КС языка:\n\n* Алгоритм Курано (Curno's algorithm): это алгоритм, который позволяет преобразовать КС язык в детерминированный язык, используя контекст-зависимые грамматики.\n* Алгоритм Рейдера (Reeder's algorithm): это алгоритм, который позволяет преобразовать КС язык в детерминированный язык, используя контекст-зависимые грамматики и регулярные выражения.\n* Алгоритм APPROX (Approximation algorithm): это алгоритм, который позволяет приблизительно определить КС язык, используя регулярные выражения и контекст-зависимые грамматики.\n\nВ целом, исправление недетерминированности КС языка является важным шагом в разработке алгоритмов и автоматов для языков, которые имеют высокую степень недетерминированности."
    },
    {
        "question": "Исправление недетерминированности языка CS",
        "answer": "____\nДетерминизация контекстно-зависимого языка — это процесс, позволяющий преобразовать контекстно-зависимый язык в детерминированный язык с сохранением его свойств и семантики.\n\nКонтекстно-зависимый язык (CS) — это язык, который можно описать с помощью контекстно-зависимых грамматик. Языки CS обладают недетерминированностью, что означает, что алгоритм, описывающий язык, не может быть однозначно определен.\n\nДетерминизация контекстно-зависимого языка может быть выполнена с помощью следующих методов:\n\n1. **Детерминизация**: это процесс, позволяющий преобразовать контекстно-зависимый язык в детерминированный язык с сохранением его свойств и семантики. Для этого используются такие алгоритмы, как алгоритм Курано, алгоритм Радера и т. д.\n\n2. **Регуляризация**: это процесс, позволяющий преобразовать контекстно-зависимый язык в регулярный язык с сохранением его свойств и семантики. Для этого используются такие алгоритмы, как алгоритм регулярных выражений и т. д.\n3. **Аппроксимация**: это процесс, который позволяет приблизительно определить язык CS, сохраняя его свойства и семантику. Для этого используются такие алгоритмы, как алгоритм APPROX и т. д.\n\nВ целом, исправление недетерминизма языка CS является важным шагом в разработке алгоритмов и автоматов для языков с высокой степенью недетерминизма.\n\nНекоторые примеры алгоритмов, которые можно использовать для исправления недетерминизма языка CS:\n\n* Алгоритм Курно: это алгоритм, который позволяет преобразовать язык CS в детерминированный язык с использованием контекстно-зависимых грамматик.\n* Алгоритм Ридера: это алгоритм, который позволяет преобразовать язык CS в детерминированный язык с использованием контекстно-зависимых грамматик и регулярных выражений.\n* Алгоритм APPROX (Аппроксимационный алгоритм): это алгоритм, позволяющий приблизительно определить язык КС с помощью регулярных выражений и контекстно-зависимых грамматик.\n\nВ целом, фиксация недетерминированности языка КС является важным шагом в разработке алгоритмов и автоматов для языков, обладающих высокой степенью недетерминированности."
    },
    {
        "question": "Исправление недетерминированности языка CS",
        "answer": "____\nКонтекстное определение языка — это процесс, который преобразует контекстуальный язык в детерминированный язык, сохраняя при этом его свойства и семантику.\n\nКонтекстно-зависимый язык (CS) — это язык, который можно описать с помощью контекстно-зависимых грамматик. Языки CS недетерминированы, а это означает, что алгоритм, описывающий язык, не может быть определен однозначно.\n\nОпределить контекстуальный язык можно с помощью следующих методов:\n\n1. **Детерминация**: это процесс преобразования контекстуального языка в детерминированный язык с сохранением его свойств и семантики. Для этого используются такие алгоритмы, как алгоритм Курано, алгоритм Рейдера и т. д. используются.\n\n2. **Регуляризация**. Это процесс преобразования контекстно-зависимого языка в обычный язык с сохранением его свойств и семантики. Для этого используются такие алгоритмы, как алгоритм регулярных выражений и т. д. используются.\n3. **Аппроксимация**: это процесс, который позволяет вам приблизиться к языку CS, сохраняя при этом его свойства и семантику. Для этого используются такие алгоритмы, как алгоритм APPROX и т. д. используются.\n\nВ целом исправление недетерминированности языка КС является важным шагом в разработке алгоритмов и автоматов для языков с высокой степенью недетерминированности.\n\nНекоторые примеры алгоритмов, которые можно использовать для исправления недетерминизма в языке CS:\n\n* Алгоритм Курно: это алгоритм, который преобразует язык CS в детерминированный язык с использованием контекстных грамматик.\n* Алгоритм чтения: это алгоритм, который позволяет конвертировать язык CS в детерминированный язык с использованием контекстно-зависимых грамматик и регулярных выражений.\n* Алгоритм APPROX: это алгоритм, позволяющий приблизительно определить язык CS с помощью регулярных выражений и контекстно-зависимых грамматик.\n\nВ целом исправление недетерминированности языка КС является важным шагом в разработке алгоритмов и автоматов для языков с высокой степенью недетерминированности."
    },
    {
        "question": "Исправление недетерминированности языка КС",
        "answer": "____\nИсправление недетерминированности языка CS — это процесс, который позволяет преобразовать язык CS в детерминированный язык, сохраняя при этом его свойства и семантику.\n\nКонтекстно-зависимый язык (CS) — это язык, который можно описать с помощью контекстно-зависимых грамматик. Языки CS недетерминированы, а это означает, что алгоритм, описывающий язык, не может быть определен однозначно.\n\nИсправление недетерминированности языка CS можно осуществить следующими методами:\n\n1. **Детерминация**: это процесс, который позволяет преобразовать язык CS в детерминированный язык, сохраняя при этом его свойства и семантику. Для этого используются такие алгоритмы, как алгоритм Курано, алгоритм Рейдера и т. д. используются.\n2. **Регуляризация**: это процесс, позволяющий преобразовать язык КС в регулярный язык, сохранив при этом его свойства и семантику. Для этого используются такие алгоритмы, как алгоритм регулярных выражений и т. д.\n3. **Аппроксимация**: это процесс, позволяющий приближенно определить язык КС, сохранив его свойства и семантику. Такие алгоритмы, как алгоритм APPROX и т. д. для этого используются.\n\nВообще говоря, исправление недетерминированности языка КС является важным шагом в разработке алгоритмов и автоматов для языков с высокой степенью недетерминированности.\n\nНекоторые примеры алгоритмов, которые можно использовать для исправления недетерминизма в языке CS:\n\n* Алгоритм Курно: это алгоритм, который преобразует язык CS в детерминированный язык с использованием контекстных грамматик.\n* Алгоритм Ридера: это алгоритм, который преобразует язык CS в детерминированный язык с использованием контекстных грамматик и регулярных выражений.\n* Алгоритм APPROX (алгоритм аппроксимации): это алгоритм, который может приблизительно определить язык KS с помощью регулярных выражений и контекстно-зависимых грамматик.\n\nВообще говоря, исправление недетерминированности языка КС является важным шагом в разработке алгоритмов и автоматов для языков с высокой степенью недетерминированности."
    },
    {
        "question": "Переключающиеся автоматы (Alternating Finite Automata)",
        "answer": "____\nАльтернативные финиитные автоматы (Alternating Finite Automata, АФА) - это тип машин, которые могут быть использованы для определения языка регулярных выражений с использованием альтернативы.\n\nОбратите внимание, что в отличие от дDeterministic Finite Automata (ДФА), АФА не обязаны быть детерминированными, то есть переходы на следующий шаг могут быть выполнены в зависимости от результата выборки алфавита.\n\nМодель АФА:\n\n* Каждое состояние имеет несколько переходов на другие состояния, зависящее от выборки алфавита.\n* В каждом состоянии есть одна из двух возможностей: переход или остановка.\n* ВАФ может быть представлено в виде 6-типного троек: Q, Σ, δ, q0, F, и λ.\n\n* Q - множество состояний.\n* Σ - алфавит.\n* δ - функция перехода, которая maps (Q × Σ) → 2^Q.\n* q0 - начальное состояние.\n* F - множество финальных состояний.\n* λ - пустой символ.\n\nВ АФА есть две основные операции:\n\n1. Δ(q, a) - переход из состояния q в состояние δ(q, a).\n2. Σ(q) - остановка в состоянии q.\n\nМетка автомата определяется как множество состояний, из которых автомат может остановиться.\n\nПример:\n\nАльтернативный финиитный автомат для языка {a^i b^j | i, j ≥ 0} можно представить следующим образом:\n\nQ = {q0, q1}\nΣ = {a, b}\nδ = {(q0, a) → {q0, q1}, (q0, b) → ∅, (q1, a) → ∅, (q1, b) → {q0}}\nq0 = q0\nF = {q0}\n\nВ этом примере автомат имеет два состояния q0 и q1. В начальном состоянии q0, автомат может перейти в любое из состояний q0 или q1, если он выбирает а, или останавливаться, если он выбирает b. Если автомат находится в состоянии q1, он останавливается, если он выбирает а или b.\n\nМетка автомата - множество состояний, из которых автомат может остановиться, то есть {q0}.\n\nАльтернативные финиитные автоматы могут быть использованы для определения языка регулярных выражений с использованием альтернативы, а также для определения языка контекстно-свободных грамматик.\n\nОни также могут быть использованы для определения языка с использованием альтернативы в языке регулярных выражений, таких как {a^i b^j | i, j ≥ 0} или {a^i b^j c^k | i, j, k ≥ 0}."
    },
    {
        "question": "Конечные автоматы с чередованием",
        "answer": "____\nАльтернативные конечные автоматы (AFA) — это тип машины, который можно использовать для определения языка регулярных выражений с использованием альтернативы.\n\nОбратите внимание, что в отличие от детерминированных конечных автоматов (DFA), AFA не обязательно должны быть детерминированными, т. е. переходы на следующий шаг могут осуществляться в зависимости от результата выборки алфавита.\n\nМодель AFA:\n\n* Каждое состояние имеет несколько переходов в другие состояния в зависимости от выборки алфавита.\n* В каждом состоянии есть две возможности: переход или остановка.\n* AFA можно представить в виде тройки из 6 типов: Q, Σ, δ, q0, F и λ.\n\n* Q — это набор состояний.\n* Σ — это алфавит.\n* δ — это функция перехода, которая отображает (Q × Σ) → 2^Q.\n* q0 — это начальное состояние.\n* F — множество конечных состояний.\n* λ — пустой символ.\n\nВ AFA есть две основные операции:\n\n1. Δ(q, a) — переход из состояния q в состояние δ(q, a).\n\n2. Σ(q) — остановка в состоянии q.\n\nМетка автомата определяется как множество состояний, из которых автомат может остановиться.\n\nПример:\n\nАльтернативный конечный автомат для языка {a^i b^j | i, j ≥ 0} можно представить следующим образом:\n\nQ = {q0, q1}\nΣ = {a, b}\nδ = {(q0, a) → {q0, q1}, (q0, b) → ∅, (q1, a) → ∅, (q1, b) → {q0}}\nq0 = q0\nF = {q0}\n\nВ этом примере автомат имеет два состояния q0 и q1. В начальном состоянии q0 автомат может перейти в любое из состояний q0 или q1, если он выбирает a, или остановиться, если он выбирает b. Если автомат находится в состоянии q1, он останавливается, если он выбирает a или b.\n\nМетка автомата — это множество состояний, из которых автомат может остановиться, т. е. {q0}.\n\nАльтернативные конечные автоматы могут использоваться для определения языка регулярных выражений с использованием альтернатив, а также для определения языка контекстно-свободных грамматик.\n\nИх также можно использовать для определения языка с использованием альтернатив в языке регулярных выражений, таких как {a^i b^j | i, j ≥ 0} или {a^i b^j c^k | i, j, k ≥ 0}."
    },
    {
        "question": "Перемежающиеся конечные автоматы",
        "answer": "____\nАльтернативные конечные автоматы (AFA) — это тип машины, которую можно использовать для определения языка регулярных выражений с использованием альтернативы.\n\nОтметим, что в отличие от детерминированных конечных автоматов (ДКА), АКА не обязательно должны быть детерминированными, т.е. переходы на следующий шаг могут осуществляться на основании результата алфавитного выбора.\n\nМодель АФА:\n\n*Каждое состояние имеет несколько переходов в другие состояния в зависимости от выбора алфавита.\n* В каждом штате есть две возможности: уйти или остановиться.\n* АФА можно представить в виде тройки 6 типов: Q, Σ, δ, q0, F и λ.\n\n*Q — набор состояний.\n* Σ – алфавит.\n*δ — функция перехода, отображающая (Q × Σ) → 2^Q.\n* q0 – исходное состояние.\n* F — множество конечных состояний.\n* λ — пустой символ.\n\nВ AFA есть две основные операции:\n\n1. Δ(q, a) — переход из состояния q в состояние δ(q, a).\n\n2. Σ(q) — остановка в состоянии q.\n\nМетка автомата определяется как множество состояний, из которых автомат может остановиться.\n\nПример:\n\nАльтернативный конечный автомат для языка {a^i b^j | i, j ≥ 0} можно представить следующим образом:\n\nQ = {q0, q1}\nΣ = {а, b}\nδ = {(q0, a) → {q0, q1}, (q0, b) → ∅, (q1, a) → ∅, (q1, b) → {q0}}\nq0 = q0\nF = {q0}\n\nВ этом примере автомат имеет два состояния q0 и q1. В начальном состоянии q0 автомат может перейти либо в состояние q0, либо в состояние q1, если выберет a, либо остановиться, если выберет b. Если машина находится в состоянии q1, она останавливается, если выбирает a или b.\n\nМетка автомата — это множество состояний, из которых автомат может остановиться, то есть {q0}.\n\nАльтернативные конечные автоматы можно использовать для определения языка регулярных выражений с использованием альтернатив, а также для определения языка контекстно-свободных грамматик.\n\nИх также можно использовать для определения языка, используя альтернативы языка регулярных выражений, например {a^i b^j | я, j ≥ 0} или {a^i b^j c^k | i, j, k ≥ 0}."
    },
    {
        "question": "Переменные конечные автоматы",
        "answer": "____\nАльтернативные конечные автоматы (AFA) — это тип машины, которую можно использовать для определения языка регулярных выражений с использованием чередования.\n\nОтметим, что в отличие от детерминированных конечных автоматов (ДКА), АКА не обязательно должны быть детерминированными, т.е. переходы на следующий шаг могут осуществляться на основании результата алфавитного выбора.\n\nМодель АФА:\n\n* Каждое состояние имеет несколько переходов в другие состояния, в зависимости от выбора алфавита.\n* Каждое состояние имеет одну из двух возможностей: уйти или остановиться.\n* ВАФ можно представить тройками 6 типов: Q, Σ, δ, q0, F и λ.\n\n* Q - набор состояний.\n* Σ – алфавит.\n* δ — функция перехода, отображающая (Q × Σ) → 2^Q.\n* q0 – исходное состояние.\n* F - набор конечных состояний.\n* λ — пустой символ.\n\nВ AFA есть две основные операции:\n\n1. Δ(q, a) – переход из состояния q в состояние δ(q, a).\n2. Σ(q) – остановка в состоянии q.\n\nМетка автомата определяется как множество состояний, из которых автомат может остановиться.\n\nПример:\n\nАльтернативный конечный автомат для языка {a^i b^j | i, j ≥ 0} можно представить следующим образом:\n\nQ = {q0, q1}\nΣ = {а, b}\nδ = {(q0, a) → {q0, q1}, (q0, b) → ∅, (q1, a) → ∅, (q1, b) → {q0}}\nq0 = q0\nF = {q0}\n\nВ этом примере автомат имеет два состояния q0 и q1. В начальном состоянии q0 автомат может перейти либо в состояние q0, либо в состояние q1, если выберет a, либо остановиться, если выберет b. Если машина находится в состоянии q1, она останавливается, если выбирает a или b.\n\nМетка автомата — это множество состояний, из которых автомат может остановиться, то есть {q0}.\n\nАльтернативные конечные автоматы можно использовать для определения языка регулярных выражений с использованием альтернативы, а также для определения языка контекстно-свободных грамматик.\n\nИх также можно использовать для определения языка, используя альтернативу языку регулярных выражений, например {a^i b^j | я, j ≥ 0} или {a^i b^j c^k | i, j, k ≥ 0}."
    },
    {
        "question": "Теоретический коллапс линейных парсеров",
        "answer": "____\nТеоретический коллапс линейных парсеросов\n\nВ теоретической информатике коллапс линейных парсеросов - это явление, при котором ресурсов, необходимых для решения задачи, растет экспоненциально с размером входных данных. Это означает, что время выполнения алгоритма и потребление памяти быстро растут при увеличении размера входных данных, эффективно делая задачу неразрешимой.\n\nДавайте глубже исследуем это понятие.\n\n**Что такое парсерос?**\n\nВ контексте линейных систем парсерос - это класс языков, которые могут быть распознаны определенным типом конечного автомата, называемым линейным паритетом (LPA). LPAs оборудованы паметной лентой, разделенной на ячейки, каждая из которых хранит двоичный символ (0 или 1). Автомат начинает работу в начальном состоянии, читает входные символы по одному и перемещается между состояниями в соответствии с предопределенными правилами. На каждом шаге автомат читает текущее состояние, читает следующий символ и обновляет паметную ленту, записывая 0 или 1 в текущей ячейке.\n\n**Что такое коллапс?**\n\nТеперь imagine hypothetical ситуацию: Представьте себе ситуацию, когда задача P имеет уникальное решение в классе линейных парсеросов, то есть существует LPA, который может распознать все экземпляры P. Коллапс происходит, когда, несмотря на уникальное решение, становится очень трудно или компьютерно неосуществимо найти его.\n\nКоллапс происходит из-за ограничений LPAs в распознавании некоторых задач. Проблема возникает, когда язык является редким, то есть есть больше строк, не входящих в язык, чем тех, которые входят в него. В таких случаях, даже с уникальным решением, время и память, необходимые для его поиска, могут стать неосуществимыми при увеличении размера входных данных.\n\n**Ключевые характеристики:**\n\n1. **Уникальное решение**: Задача P называется уникальным решением, если существует LPA, который может распознать все экземпляры P.\n2. **Коллапс**: Когда решение становится компьютерно неосуществимым или требует много времени при увеличении размера входных данных, несмотря на уникальность.\n\n**Импликации:**\n\nКоллапс линейных парсеросов имеет значимые последствия для различных областей, таких как:\n\n1. **Теория сложности вычислений**: Он подчеркивает ограничения текущих алгоритмов и важность разработки новых, более эффективных подходов для решения неразрешимых задач.\n2. **Теория кодирования**: Коллапс освещает трудности в создании оптимальных кодов для надежной передачи и хранения данных.\n3. **Машинное обучение**: Исследователи могут потребовать разработки альтернативных методов для уменьшения влияния коллапса, что может привести к созданию новых алгоритмов и архитектур.\n\nХотя коллапс линейных парсеросов может казаться неожиданным вначале, он спровоцировал интересные направления исследований и глубоко расширил наше понимание ограничений в решении компьютерных задач."
    },
    {
        "question": "Теоретический коллапс линейных парсеров",
        "answer": "____\nТеоретический коллапс линейных парсеров\n\nВ теоретической информатике коллапс линейного парсера — это явление, при котором ресурсы, необходимые для решения задачи, растут экспоненциально с размером входных данных. Это означает, что время выполнения алгоритма и его потребление памяти быстро растут с увеличением размера входных данных, что фактически делает задачу неразрешимой.\n\nДавайте рассмотрим эту концепцию подробнее.\n\n**Что такое парсер?**\n\nВ контексте линейных систем парсер — это класс языков, которые могут быть распознаны определенным типом конечного автомата, называемого линейным парсером (LPA). LPA оснащены лентой памяти, разделенной на ячейки, каждая из которых хранит двоичный символ (0 или 1). Автомат начинает работу в начальном состоянии, считывает входные символы по одному за раз и перемещается между состояниями в соответствии с предопределенными правилами. На каждом шаге автомат считывает текущее состояние, считывает следующий символ и обновляет ленту памяти, записывая 0 или 1 в текущую ячейку.\n\n**Что такое коллапс?**\n\nТеперь представьте себе гипотетическую ситуацию: представьте себе ситуацию, когда проблема P имеет единственное решение в классе линейных парсеров, т. е. существует LPA, который может распознавать все экземпляры P. Коллапс происходит, когда, несмотря на единственное решение, становится очень трудно или невыполнимо для компьютера найти его.\n\nКоллапс происходит из-за ограничений LPA в распознавании некоторых проблем. Проблема возникает, когда язык разрежен, т. е. за пределами языка больше строк, чем в нем. В таких случаях даже при единственном решении время и память, необходимые для его поиска, могут стать невыполнимыми по мере увеличения размера входных данных.\n\n**Ключевые особенности:**\n\n1. **Уникальное решение**: проблема P называется уникальным решением, если существует LPA, который может распознать все экземпляры P.\n2. **Коллапс**: когда решение становится невыполнимым для компьютера или требует много времени по мере увеличения размера входных данных, несмотря на свою уникальность.\n\n**Последствия:**\n\nКоллапс линейных парсеров имеет значительные последствия для различных областей, таких как:\n\n1. **Теория вычислительной сложности**: она подчеркивает ограничения текущих алгоритмов и важность разработки новых, более эффективных подходов к решению сложных проблем.\n2. **Теория кодирования**: коллапс подчеркивает трудности в создании оптимальных кодов для надежной передачи и хранения данных.\n3. **Машинное обучение**: исследователям может потребоваться разработать альтернативные методы для уменьшения влияния коллапса, что может привести к появлению новых алгоритмов и архитектур.\n\nХотя поначалу крах линейных синтаксических анализаторов мог показаться неожиданным, он положил начало интересным направлениям исследований и существенно расширил наше понимание ограничений решения компьютерных задач."
    },
    {
        "question": "Теоретический крах линейных анализаторов",
        "answer": "____\nТеоретический крах линейных анализаторов\n\nВ теоретической информатике коллапс линейного анализатора — это явление, при котором ресурсы, необходимые для решения проблемы, увеличиваются экспоненциально с размером входных данных. Это означает, что время выполнения алгоритма и потребление памяти быстро возрастают по мере увеличения размера входных данных, что делает проблему неразрешимой.\n\nДавайте рассмотрим это понятие более подробно.\n\n**Что такое парсер?**\n\nВ контексте линейных систем парсер — это класс языков, который может распознаваться конечным автоматом определенного типа, называемым линейным парсером (LPA). ЛПА оснащены полосой памяти, разделенной на ячейки, в каждой из которых хранится двоичный символ (0 или 1). Машина запускается в исходном состоянии, считывает входные символы один за другим и перемещается между состояниями в соответствии с заранее заданными правилами. На каждом этапе машина считывает текущее состояние, считывает следующий символ и обновляет полосу памяти, записывая 0 или 1 в текущую ячейку.\n\n**Что такое коллапс?**\n\nТеперь представьте себе гипотетическую ситуацию: представьте себе ситуацию, в которой задача P имеет единственное решение в классе линейных анализаторов, то есть существует LPA, способный распознавать все экземпляры P. Коллапс происходит, когда, несмотря на уникальность решения, она компьютеру становится очень трудно или невозможно его найти.\n\nЭтот коллапс вызван неспособностью НОАК признать определенные проблемы. Проблема возникает, когда язык разрежен, то есть строк вне языка больше, чем в нем. В таких случаях, даже при наличии единственного решения, время и память, необходимые для его поиска, могут стать невозможными по мере увеличения размера входных данных.\n\n**Основные характеристики:**\n\n1. **Уникальное решение**. Проблема P называется уникальным решением, если существует LPA, способный распознавать все экземпляры P.\n2. **Свернуть**: когда решение становится невозможным на компьютере или требует времени из-за увеличения размера входных данных, хотя оно уникально.\n\n**Последствия:**\n\nВыход из строя линейных анализаторов имеет важные последствия в различных областях, таких как:\n\n1. **Теория сложности вычислений**: она подчеркивает ограничения существующих алгоритмов и важность разработки новых, более эффективных подходов к решению сложных задач.\n2. **Теория кодирования**: Коллапс подчеркивает трудности создания оптимальных кодов для надежной передачи и хранения данных.\n3. **Машинное обучение**. Исследователям, возможно, придется разработать альтернативные методы уменьшения последствий коллапса, что может привести к созданию новых алгоритмов и архитектур.\n\nХотя крах линейных анализаторов поначалу мог показаться неожиданным, он открыл некоторые интересные направления исследований и значительно расширил наше понимание пределов решения вычислительных задач."
    },
    {
        "question": "Теоретический крах линейных анализаторов",
        "answer": "____\nТеоретический крах линейных анализаторов\n\nВ теоретической информатике коллапс линейного анализатора — это явление, при котором ресурсы, необходимые для решения проблемы, увеличиваются экспоненциально с размером входных данных. Это означает, что время выполнения алгоритма и потребление памяти быстро возрастают по мере увеличения размера входных данных, что делает проблему неразрешимой.\n\nДавайте рассмотрим эту концепцию более подробно.\n\n**Что такое парсеро?**\n\nВ контексте линейных систем парсеры представляют собой класс языков, которые можно распознать с помощью определенного типа конечного автомата, называемого линейной четностью (LPA). ЛПА оснащены полосой памяти, разделенной на ячейки, в каждой из которых хранится двоичный символ (0 или 1). Машина запускается в исходном состоянии, считывает входные символы один за другим и перемещается между состояниями в соответствии с заранее заданными правилами. На каждом этапе машина считывает текущее состояние, считывает следующий символ и обновляет полосу памяти, записывая 0 или 1 в текущую ячейку.\n\n**Что такое коллапс?**\n\nТеперь представьте себе гипотетическую ситуацию: представьте себе ситуацию, в которой задача P имеет единственное решение в классе линейных анализаторов, то есть существует LPA, способный распознавать все экземпляры P. Коллапс происходит, когда, несмотря на уникальность решения, она найти его становится очень сложно или вычислительно невозможно.\n\nКоллапс происходит из-за ограничений LPA в осознании определенных задач. Проблема возникает, когда язык разрежен, то есть строк, которых нет в языке, больше, чем есть. В таких случаях, даже при наличии единственного решения, время и память, необходимые для его поиска, могут стать невозможными по мере увеличения размера входных данных.\n\n**Основные характеристики:**\n\n1. **Уникальное решение**. Проблема P называется уникальным решением, если существует LPA, способный распознавать все экземпляры P.\n2. **Свернуть**: когда решение становится вычислительно неосуществимым или требует много времени по мере увеличения размера входных данных, даже если оно уникально.\n\n**Импликация:**\n\nКрах линейных парсеров имеет серьезные последствия в различных областях, таких как:\n\n1. **Теория сложности вычислений**. Она подчеркивает ограничения существующих алгоритмов и важность разработки новых, более эффективных подходов к решению трудноразрешимых проблем.\n2. **Теория кодирования**: Коллапс подчеркивает трудности создания оптимальных кодов для надежной передачи и хранения данных.\n3. **Машинное обучение**. Исследователям может потребоваться разработка альтернативных методов уменьшения последствий коллапса, что может привести к созданию новых алгоритмов и архитектур.\n\nХотя крах линейных анализаторов на первый взгляд может показаться неожиданным, он открыл некоторые интересные направления исследований и глубоко расширил наше понимание пределов вычислительных задач."
    },
    {
        "question": "автомат Треллиса",
        "answer": "____\nВы упомянули автомат по типу Trelleborg!\n\nTrelleborg - это известная шведская компания, которая специализируется на разработке машин для изменяения шин, и их автоматическая машина для изменения шин - это популярный выбор для шинных станций и автоматизированных станций сервиса.\n\n以下 перечислены основные функции и преимущества автомата Trelleborg:\n\n1. **Удобство**: машина может изменить шину в считанные минуты, что значительно быстрее методов ручного изменения шин.\n2. **Точность**: машина спроектирована для обеспечения точного и-consistent наджима шины, что важно для безопасности и продолжительной службы шин.\n3. **Easy to use**: машина имеет пользовательский интерфейс, который сделает ее простой для использования даже для пользователей с ограниченным опытом изменения шин.\n4. **Контроль**: машина позволяет пользователю контролировать процесс изменения шины, обеспечивая ее правильное посадку и наджим.\n5. **Продолжительность жизни**: машина является стойкой к частым нагрузкам и спроектирована для работы многие годы с proper servicing.\n6. **Охрана окружающей среды**: машина уменьшает необходимость ручного труда, что может привести к уменьшению потребления топлива и выбросов.\n\nВ целом, автомат Trelleborg - это надежная и производительная машина, которая может помочь шинным станциям и автоматизированным станциям сервиса увеличить свою производительность и прибыльность, а также обеспечить безопасность и качество их услуг по изменению шин.\n\nХотите узнать больше о модели или функциях автомата Trelleborg?"
    },
    {
        "question": "Пулемет «Треллис»",
        "answer": "____\nВы упомянули станок типа Trelleborg!\n\nTrelleborg — известная шведская компания, которая специализируется на разработке шиномонтажных станков, и их автоматический шиномонтажный станок пользуется популярностью у шиномонтажных мастерских и автоматизированных станций техобслуживания.\n\n以下 перечисляет основные характеристики и преимущества станка Trelleborg:\n\n1. **Удобство**: станок может заменить шину за считанные минуты, что значительно быстрее, чем ручные методы замены шин.\n2. **Точность**: станок предназначен для обеспечения точного и постоянного прессования шин, что важно для безопасности и долговечности шин.\n3. **Простота использования**: станок имеет пользовательский интерфейс, который сделает его простым в использовании даже для пользователей с ограниченным опытом замены шин.\n4. **Управление**: станок позволяет пользователю контролировать процесс замены шин, гарантируя правильную посадку и прессование шины.\n5. **Срок службы**: Машина устойчива к частым нагрузкам и рассчитана на многолетнюю работу при надлежащем обслуживании.\n\n6. **Экологичность**: Машина снижает потребность в ручном труде, что может привести к снижению расхода топлива и выбросов.\n\nВ целом, машина Trelleborg — это надежная и производительная машина, которая может помочь шиномонтажным мастерским и автоматизированным станциям техобслуживания повысить производительность и прибыльность, а также обеспечить безопасность и качество услуг по замене шин.\n\nХотите узнать больше о модели или характеристиках машины Trelleborg?"
    },
    {
        "question": "Пулемет «Треллис»",
        "answer": "____\nВы упомянули машину типа Треллеборг!\n\nTrelleborg — известная шведская компания, специализирующаяся на разработке шиномонтажных станков, ее автоматические шиномонтажные станки пользуются популярностью в шиномонтажных мастерских и на автоматических заправочных станциях.\n\n以下 перечисляет основные особенности и преимущества машины Trelleborg:\n\n1. **Удобно**: машина может заменить шину за считанные минуты, что намного быстрее, чем при замене шин вручную.\n2. **Точность**: машина предназначена для обеспечения точного и равномерного прижима шин, что важно для безопасности и долговечности шин.\n3. **Простота в использовании**: машина имеет пользовательский интерфейс, который позволит легко использовать ее даже пользователям с ограниченным опытом замены шин.\n4. **Управление**: машина позволяет пользователю контролировать процесс замены шин, обеспечивая правильную посадку и сжатие шин.\n5. **Срок службы**: машина выдерживает частое использование и рассчитана на долгие годы службы при правильном обслуживании.\n\n6. **Экологичность**: машина снижает потребность в ручном труде, что может привести к снижению расхода топлива и выбросов.\n\nВ целом, Trelleborg — это надежная и производительная машина, которая может помочь шиномонтажным мастерским и автоматизированным станциям технического обслуживания повысить производительность и прибыльность, а также обеспечить безопасные и качественные услуги по замене шин.\n\nХотите узнать больше о модели или функциях вашей машины Trelleborg?"
    },
    {
        "question": "Решетчатая машина",
        "answer": "____\nВы упомянули машину типа Треллеборг!\n\nTrelleborg — известная шведская компания, специализирующаяся на разработке машин для замены шин. Их автоматические машины для замены шин широко используются на шиномонтажных станциях и автоматизированных заправочных станциях.\n\nВот список основных функций и преимуществ станка Треллеборг:\n\n1. **Удобство**: машина позволяет заменить шину за считанные минуты, что намного быстрее, чем при замене шин вручную.\n2. **Точность**. Конструкция машины обеспечивает точное и постоянное давление в шинах, что важно для безопасности и длительного срока службы шин.\n3. **Простота в использовании**: машина имеет пользовательский интерфейс, который позволит легко использовать ее даже пользователям с ограниченным опытом модификации шин.\n4. **Управление**: машина позволяет пользователю контролировать процесс замены шин, обеспечивая правильную посадку и давление.\n5. **Срок службы**: машина выдерживает частое использование и рассчитана на долгие годы работы при правильном обслуживании.\n6. **Защита окружающей среды**: машина снижает потребность в ручном труде, что может привести к снижению расхода топлива и выбросов.\n\nВ целом, машина Trelleborg — это надежная и производительная машина, которая может помочь шиномонтажным станциям и автоматизированным станциям технического обслуживания повысить свою производительность и прибыльность, а также обеспечить безопасность и качество обслуживания шин.\n\nХотите узнать больше о модели или особенностях машины Trelleborg?"
    },
    {
        "question": "Jumping Lemma",
        "answer": "____\nБорьба с Леммой!\n\nВ математике, особенно в топологии и анализе, Лемма о скачках (Jumping Lemma) - это результат, который обеспечивает нижнюю оценку скорости сходимости Certain функций. Специально, он работает с функциями, которые скачут неопределенно, такие как функция Хевисайда или функция абсолютного значения.\n\nЛемма обычно утверждает, что функция, имеющая скачковую дисконтинуацию в точке x, для точек y близких к x, будет иметь скорость сходимости, пропорциональную размеру скачки. Это means that function будет \"скачать\" обратно к своему ограничение, как y approches x, со скоростью, зависящей от размера скачки.\n\nЭто важное следствие имеет важные последствия в различных областях:\n\n1. Функциональный анализ: Лемма помогает понять свойства линейных операторов и их спектральное разложение.\n2. Теория меры: Он играет важную роль в исследовании мер и интегралов, особенно в контексте теории Лебега.\n3. Гармонический анализ: Лемма имеет приложения в анализе Фурье-серий и волокнистых преобразованиях.\n4. Теория приближений: Он обеспечивает оценку ошибки приближения функций при использовании приближений.\n\nУ вас есть какие-либо конкретные вопросы или темы, связанные с Леммой о скачках, которые вы хотели бы обсудить?"
    },
    {
        "question": "Лемма о прыжках",
        "answer": "____\nБорьба с леммой!\n\nВ математике, особенно в топологии и анализе, лемма о прыжках — это результат, который дает нижнюю границу для скорости сходимости определенных функций. В частности, она работает для функций, которые прыгают бесконечно, таких как функция Хевисайда или функция абсолютного значения.\n\nЛемма обычно утверждает, что функция, которая имеет скачкообразный разрыв в точке x, для точек y, близких к x, будет иметь скорость сходимости, пропорциональную размеру скачка. Это означает, что функция будет «прыгать» обратно к своему пределу, когда y приближается к x, со скоростью, которая зависит от размера скачка.\n\nЭто важное следствие имеет важные последствия в различных областях:\n\n1. Функциональный анализ: лемма помогает понять свойства линейных операторов и их спектральное разложение.\n2. Теория меры: она играет важную роль в изучении мер и интегралов, особенно в контексте теории Лебега.\n3. Гармонический анализ: лемма имеет приложения в анализе рядов Фурье и преобразованиях волокон.\n\n4. Теория приближений: она дает оценку погрешности приближения функций при использовании приближений.\n\nУ вас есть какие-либо конкретные вопросы или темы, связанные с леммой о скачке, которые вы хотели бы обсудить?"
    },
    {
        "question": "Лемма о прыжке",
        "answer": "____\nБорьба с леммой!\n\nВ математике, особенно в топологии и анализе, лемма о скачке — это результат, который дает нижнюю оценку скорости сходимости некоторых функций. Это особенно работает для функций, которые переходят на бесконечность, таких как функция Хевисайда или функция абсолютного значения.\n\nЛемма обычно утверждает, что функция, имеющая скачок в точке x, для точек y, близких к x, будет иметь скорость сходимости, пропорциональную размеру скачка. Это означает, что функция будет «прыгать» к своему пределу по мере того, как y приближается к x, со скоростью, которая зависит от размера скачка.\n\nЭто важное последствие имеет важные последствия в различных областях:\n\n1. Функциональный анализ. Лемма помогает понять свойства линейных операторов и их спектральное разложение.\n2. Теория измерений. Она играет важную роль в изучении измерений и интегралов, особенно в контексте теории Лебега.\n3. Гармонический анализ. Лемма имеет применение при анализе рядов Фурье и слоевых преобразований.\n\n4. Теория приближения. Она дает оценку ошибки аппроксимации функций при использовании приближений.\n\nЕсть ли у вас какие-либо вопросы или конкретные темы, связанные с леммой о переходе, которые вы хотели бы обсудить?"
    },
    {
        "question": "Лемма прыгает",
        "answer": "____\nБорьба с Леммой!\n\nВ математике, особенно в топологии и анализе, лемма о скачке — это результат, который дает нижнюю оценку скорости сходимости некоторых функций. В частности, он работает с функциями, которые перемещаются бесконечно, например, с функцией Хевисайда или функцией абсолютного значения.\n\nЛемма обычно утверждает, что функция, имеющая скачок в точке x, для точек y, близких к x, будет иметь скорость сходимости, пропорциональную размеру скачка. Это означает, что функция будет «загружаться» до предела по мере того, как y приближается к x, со скоростью, зависящей от размера скачка.\n\nЭто важное последствие имеет важные последствия в различных областях:\n\n1. Функциональный анализ. Лемма помогает понять свойства линейных операторов и их спектральное разложение.\n2. Теория измерения. Она играет важную роль в изучении мер и интегралов, особенно в контексте теории Лебега.\n3. Гармонический анализ. Лемма применима при анализе рядов Фурье и волоконных преобразований.\n4. Теория аппроксимации: она дает оценку ошибки аппроксимации функций при использовании аппроксимаций.\n\nЕсть ли у вас какие-либо конкретные вопросы или темы, связанные с леммой о скачках, которые вы хотели бы обсудить?"
    },
    {
        "question": "Атрибутные грамматики",
        "answer": "____\nАтрибутные грамматики (Attribute-Value Grammar, AVG) - это тип грамматики, который использует пару \"атрибут-значение\" (attribute-value) для определения синтаксических элементов языка.\n\nВ атрибутной грамматике, каждый синтаксический элемент языка ассоциирован с атрибутами, которые определяют его структуру и свойства. Атрибуты могут быть строковыми, целочисленными, логическими и другими типами данных.\n\nАтрибуты могут быть двух типов:\n\n1. Имя атрибута (Attribute Name) - это имя, которое задает атрибут. Например, \"type\", \"name\", \"date\".\n2. Значение атрибута (Attribute Value) - это значение, которое связано с именем атрибута. Например, \"int\", \"John\", \"2022-01-01\".\n\nАтрибуты используются для определения синтаксических правил языка, например:\n\n* \"sentence → (attribute: type, value: declarative) verb phrase (attribute: type, value: nominative) noun phrase (attribute: type, value: accusative)\"\n* \"verb phrase → (attribute: type, value: transitive) verb (attribute: type, value: tense, value: present) noun phrase (attribute: type, value: direct object)\"\n\nВ атрибутной грамматике, атрибуты используются для определения отношений между синтаксическими элементами языка, а также для задания ограничений на используемые значения атрибутов.\n\nАтрибутные грамматики могут быть использованы в различных приложениях, таких как:\n\n* Разработка языков программирования\n* Конструирование языков формализации\n* Синтаксическое разбиение текста\n* Определение языка запросов\n\nНедостатки атрибутных грамматик:\n\n* Комплексность: атрибутные грамматики могут быть сложными в описании и понимании\n* Несостоятельность: может быть трудно определить значения атрибутов в соответствии с синтаксическими правилами языка\n\nПримеры языков, использующих атрибутные грамматики:\n\n* SGML (Standard Generalized Markup Language)\n* XML (Extensible Markup Language)\n* HTML (Hypertext Markup Language)\n* SQL (Structured Query Language)\n\nВ целом, атрибутные грамматики предоставляют мощный инструмент для описания синтаксических правил языка, но могут быть трудны в использовании из-за своей сложности и потенциальной несостоятельности."
    },
    {
        "question": "Атрибутивные грамматики",
        "answer": "____\nАтрибутно-значная грамматика (AVG) — это тип грамматики, который использует пары атрибут-значение для определения синтаксических элементов языка.\n\nВ атрибутной грамматике каждый синтаксический элемент языка связан с атрибутами, которые определяют его структуру и свойства. Атрибуты могут быть строками, целыми числами, булевыми значениями и другими типами данных.\n\nАтрибуты могут быть двух типов:\n\n1. Имя атрибута — это имя, которое определяет атрибут. Например, «type», «name», «date».\n\n2. Значение атрибута — это значение, которое связано с именем атрибута. Например, «int», «John», «2022-01-01».\n\nАтрибуты используются для определения синтаксических правил языка, например:\n\n* \"предложение → (атрибут: тип, значение: повествовательный) глагольная группа (атрибут: тип, значение: номинативный) именная группа (атрибут: тип, значение: винительный)\"\n* \"глагольная группа → (атрибут: тип, значение: переходный) глагол (атрибут: тип, значение: время, значение: настоящее) именная группа (атрибут: тип, значение: прямой объект)\"\n\nВ атрибутной грамматике атрибуты используются для определения отношений между синтаксическими элементами языка, а также для установки ограничений на значения атрибутов, которые могут быть использованы.\n\nГрамматики атрибутов могут использоваться в различных приложениях, таких как:\n\n* Разработка языков программирования\n* Разработка языков формализации\n* Синтаксическая декомпозиция текста\n* Определение языка запросов\n\nНедостатки грамматик атрибутов:\n\n* Сложность: грамматики атрибутов могут быть сложны для описания и понимания\n* Непоследовательность: может быть сложно определить значения атрибутов в соответствии с синтаксическими правилами языка\n\nПримеры языков, использующих грамматики атрибутов:\n\n* SGML (Standard Generalized Markup Language)\n* XML (Extensible Markup Language)\n* HTML (Hypertext Markup Language)\n* SQL (Structured Query Language)\n\nВ целом, грамматики атрибутов предоставляют мощный инструмент для описания синтаксических правил языка, но могут быть сложны в использовании из-за их сложности и потенциальной непоследовательности."
    },
    {
        "question": "Атрибутивные грамматики",
        "answer": "____\nГрамматика атрибут-значение (AVG) — это тип грамматики, которая использует пары атрибут-значение для определения синтаксических элементов языка.\n\nВ атрибутной грамматике каждый синтаксический элемент языка связан с атрибутами, определяющими его структуру и свойства. Атрибуты могут быть строками, целыми числами, логическими значениями и другими типами данных.\n\nАтрибуты могут быть двух типов:\n\n1. Имя атрибута — это имя, идентифицирующее атрибут. Например, «тип», «имя», «дата».\n\n2. Значение атрибута — это значение, связанное с именем атрибута. Например, «int», «Джон», «01.01.2022».\n\nАтрибуты позволяют определять синтаксические правила языка, например:\n\n* «предложение → (атрибут: тип, значение: повествовательное) глагольная фраза (признак: тип, значение: именительный падеж) именное словосочетание (признак: тип, значение: винительный падеж)»\n* «вербальное выражение → (атрибут: тип, значение: переходный) глагол (атрибут: тип, значение: время, значение: настоящее время) именной фразой (атрибут: тип, значение: прямой объект)»\n\nВ атрибутной грамматике атрибуты используются для определения отношений между синтаксическими элементами языка, а также для установки ограничений на значения атрибутов, которые можно использовать.\n\nГрамматики атрибутов могут использоваться в различных приложениях, таких как:\n\n* Разработка языков программирования.\n* Разработка языков формализации.\n* Синтаксическая декомпозиция текста\n* Определение языка запросов\n\nНедостатки атрибутивных грамматик:\n\n* Сложность: грамматики атрибутов может быть сложно описать и понять.\n* Непоследовательность: может быть сложно определить значения атрибутов в соответствии с синтаксическими правилами языка.\n\nПримеры языков, использующих грамматики атрибутов:\n\n* SGML (стандартный обобщенный язык разметки)\n* XML (расширяемый язык разметки)\n* HTML (язык разметки гипертекста)\n*SQL (язык структурированных запросов)\n\nВ целом грамматики атрибутов являются мощным инструментом для описания синтаксических правил языка, но их может быть сложно использовать из-за их сложности и потенциальной противоречивости."
    },
    {
        "question": "Грамматики атрибутов",
        "answer": "____\nГрамматика значения атрибута (AVG) — это тип грамматики, который использует пару атрибут-значение для определения синтаксических элементов языка.\n\nВ атрибутной грамматике каждый синтаксический элемент языка связан с атрибутами, определяющими его структуру и свойства. Атрибуты могут быть строками, целыми числами, логическими значениями и другими типами данных.\n\nАтрибуты могут быть двух типов:\n\n1. Имя атрибута — это имя, которое определяет атрибут. Например, «тип», «имя», «дата».\n2. Значение атрибута — это значение, связанное с именем атрибута. Например, «int», «Джон», «01.01.2022».\n\nАтрибуты позволяют определять синтаксические правила языка, например:\n\n* «фраза → (атрибут: тип, значение: декларативный) глагольная фраза (атрибут: тип, значение: именительный падеж) именной фраза (атрибут: тип, значение: винительный падеж)»\n* «глагольное выражение → (атрибут: тип, значение: переходный) глагол (атрибут: тип, значение: время, значение: настоящее) именной фразой (атрибут: тип, значение: прямое дополнение)»\n\nВ атрибутной грамматике атрибуты используются для определения отношений между синтаксическими элементами языка, а также для установки ограничений на значения атрибутов, которые можно использовать.\n\nГрамматики атрибутов могут использоваться в различных приложениях, таких как:\n\n* Разработка языков программирования.\n* Построение языков формализации.\n* Синтаксическое разбиение текста\n* Определение языка запросов\n\nНедостатки атрибутивных грамматик:\n\n* Сложность: грамматики атрибутов может быть сложно описать и понять.\n* Непоследовательность: может быть сложно определить значения атрибутов в соответствии с синтаксическими правилами языка.\n\nПримеры языков, использующих грамматики атрибутов:\n\n* SGML (стандартный обобщенный язык разметки)\n* XML (расширяемый язык разметки)\n* HTML (язык разметки гипертекста)\n*SQL (язык структурированных запросов)\n\nВ целом грамматики атрибутов являются мощным инструментом для описания синтаксических правил языка, но их может быть сложно использовать из-за их сложности и потенциальной противоречивости."
    },
    {
        "question": "Замкнута ли DMFL относительно пересечения с регулярным языком",
        "answer": "____\nОтвет на вопрос:\n\nНет, DMFL не обязательно замкнута относительно пересечения с регулярным языком.\n\nДля иллюстрации этого факта рассмотрим следующий пример:\n\nПусть L будет регулярным языком, признанным DMFL M, и пусть R будет регулярным языком, признанным DFA N. Пересечение L и R, обозначенное как L ∩ R, является регулярным языком, признанным DFA, который принимает слово, если и только если M принимает это слово и N принимает это слово.\n\nТеперь предположим, что M имеет более одного ленты, а R будет регулярным языком, который не может быть признан DFA (например, язык всех строк над алфавитом {a, b}, которые не содержат подстроки \"ab\"). Тогда пересечение L ∩ R не является регулярным языком, поскольку не может быть признано никаким DFA.\n\nОднако L ∩ R все еще может быть признан DMFL, поскольку M может симулировать поведение DFA на каждой ленте и затем интерсектировать результаты, чтобы определить, принимается ли слово. поэтому пересечение DMFL с регулярным языком не обязательно является регулярным языком.\n\nДействительно, пересечение DMFL с регулярным языком является контекстно-определенным языком, который является более общим классом языков, чем регулярные языки. Это потому, что DMFL может признать контекстно-определенный язык, симулируя поведение pushdown-автомата на каждой ленте.\n\nНадеюсь, это помогло! Если у вас есть дополнительные вопросы, пожалуйста, не стесняйтесь задавать их."
    },
    {
        "question": "Замкнут ли DMFL относительно пересечения с обычным языком?",
        "answer": "____\nОтвет на вопрос:\n\nНет, DMFL не обязательно замкнут относительно пересечения с регулярным языком.\n\nЧтобы проиллюстрировать этот факт, рассмотрим следующий пример:\n\nПусть L — регулярный язык, распознаваемый DMFL M, а R — регулярный язык, распознаваемый DFA N. Пересечение L и R, обозначаемое как L ∩ R, является регулярным языком, распознаваемым DFA, который принимает слово тогда и только тогда, когда M принимает это слово, а N принимает это слово.\n\nТеперь предположим, что M имеет более одной полосы, а R — регулярный язык, который не может быть распознан DFA (например, язык всех строк в алфавите {a, b}, которые не содержат подстроку «ab»). Тогда пересечение L ∩ R не является регулярным языком, поскольку оно не может быть распознано никаким DFA.\n\nОднако L ∩ R все еще может быть распознан как DMFL, поскольку M может имитировать поведение DFA на каждой ленте, а затем пересекать результаты, чтобы определить, принято ли слово. Таким образом, пересечение DMFL с регулярным языком не обязательно является регулярным языком.\n\nДействительно, пересечение DMFL с регулярным языком является контекстно-зависимым языком, который является более общим классом языков, чем регулярные языки. Это потому, что DMFL может распознавать контекстно-зависимый язык, имитируя поведение автомата с магазином на каждой ленте.\n\nНадеюсь, это поможет! Если у вас есть дополнительные вопросы, не стесняйтесь спрашивать."
    },
    {
        "question": "Закрыты ли DMFL относительно пересечения с обычным языком?",
        "answer": "____\nОтвет на вопрос:\n\nНет, DMFL не обязательно замкнут в отношении пересечения с обычным языком.\n\nЧтобы проиллюстрировать этот факт, рассмотрим следующий пример:\n\nПусть L — регулярный язык, распознаваемый DMFL M, а R — регулярный язык, распознаваемый DFA N. Пересечение L и R, обозначаемое L ∩ R, является регулярным языком, распознаваемым DFA, который принимает слово тогда и только тогда, когда M принимает слово. это слово, и N принимает это слово.\n\nТеперь предположим, что M имеет несколько полос и что R — стандартный язык, который не может быть распознан DFA (например, язык всех строк алфавита {a, b}, не содержащих подстроку «ab»). Тогда пересечение L ∩ R не является регулярным языком, поскольку не может быть распознано никаким ДКА.\n\nОднако L ∩ R по-прежнему можно распознать как DMFL, поскольку M может имитировать поведение DFA на каждой полосе, а затем ссылаться на результаты, чтобы определить, принято ли слово. Таким образом, пересечение DMFL с обычным языком не обязательно является регулярным языком.\n\nДействительно, пересечение DMFL с обычным языком представляет собой контекстно-зависимый язык, который представляет собой более общий класс языков, чем обычные языки. По сути, DMFL может распознавать контекстный язык, моделируя поведение машины с магазином на каждой ленте.\n\nНадеюсь, это поможет! Если у вас есть дополнительные вопросы, пожалуйста, не стесняйтесь спрашивать."
    },
    {
        "question": "Закрыт ли DMFL относительно пересечения с обычным языком?",
        "answer": "____\nОтвет на вопрос:\n\nНет, DMFL не обязательно замкнут в отношении пересечения с обычным языком.\n\nЧтобы проиллюстрировать этот факт, рассмотрим следующий пример:\n\nПусть L — регулярный язык, распознаваемый DMFL M, а R — регулярный язык, распознаваемый DFA N. Пересечение L и R, обозначаемое L ∩ R, является регулярным языком, распознаваемым DFA, который принимает слово тогда и только тогда, когда M принимает это слово, и N принимает это слово.\n\nТеперь предположим, что M имеет несколько полос и что R — стандартный язык, который не может быть распознан DFA (например, язык всех строк выше алфавита {a, b} и которые не содержат подстроку «ab»). Тогда пересечение L ∩ R не является регулярным языком, поскольку не может быть распознано никаким ДКА.\n\nОднако L ∩ R по-прежнему можно распознать как DMFL, поскольку M может моделировать поведение DFA на каждой полосе, а затем сопоставлять результаты, чтобы определить, принято ли слово. поэтому пересечение DMFL с обычным языком не обязательно является регулярным языком.\n\nДействительно, пересечение DMFL с регулярным языком представляет собой контекстно-зависимый язык, который представляет собой более общий класс языков, чем обычные языки. Действительно, DMFL может распознавать контекстно-зависимый язык, моделируя поведение понижающей машины на каждом диапазоне.\n\nНадеюсь, это помогло! Если у вас есть дополнительные вопросы, пожалуйста, не стесняйтесь спрашивать."
    },
    {
        "question": "Замкнута ли DMFL относительно объединения",
        "answer": "____\nDMFL (Data Markup Format Language) является замкнутым языком помаркирования для размечения и категоризации данных, в котором есть ограничения на возможности размечения, чтобы предотвратить неограниченное размечивание и обеспечить единство и понятность для размечения данных.\n\nВ частности, DMFL имеет несколько механизмов, чтобы помочь обеспечить ограничения и запреты на размечивание:\n\n1. Пользовательский профилювання: пользователи могут создавать имена для своих обрений, но ограничены до длины 64 символа.\n2. Документарное ограничение: пользователь не может создать объекты с именем, которое уже является документарным.\n3. Неупорядочивание: пользователь не может создавать ссылки на объекты, которые не существуют или не имеют определения.\n\nЭто ограничения позволяют предотвратить создание бесконечного или взаимосвязанного размечения и обеспечивают единство и понятность для размечения данных. DMFL также имеет built-in functions для проверки валидности размечивания, чтобы гарантировать, что разметка данных является правильной и корректной."
    },
    {
        "question": "Закрыт ли DMFL по решению профсоюза?",
        "answer": "____\nDMFL (Data Markup Format Language) — это закрытый язык маркировки для маркировки и категоризации данных, который имеет ограничения на возможности маркировки, чтобы предотвратить неограниченную маркировку и обеспечить единообразие и ясность маркировки данных.\n\nВ частности, DMFL имеет несколько механизмов, помогающих обеспечить соблюдение ограничений и запретов на маркировку:\n\n1. Профилирование пользователей: пользователи могут создавать имена для своих объектов, но ограничены 64 символами.\n\n2. Ограничение документа: пользователь не может создавать объекты с именем, которое уже задокументировано.\n\n3. Неупорядочивание: пользователь не может создавать ссылки на объекты, которые не существуют или не имеют определения.\n\nЭти ограничения помогают предотвратить создание бесконечной или взаимосвязанной маркировки и обеспечить единообразие и ясность маркировки данных. DMFL также имеет встроенные функции для проверки валидности маркировки, чтобы гарантировать, что маркировка данных является правильной и правильно сформированной."
    },
    {
        "question": "Закрыт ли DMFL по решению профсоюза?",
        "answer": "____\nDMFL (язык формата разметки данных) — это собственный язык разметки для маркировки и категоризации данных, который имеет ограничения на возможности разметки, чтобы предотвратить неограниченную маркировку и обеспечить согласованность и ясность маркировки данных.\n\nВ частности, в DMFL имеется несколько механизмов, помогающих обеспечить соблюдение ограничений и запретов на маркировке:\n\n1. Профилирование пользователей. Пользователи могут создавать имена для своих объектов, но их длина ограничена 64 символами.\n\n2. Ограничение документов: пользователь не может создавать объекты, имя которых уже задокументировано.\n\n3. Беспорядок: Пользователь не может создавать ссылки на объекты, которые не существуют или не имеют определения.\n\nЭти ограничения помогают избежать бесконечной или взаимосвязанной маркировки и обеспечить последовательность и ясность маркировки данных. DMFL также имеет встроенные функции для проверки правильности тегов, чтобы убедиться, что теги данных правильны и правильно сформированы."
    },
    {
        "question": "Закрыт ли DMFL с точки зрения профсоюза?",
        "answer": "____\nDMFL (язык формата разметки данных) — это закрытый язык разметки для маркировки и категоризации данных, который имеет ограничения на возможности разметки для предотвращения неограниченной разметки и обеспечения согласованности и ясности разметки данных.\n\nВ частности, DMFL имеет несколько механизмов, помогающих обеспечить соблюдение ограничений и ограничений разметки:\n\n1. Пользовательское профилирование. Пользователи могут создавать имена для своих профилей, но их длина ограничена 64 символами.\n2. Документарное ограничение: пользователь не может создавать объекты, имя которых уже документировано.\n3. Беспорядок: Пользователь не может создавать ссылки на объекты, которые не существуют или не имеют определения.\n\nЭти ограничения предотвращают создание бесконечной или взаимосвязанной разметки и обеспечивают согласованность и ясность разметки данных. DMFL также имеет встроенные функции для проверки действительности тегов, чтобы гарантировать правильность и правильность тегов данных."
    },
    {
        "question": "Линеаризация регулярных выражений это",
        "answer": "____\n\nЕсли регулярное выражение r ∈ RE (регулярное выражение) содержит n вхождений букв алфавита ∑, тогда линеаризованное регулярное выражение Linearize(r) получается из r приписыванием i-ой по счёту букве, входящий в r, индекса i.\nРассмотрим регулярное выражение:(ba | b)aa(a | ab)*\nЕго линеаризованная версия:(b_1a_2 | b_3)a_4a_5(a_6 | a_7b_8)*"
    },
    {
        "question": "Линеаризация регулярных выражений - это",
        "answer": "____\n\nЕсли регулярное выражение r ∈ RE (регулярное выражение) содержит n вхождений букв алфавита ∑, то линеаризованное регулярное выражение Linearize(r) получается из r путем присвоения индекса i i-й букве в r.\nРассмотрим регулярное выражение: (ba | b)aa(a | ab)*\nЕго линеаризованная версия: (b_1a_2 | b_3)a_4a_5(a_6 | a_7b_8)*"
    },
    {
        "question": "Линеаризация регулярных выражений",
        "answer": "____\n\nЕсли регулярное выражение r ∈ RE (регулярное выражение) содержит n вхождений букв алфавита ∑, то линеаризованное регулярное выражение Linearize(r) получается из r путем присвоения индекса i i-й букве r.\nРассмотрим регулярное выражение: (ba | b)aa(a | ab)*\nЕго линеаризованная версия: (b_1a_2 | b_3)a_4a_5(a_6 | a_7b_8)*"
    },
    {
        "question": "Линеаризация регулярных выражений",
        "answer": "____\n\nЕсли регулярное выражение r ∈ RE (регулярное выражение) содержит n вхождений букв алфавита ∑, то линеаризованное регулярное выражение Linearize(r) получается из r путем присвоения индекса i i-й букве r.\nРассмотрим регулярное выражение:(ba | b)aa(a | ab)*\nЕго линеаризованная версия: (b_1a_2 | b_3)a_4a_5(a_6 | a_7b_8)*"
    },
    {
        "question": "Множество First Last Follow",
        "answer": "____\n\nПусть регулярное выражение r ∈ RE (регулярное выражение), тогда:Множество First - это множество букв, с которых может начинаться слово из L(r) (если ε ∈ L(r), то оно формально добавляется в First);\nМножество Last- это множество букв, с которых может заканчиваться слово из L(r) \nМножество Follow(c)- это множество букв, с которых может предшествовать c. Т.е. { d ∈ ∑ | ∃ w_1, w_2 (w_1cdw_2 ∈ L(r)) }\nr = (ba | b)aa(a | ab)* - регулярное выражениеFirst(r) = {b}\nLast(r) = {a, b}\nFollow_r(a) = {a, b}; Follow)_r(b) ={a}"
    },
    {
        "question": "Много Первый Последний Подписаться",
        "answer": "____\n\nПусть регулярное выражение r ∈ RE (регулярное выражение), тогда: Множество First — это множество букв, с которых может начинаться слово из L(r) (если ε ∈ L(r), то оно формально добавляется к First);\nМножество Last — это множество букв, с которых может заканчиваться слово из L(r)\nМножество Follow(c) — это множество букв, которым может предшествовать c. То есть, { d ∈ ∑ | ∃ w_1, w_2 (w_1cdw_2 ∈ L(r)) }\nr = (ba | b)aa(a | ab)* — регулярное выражениеFirst(r) = {b}\nLast(r) = {a, b}\nFollow_r(a) = {a, b}; Follow)_r(b) = {a}"
    },
    {
        "question": "Многие Первые Последние Подписка",
        "answer": "____\n\nУчитывая регулярное выражение r ∈ RE (регулярное выражение), тогда: Множество First — это набор букв, с которых может начинаться слово из L(r) (если ε ∈ L(r), то оно формально добавляется к First) ;\nМножество Last — это набор букв, которыми может заканчиваться слово L(r).\nНабор Follow(c) — это набор букв, которым может предшествовать c. Другими словами, { d ∈ ∑ | ∃ w_1, w_2 (w_1cdw_2 ∈ L(r)) }\nr = (ba | b)aa(a | ab)* — регулярное выражениеFirst(r) = {b}\nПоследний(r) = {a, b}\nFollow_r(a) = {a, b}; Следовать)_r(b) = {a}"
    },
    {
        "question": "Много первых последних подписчиков",
        "answer": "____\n\nУчитывая регулярное выражение r ∈ RE (регулярное выражение), тогда: Множество First — это набор букв, с которых может начинаться слово из L(r) (если ε ∈ L(r), то оно формально добавляется к First) ;\nПоследний набор — это набор букв, которыми может заканчиваться слово L(r). \nНабор Follow(c) — это набор букв, которым может предшествовать c. Те. { d ∈ ∑ | ∃ w_1, w_2 (w_1cdw_2 ∈ L(r)) }\nr = (ba | b)aa(a | ab)* - регулярное выражениеFirst(r) = {b}\nПоследний(r) = {a, b}\nFollow_r(a) = {a, b}; Следовать)_r(b) ={a}"
    },
    {
        "question": "Минимализация ДКА алгоритм Хопкрофта",
        "answer": "____\nАлгоритм Хопкрофта для минимизации ДКА (Deterministic Finite Automaton) - это алгоритм, который позволяет найти минимальный ДКА, эквивалентный дадому ДКА.\nАлгоритм Хопкрофта работает следующим образом:\nШаг 1: Инициализация. Создаем начальное разделение на множество Q0 (начальные состояния) и множество Q1,..., Qn-1 (все другие состояния).\nШаг 2: Пока множество разделений более чем из одного элемента, выполняем следующее:\n* Выберите множество A из разделения.\n* Выберите символ c.\n* Для каждого множества B в разделении, разделите B на два подмножества:\n    * B_c: множество состояний в B, которые, прочитав c, переходят в состояние в A.\n    * B_~c: множество состояний в B, которые, прочитав c, не переходят в состояние в A.\n* Добавьте B_c и B_~c в разделение.\nШаг 3: Алгоритм останавливается, когда невозможно выполнить больше разделений.\nТеорема: Алгоритм Хопкрофта останавливается и производит минимальный ДКА.\nАлгоритм Хопкрофта является алгоритмом для поиска минимального ДКА, эквивалентного дадому ДКА, и используется в теории автоматов и регулярных языках."
    },
    {
        "question": "Минимизация алгоритма DFA Хопкрофта",
        "answer": "____\nАлгоритм Хопкрофта для минимизации DFA (детерминированный конечный автомат) — это алгоритм, который находит наименьший DFA, эквивалентный заданному DFA.\nАлгоритм Хопкрофта работает следующим образом:\nШаг 1: Инициализация. Создайте начальное разбиение на множество Q0 (начальные состояния) и множество Q1,..., Qn-1 (все остальные состояния).\nШаг 2: Пока множество разбиений содержит более одного элемента, выполните следующие действия:\n* Выберите множество A из разбиения.\n* Выберите символ c.\n* Для каждого множества B в разбиении разбейте B на два подмножества:\n* B_c: множество состояний в B, которые при чтении c эволюционируют в состояние в A.\n* B_~c: множество состояний в B, которые при чтении c не эволюционируют в состояние в A.\n* Добавьте B_c и B_~c в разбиение.\nШаг 3: Алгоритм останавливается, когда больше разбиений сделать нельзя.\nТеорема: Алгоритм Хопкрофта останавливается и производит минимальный DFA. Алгоритм Хопкрофта — это алгоритм для нахождения минимального DFA, эквивалентного дада DFA, и используется в теории автоматов и регулярных языках."
    },
    {
        "question": "Минимизация алгоритма DFA Хопкрофта",
        "answer": "____\nАлгоритм минимизации детерминированного конечного автомата (DFA) Хопкрофта — это алгоритм, который находит наименьший DFA, эквивалентный заданному DFA.\nАлгоритм Хопкрофта работает следующим образом:\nШаг 1: Инициализация. Создайте начальный раздел в множестве Q0 (начальные состояния) и множестве Q1,..., Qn-1 (все остальные состояния).\nШаг 2. Если разделенный набор содержит несколько элементов, выполните следующие действия:\n* Выберите набор A в партитуре.\n* Выберите символ c.\n* Для каждого набора B в разделе разделите B на два подмножества:\n* B_c: набор состояний в B, которые, читая из c, развиваются к состоянию в A.\n* B_~c: набор состояний в B, которые при чтении c не развиваются к состоянию в A.\n* Добавьте B_c и B_~c к разделению.\nШаг 3: Алгоритм останавливается, когда разделение становится невозможным.\nТеорема: Алгоритм Хопкрофта останавливается и выдает минимальный ДКА. Алгоритм Хопкрофта представляет собой алгоритм поиска минимального DFA-эквивалента Dada DFA и используется в теории автоматов и регулярных языках."
    },
    {
        "question": "Алгоритм Хопкрофта для минимизации DFA",
        "answer": "____\nАлгоритм Хопкрофта для минимизации DFA (детерминированный конечный автомат) — это алгоритм, который позволяет найти минимальный DFA, эквивалентный adom DFA.\nАлгоритм Хопкрофта работает следующим образом:\nШаг 1: Инициализация. Создадим начальное разделение на множество Q0 (начальные состояния) и множество Q1,..., Qn-1 (все остальные состояния).\nШаг 2. Если имеется несколько разделов нескольких предметов, выполните следующие действия:\n* Выберите набор А в разделе.\n* Выберите символ c.\n* Для каждого набора B в разделе разделите B на два подмножества:\n    * B_c: набор состояний в B, которые после чтения c переходят в состояние в A.\n    * B_~c: набор состояний в B, которые после чтения c не переходят в состояние в A.\n*Добавьте B_c и B_~c к разделению.\nШаг 3: Алгоритм останавливается, когда деление невозможно.\nТеорема: Алгоритм Хопкрофта останавливается и выдает минимальный ДКА.\nАлгоритм Хопкрофта — это алгоритм поиска минимального DFA, эквивалентного dom DFA, и используется в теории автоматов и регулярных языках."
    },
    {
        "question": "что такое LTS(Labelled Transition System)",
        "answer": "____\nLTS это тройка <S,∑,Q> где S-множество состояний, ∑ - множество меток, Q - множество переходов <троек из S x ∑ x S>. LTS похожи на автоматы но допускают бесконечные множества S и Q. так же в них нет начальных и финальных \nсостояний"
    },
    {
        "question": "что такое LTS (система маркированного перехода)",
        "answer": "____\nLTS — это тройка <S,∑,Q>, где S — множество состояний, ∑ — множество меток, Q — множество переходов <тройки из S x ∑ x S>. LTS похожи на автоматы, но допускают бесконечные множества S и Q. Они также не имеют начальных и конечных \nсостояний"
    },
    {
        "question": "что такое LTS (система маркированных переходов)",
        "answer": "____\nLTS — это тройка <S,∑,Q>, где S — множество состояний, ∑ — множество меток, Q — множество переходов <тройка S x ∑ x S>. LTS похожи на автоматы, но допускают бесконечные множества S и Q. Они также не имеют начальных и конечных значений. \nгосударства"
    },
    {
        "question": "что такое LTS (система маркированных переходов)",
        "answer": "____\nLTS — это тройка <S,∑,Q>, где S — множество состояний, ∑ — множество меток, Q — множество переходов <тройки S x ∑ x S>. LTS похожи на автоматы, но допускают бесконечные множества S и Q. Они также не имеют начальных и конечных значений. \nгосударства"
    },
    {
        "question": "Если язык L - регулярный, то он задаётся конечным недетерминированным автоматом. Докажи",
        "answer": "____\t\n\nПусть задан алфавит Σ терминальных символов.\nКак строятся регулярные множества, так же и доказывается теорема. Наша задача - доказать, что любое регулярное множество можно задать конечным недетерминированным автоматом. Для начала найдем схему построения автомата для регулярок-констант, т.е. для букв алфавита ∑, потом перейдем к усложнениям.\nПостроим автомат, который распознаёт некоторую букву а ∈ ∑:\nM = <Q, Σ, δ(x,y), q0, F>\nQ = {q0}\nF = {q0}\nδ(q0, a) = q0.\nТ.е. это автомат, распознающий язык {a}. Для языка { }, функция будет пустой, все остальное будет таким же. А для языка ∅ еще и множество допускающих состояний будет пустым, F = ∅.\nТут должен был быть рисунок с диаграммой, но его нет. Диаграмма автомата - обычный ориентированный граф, где вершины - состояния из Q, а те, что из F еще и как-то выделены цветом/обводкой/т.д. Ребро q1 → q2 всегда должно быть подписано буквой из a ∈ ∑, что означает, что (q1, a) = q2. Вот и все.\nНужно построить автомат, распознающий язык L1 + L2\nПо определению: Если языки L1 и L2 - регулярные, то и L1 + L2 - регулярный язык. Пусть L1 распознаётся автоматом M1=<Q1, Σ, δ1, q1, F1>, а L2 распознаётся автоматом M1=<Q2, Σ, δ2, q2, F2> Не ограничивая общности, считаем, что Q1∩Q2 =∅ (достигается обычным переименовыванием). Введём новое состояние q0.\nПусть M распознаёт L1+L2. M=<Q, Σ, δ, q0, F>\nQ=Q1UQ2U{q0}\nδ(q0, a) = δ1(q1,a) U δ2(q2,a)\nδ(q, a)= δ1(q, a); q∈Q1\nδ2(q, a), q∈Q2\nF = F1 U F2\nНужно построить автомат, распознающий язык L1 L2\nПусть M распознаёт L1L2. M=<Q, Σ, δ, q1, F>\nδ1(q, a), если q∈Q1\\F1\nδ(q, a)= δ1(q,a) U δ2(q2,a); q∈F1\nδ2(q, a), q∈Q2\nF=F2\n/здесь не все так просто - если q2 ∈ F2, то F = F1 ∪ F2/\nНужно построить автомат, распознающий язык L1*\nM=<Q, Σ, δ, q0, F>\nF=F1 U {q0}\nδ1(q1, a), если q=q0\nδ(q, a)= δ1(q, a); q∉F1\nδ1(q1,a) U δ1(q,a), q∈F"
    },
    {
        "question": "Если язык L регулярен, то он определяется конечным недетерминированным автоматом. Доказать",
        "answer": "____ \n\nПусть дан алфавит Σ терминальных символов.\nТеорема доказывается так же, как строятся регулярные множества. Наша задача — доказать, что любое регулярное множество можно задать конечным недетерминированным автоматом. Сначала найдем схему построения автомата для постоянных регулярных множеств, т. е. для букв алфавита ∑, затем перейдем к усложнениям.\nПостроим автомат, распознающий некоторую букву a ∈ ∑:\nM = <Q, Σ, δ(x,y), q0, F>\nQ = {q0}\nF = {q0}\nδ(q0, a) = q0.\nТо есть это автомат, распознающий язык {a}. Для языка { } функция будет пустой, все остальное будет таким же. А для языка ∅ множество допускающих состояний также будет пустым, F = ∅.\nЗдесь должна была быть картинка с диаграммой, но ее нет. Диаграмма автомата представляет собой регулярный ориентированный граф, где вершины — это состояния из Q, а вершины из F также выделены каким-то цветом/контуром/и т. д. Ребро q1 → q2 всегда должно быть помечено буквой из a ∈ ∑, что означает, что (q1, a) = q2. Вот и все.\nНам нужно построить автомат, распознающий язык L1 + L2\nПо определению: если языки L1 и L2 регулярны, то L1 + L2 — регулярный язык. Пусть L1 распознается автоматом M1=<Q1, Σ, δ1, q1, F1>, а L2 распознается автоматом M1=<Q2, Σ, δ2, q2, F2> Без потери общности будем считать, что Q1 ∩ Q2 = ∅ (достигается регулярным переименованием). Введем новое состояние q0.\nПусть M распознает L1+L2. M=<Q, Σ, δ, q0, F>\nQ=Q1UQ2U{q0}\nδ(q0, a) = δ1(q1,a) U δ2(q2,a)\nδ(q, a)= δ1(q, a); q∈Q1\nδ2(q, a), q∈Q2\nF = F1 U F2\nНам нужно построить автомат, распознающий язык L1 L2\nПусть M распознает L1L2. M=<Q, Σ, δ, q1, F>\nδ1(q, a), если q∈Q1\\F1\nδ(q, a)= δ1(q, a) U δ2(q2,a); q∈F1\nδ2(q, a), q∈Q2\nF=F2\n/все не так просто - если q2 ∈ F2, то F = F1 ∪ F2/\nНам нужно построить автомат, распознающий язык L1*\nM=<Q, Σ, δ, q0, F>\nF=F1 U {q0}\nδ1(q1, a), если q=q0\nδ(q, a)= δ1(q, a); q∉F1\nδ1(q1,a) U δ1(q,a), q∈F"
    },
    {
        "question": "Если язык L регулярен, то он определяется недетерминированным конечным автоматом. Доказывать",
        "answer": "____ \n\nРассмотрим алфавит терминальных символов Σ.\nТеорема доказывается так же, как и построение регулярных множеств. Наша задача — доказать, что любое регулярное множество можно задать недетерминированным конечным автоматом. Сначала найдем схему построения автомата для постоянных регулярных множеств, то есть для букв алфавита ∑, а затем перейдем к усложнениям.\nПостроим автомат, распознающий букву a ∈ ∑:\nM = <Q, Σ, δ(x,y), q0, F>\nQ = {q0}\nF = {q0}\nδ(q0, a) = q0.\nДругими словами, это автомат, распознающий язык {a}. Для языка { } функция будет пустой, все остальное будет таким же. А для языка ∅ множество допущенных состояний также будет пустым, F = ∅.\nЗдесь должна быть картинка со схемой, но ее нет. Диаграмма автомата представляет собой правильный ориентированный граф, вершины которого являются состояниями Q, а вершины F также выделены цветом/контуром/и т.д. Ребро q1 → q2 всегда должно быть помечено буквой a ∈. ∑, что означает, что (q1,a) = q2. Вот и все.\nНам нужно построить автомат, распознающий язык L1+L2.\nПо определению: если языки L1 и L2 регулярны, то L1+L2 — регулярный язык. Пусть L1 распознается автоматом M1=<Q1, Σ, δ1, q1, F1>, а L2 распознается автоматом M1=<Q2, Σ, δ2, q2, F2>. Без ограничения общности будем считать, что Q1 ∩ Q2 = ∅ (получено регулярным изменением имени). Введем новое состояние q0.\nПусть M распознает L1+L2. M=<Q, Σ, δ, q0, F>\nQ=Q1UQ2U{q0}\nδ(q0,a) = δ1(q1,a) U δ2(q2,a)\nδ(q, a)= δ1(q, a); qεQ1\nδ2(q, a), qεQ2\nФ = Ф1 У Ф2\nНам нужно построить автомат, распознающий язык L1 L2.\nПусть M распознает L1L2. M=<Q, Σ, δ, q1, F>\nδ1(q, a), если qεQ1\\F1\nδ(q, a)= δ1(q, a) U δ2(q2,a); qεF1\nδ2(q, a), qεQ2\nФ=Ф2\n/все не так просто - если q2 ∈ F2, то F = F1 ∪ F2/\nМы должны построить автомат, распознающий язык L1*.\nM=<Q, Σ, δ, q0, F>\nF = F1 U {q0}\nδ1(q1,a), если q=q0\nδ(q, a)= δ1(q, a); q∉F1\nδ1(q1,a) U δ1(q,a), qεF"
    },
    {
        "question": "Если язык L регулярен, то он задается недетерминированным конечным автоматом. Докажи это",
        "answer": "____\t\n\nРассмотрим алфавит терминальных символов Σ.\nСпособ построения регулярных множеств и есть доказательство теоремы. Наша задача — доказать, что любое регулярное множество можно задать недетерминированным конечным автоматом. Сначала найдем схему построения автомата для регулярных констант, то есть для букв алфавита ∑, затем перейдем к усложнениям.\nПостроим автомат, распознающий некоторую букву a ∈ ∑:\nM = <Q, Σ, δ(x,y), q0, F>\nQ = {q0}\nF = {q0}\nδ(q0, a) = q0.\nТе. Это автомат, распознающий язык {a}. Для языка { } функция будет пустой, все остальное будет таким же. А для языка ∅ множество допущенных состояний также будет пустым, F = ∅.\nДолжна была быть картинка со схемой, но ее нет. Диаграмма автомата представляет собой обычный ориентированный граф, где вершины являются состояниями Q, а вершины F также выделены каким-то образом цветом/контуром/и т.д. Ребро q1 → q2 всегда должно быть помечено буквой a ∈ ∑, что означает, что (q1, a) = q2. Вот и все.\nНам нужно построить автомат, распознающий язык L1+L2.\nПо определению: Если языки L1 и L2 регулярны, то L1+L2 — регулярный язык. Пусть L1 распознается автоматом M1=<Q1, Σ, δ1, q1, F1>, а L2 распознается автоматом M1=<Q2, Σ, δ2, q2, F2>. Без ограничения общности будем считать, что Q1 ∩ Q2 =∅ (получено обычной сменой имени). Введем новое состояние q0.\nПусть M распознает L1+L2. M=<Q, Σ, δ, q0, F>\nQ=Q1UQ2U{q0}\nδ(q0,a) = δ1(q1,a) U δ2(q2,a)\nδ(q, a)= δ1(q, a); qεQ1\nδ2(q, a), qεQ2\nФ = Ф1 У Ф2\nНам нужно построить автомат, распознающий язык L1 L2.\nПусть M распознает L1L2. M=<Q, Σ, δ, q1, F>\nδ1(q, a), если qεQ1\\F1\nδ(q,a)= δ1(q,a) U δ2(q2,a); qεF1\nδ2(q, a), qεQ2\nФ=Ф2\n/Здесь не все так просто - если q2 ∈ F2, то F = F1 ∪ F2/\nМы должны построить автомат, распознающий язык L1*.\nM=<Q, Σ, δ, q0, F>\nF = F1 U {q0}\nδ1(q1,a), если q=q0\nδ(q, a)= δ1(q, a); q∉F1\nδ1(q1,a) U δ1(q,a), qεF"
    },
    {
        "question": "Если язык L - регулярный, то он задаётся праволинейной грамматикой. Докажи",
        "answer": "____\nS→ a — грамматика, из которой выводится 1 символ. Пустая грамматика соответствует пустому языку, а грамматика S → соответствует языку { }.\nПусть L1 и L2 - регулярные языки, и задаются грамматиками G1 и G2 соответственно.\nПостроим грамматику, которая задаёт язык L = L1 + L2:\nДобавим один новый нетерминал S: G=<N1 U N2, ∑, P, S>, где N1 - множество нетерминалов из G1, N2\n* множество нетерминалов из G2 Предположим, что N1∩N2=∅. P=P1U P2 и добавим новое правило: S → S1|S2 Построим грамматику, которая задаёт язык L=L1L2 Возьмём из P1 правила A → γ, где γ ∈ ∑*, и заменим их на правила A → γS2 Построим грамматику, которая задаёт язык L=L1\n* \nВозьмём все правила A → γ, где γ ∈ ∑*, и заменим их на правила A → γS1, а так же добавим правило S→"
    },
    {
        "question": "Если язык L регулярен, то он определяется праволинейной грамматикой. Докажите",
        "answer": "____\nS→ a — это грамматика, которая выводит 1 символ. Пустая грамматика соответствует пустому языку, а грамматика S → соответствует языку { }.\nПусть L1 и L2 — это регулярные языки, определяемые грамматиками G1 и G2 соответственно.\nПостроим грамматику, которая определяет язык L = L1 + L2:\nДобавим один новый нетерминал S: G=<N1 U N2, ∑, P, S>, где N1 — это множество нетерминалов из G1, N2\n* множество нетерминалов из G2 Предположим, что N1∩N2=∅. P=P1U P2 и добавьте новое правило: S → S1|S2 Постройте грамматику, которая определяет язык L=L1L2 Возьмите из P1 правила A → γ, где γ ∈ ∑*, и замените их правилами A → γS2 Постройте грамматику, которая определяет язык L=L1\n* \nВозьмите все правила A → γ, где γ ∈ ∑*, и замените их правилами A → γS1, а также добавьте правило S→"
    },
    {
        "question": "Если язык L регулярен, то он определяется прямой линейной грамматикой. Доказывать",
        "answer": "____\nS → a — грамматика, порождающая 1 символ. Пустая грамматика соответствует пустому языку, а грамматика S → соответствует языку { }.\nПусть L1 и L2 — регулярные языки, определяемые соответственно грамматиками G1 и G2.\nПостроим грамматику, определяющую язык L = L1 + L2:\nДобавим новый нетерминал S: G=<N1 U N2, ∑, P, S>, где N1 — множество нетерминалов G1, N2\n* множество нетерминалов группы G2. Предположим, что N1∩N2=∅. P=P1U P2 и добавим новое правило: S → S1|S2 Построим грамматику, определяющую язык L=L1L2. Возьмем из P1 правила A → γ, где γ ∈ ∑*, и заменим их правилами A → γS2 Построим грамматика, определяющая язык L=L1\n* \nВозьмите все правила A → γ, где γ ∈ ∑*, и замените их правилами A → γS1, а также добавьте правило S→"
    },
    {
        "question": "Если язык L регулярен, то он определяется прямой линейной грамматикой. Докажи это",
        "answer": "____\nS → a — грамматика, из которой образован 1 символ. Пустая грамматика соответствует пустому языку, а грамматика S → соответствует языку { }.\nПусть L1 и L2 — регулярные языки, заданные грамматиками G1 и G2 соответственно.\nПостроим грамматику, определяющую язык L = L1 + L2:\nДобавим новый нетерминал S: G=<N1 U N2, ∑, P, S>, где N1 — множество нетерминалов G1, N2\n* множество нетерминалов группы G2. Предположим, что N1∩N2=∅. P=P1U P2 и добавим новое правило: S → S1|S2 Построим грамматику, определяющую язык L=L1L2. Возьмем правила A → γ языка P1, где γ ∈ ∑*, и заменим их правилами A → γS2. построить грамматику, определяющую язык L=L1\n* \nВозьмем все правила A → γ, где γ ∈ ∑*, и заменим их правилами A → γS1, а также добавим правило S→"
    },
    {
        "question": "{a^nb^n| n>=0} is regular?",
        "answer": "____\n\n{a^nb^n| n>=0} is not regular. Let W = {a^k | k >=0}. For every distinct words a^i, a^j ∈ W (i !=j), we have b^i ∈ L^(a^i), but b^j !∈ L^(a^j)"
    },
    {
        "question": "{a^nb^n| n>=0} является правильным?",
        "answer": "____ {a^nb^n| n>=0} не является регулярным. Пусть W = {a^k | k >=0}. Для любых различных слов a^i, a^j ∈ W (i !=j), мы имеем b^i ∈ L^(a^i), но b^j !∈ L^(a^j)"
    },
    {
        "question": "{un^nb^n| n>=0} это правильно?",
        "answer": "____ {a^nb^n| n>=0} не является регулярным. Пусть W = {a^k | к >=0}. Для любого отдельного слова a^i, a^j ∈ W (i !=j) имеем b^i ∈ L^(a^i), но b^j !ε L^(a^j)"
    },
    {
        "question": "{un^nb^n| n>=0} является регулярным?",
        "answer": "____\n\n{un^nb^n| n>=0} не является регулярным. Пусть W = {a^k | к >=0}. Для каждого отдельного слова a^i, a^j ∈ W (i !=j) имеем b^i ∈ L^(a^i), но b^j !ε L^(a^j)"
    },
    {
        "question": "{ww | w ∈ ∑* } regular?",
        "answer": "____\n\n{ww | w ∈ ∑* } is not regular. Let W=Σ*. For every 2 distinct words w, v ∈ W (w !=v), we have that w ∈ L^w, but w !∈ L^v"
    },
    {
        "question": "{ww | w ∈ ∑* } регулярно?",
        "answer": "____ {ww | w ∈ ∑* } не является регулярным. Пусть W=Σ*. Для любых 2 различных слов w, v ∈ W (w !=v) имеем, что w ∈ L^w, но w !∈ L^v"
    },
    {
        "question": "{www | w ∈ ∑* } регулярный?",
        "answer": "____ {www | w ∈ ∑* } не является регулярным. Пусть W=Σ*. Для двух различных слов w, v ∈ W (w !=v) имеем w ∈ L^w, но w !ε L^v"
    },
    {
        "question": "{www | w ∈ ∑* } регулярный?",
        "answer": "____\n\n{www | w ∈ ∑* } не является регулярным. Пусть W=Σ*. Для двух различных слов w, v ∈ W (w !=v) мы имеем w ∈ L^w, но w !ε L^v"
    },
    {
        "question": "1) Лемма о накачке для регулярных языков.",
        "answer": "____\nПусть L регулярный язык. Тогда существует целое p ≥ 1 зависящее только от L, такое что строки w из L длины по меньшей мере p (p называется «длиной накачки») может быть записано как w = xyz, так что:\n1. |y| ≥ 1\n2. |xy| ≤ p\n3. для всех i ≥ 0, x(y^i)z ∈ L\ny — это подстрока, которую можно накачать (удалить или повторить произвольное число раз, так что результат останется в L). (1) означает, что цикл y должен быть накачан хотя бы длиной 1, (2) означает, что цикл должен быть в пределах первых p символов. На x и z ограничений не накладывается."
    },
    {
        "question": "1) Лемма о накачке для регулярных языков.",
        "answer": "____\nПусть L — регулярный язык. Тогда существует целое число p ≥ 1, зависящее только от L, такое, что строки w в L длины не менее p (p называется «длиной накачки») можно записать как w = xyz, так что:\n1. |y| ≥ 1\n2. |xy| ≤ p\n3. для всех i ≥ 0, x(y^i)z ∈ L\ny — подстрока, которую можно накачать (удалить или повторить произвольное количество раз, так что результат останется в L). (1) означает, что цикл y должен быть накачан длиной не менее 1, (2) означает, что цикл должен находиться в пределах первых p символов. Нет никаких ограничений на x и z."
    },
    {
        "question": "1) Лемма о прокачке для регулярных языков.",
        "answer": "____\nПусть L — регулярный язык. Тогда существует целое число p ≥ 1, зависящее только от L, такое, что цепи w в L длины не менее p (p называется «длиной насоса») можно записать w = xyz, так что:\n1. |у| ≥ 1\n2. |ху| ≤p\n3. для всех i ≥ 0 x(y^i)z ∈ L\ny — подстрока, которую можно перекачивать (удалять или повторять произвольное количество раз, чтобы результат оставался в L). (1) означает, что петля y должна быть прокачана длиной не менее 1, (2) означает, что петля должна находиться в пределах первых p символов. Ограничений по x и z нет."
    },
    {
        "question": "1) Лемма о прокачке для регулярных языков.",
        "answer": "____\nПусть L — регулярный язык. Тогда существует целое число p ≥ 1, зависящее только от L, такое, что цепи w из L длины не менее p (p называется «длиной насоса») можно записать w = xyz, так что:\n1. |у| ≥ 1\n2. |ху| ≤p\n3. для всех i ≥ 0 x(y^i)z ∈ L\ny — подстрока, которую можно перекачивать (удалять или повторять произвольное количество раз, чтобы результат оставался в L). (1) означает, что цикл y должен быть накачан длиной не менее 1, (2) означает, что цикл должен находиться в пределах первых p символов. Ограничений по x и z нет."
    },
    {
        "question": "2) Неформальное утверждение и пояснение леммы о накачке для регулярных языков.",
        "answer": "____\n\nЛемма о накачке описывает существенное свойство регулярных языков. Она утверждает, что слово w языка L длины по меньшей мере m, (где m константа, называемая длиной накачки, зависит лишь от L) можно разделить на три подстроки, w = xyz, так что среднюю часть, y (непустую), можно повторить произвольное число раз (включая ноль, то есть удалить) и получить строку из L. Этот процесс повторения называется «накачкой». Более того, лемма о накачке гарантирует, что длина xy не превысит m, ограничивая способы разделения строки w. Заметим, что конечные языки удовлетворяют требованиям леммы о накачке тривиально определяя m длиной максимальной строки из языка плюс один."
    },
    {
        "question": "2) Неформальное изложение и объяснение леммы о накачке для регулярных языков.",
        "answer": "____\n\nЛемма о накачке описывает существенное свойство регулярных языков. Она утверждает, что слово w языка L длиной не менее m (где m — константа, называемая длиной накачки, зависящая только от L) можно разделить на три подстроки, w = xyz, так что средняя часть, y (непустая), может быть повторена произвольное число раз (включая ноль, т. е. удалена), чтобы получить строку в L. Этот процесс повторения называется «накачкой». Более того, лемма о накачке гарантирует, что длина xy не превысит m, ограничивая способы, которыми можно разделить w. Обратите внимание, что конечные языки удовлетворяют требованиям леммы о накачке, тривиально определяя m по длине наибольшей строки в языке плюс один."
    },
    {
        "question": "2) Неформальное изложение и объяснение леммы о накачке для обычных языков.",
        "answer": "____\n\nЛемма о накачке описывает важное свойство регулярных языков. Он гласит, что слово w языка L длины не менее m (где m — константа, называемая длиной накачки, зависящая только от L) можно разделить на три подстроки w = xyz, так что средняя часть y (не -пусто), может повторяться произвольное количество раз (включая ноль, т.е. удаляться) для получения строки в L. Этот процесс повторения называется «накачкой». Кроме того, лемма о накачке гарантирует, что длина xy не превышает m, что ограничивает способы разделения w. Обратите внимание, что конечные языки удовлетворяют требованиям леммы о накачке, тривиально определяя m как длину наибольшей строки языка плюс единица."
    },
    {
        "question": "2) Неформальная формулировка и объяснение леммы о накачке для обычных языков.",
        "answer": "____\n\nЛемма о накачке описывает важное свойство регулярных языков. Он утверждает, что слово w языка L длиной не менее m (где m — константа, называемая длиной накачки, зависящая только от L) можно разделить на три подстроки w = xyz, так что средняя часть y (не- пусто), можно повторить произвольное количество раз (в том числе ноль, т.е. удалить) и получить строку L. Этот процесс повторения называется «накачкой». Кроме того, лемма о накачке гарантирует, что длина xy не превышает m, ограничивая способы разделения w. Обратите внимание, что конечные языки удовлетворяют требованиям леммы о накачке, тривиально определяя m как максимальную длину строки языка плюс единица."
    },
    {
        "question": "3) Использование леммы о накачке для регулярных языков.",
        "answer": "____\nЛемма о накачке часто используется для доказательство того, что некоторый язык не является регулярным: доказательство от противного (предположив регулярность языка) может состоять из нахождения слова (нужной длины) языка, для которого свойство из формулировки леммы не выполняется.\n\nНапример нерегулярность языка L = {(a^n)(b^n) : n ≥ 0} над алфавитом Σ = {a, b} можно показать следующим образом. Пусть w, x, y, z, p, и i заданы соответственно формулировке леммы выше. Пусть w из L задаётся как w = (a^p)(b^p). По лемме о накачке, существует разбиение w = xyz, где |xy| ≤ p, |y| ≥ 1, такое что x(y^i)z принадлежит L для любого i ≥ 0. Если допустить, что |xy|=p, а |z|=p, то xy — это первая часть w, состоящая из p последовательных экземпляров символа a. Поскольку |y| ≥ 1, она содержит по меньшей мере одну букву a, а x(y^2)z содержит больше букв a чем b. Следовательно, x(y^2)z не в языке L (заметим, что любое значение i не равно 1 даст противоречие). Достигнуто противоречие, поскольку в этом случае накачанное слово не принадлежит языку L. Следовательно предположение о регулярности L неверно. Следовательно L — не регулярный язык.\n\nДоказательство нерегулярности языка сбалансированных скобок проводится с той же идеей. Если дано p, существует строка сбалансированных скобочек, начинающихся с более чем p левых скобок, так что y будет содержать только левые скобки. Повторяя y, можно сконструировать строку, в которой не содержится равное количество левых и правых скобок, которая не может быть сбалансированной."
    },
    {
        "question": "3) Использование леммы о накачке для регулярных языков.",
        "answer": "____\nЛемма о накачке часто используется для доказательства того, что какой-то язык не является регулярным: доказательство от противного (предполагая, что язык регулярен) может состоять из нахождения слова (требуемой длины) в языке, для которого свойство, указанное в лемме, не выполняется.\n\nНапример, нерегулярность языка L = {(a^n)(b^n) : n ≥ 0} над алфавитом Σ = {a, b} можно показать следующим образом. Пусть w, x, y, z, p и i заданы так, как указано в лемме выше. Пусть w в L задано как w = (a^p)(b^p). По лемме о накачке существует разбиение w = xyz, где |xy| ≤ p, |y| ≥ 1, такой что x(y^i)z принадлежит L для каждого i ≥ 0. Если предположить, что |xy|=p и |z|=p, то xy — это первая часть w, состоящая из p последовательных вхождений символа a. Поскольку |y| ≥ 1, он содержит по крайней мере одну букву a, а x(y^2)z содержит больше a, чем b. Следовательно, x(y^2)z не принадлежит L (обратите внимание, что любое значение i, не равное 1, приведет к противоречию). Мы пришли к противоречию, поскольку в этом случае прокачиваемое слово не принадлежит L. Следовательно, предположение о том, что L является регулярным, ложно. Следовательно, L не является регулярным языком.\n\nДоказательство нерегулярности языка сбалансированных скобок следует той же идее. При заданном p существует строка сбалансированных скобок, начинающаяся с более чем p левых скобок, поэтому y будет содержать только левые скобки. Повторяя y, можно построить строку, которая не будет содержать одинаковое количество левых и правых скобок, что не может быть сбалансировано."
    },
    {
        "question": "3) Использование леммы о накачке для регулярных языков.",
        "answer": "____\nЛемма о накачке часто используется для доказательства того, что язык не является регулярным: доказательство от противного (в предположении, что язык регулярен) может заключаться в нахождении слова (нужной длины) в языке, для которого свойство, указанное в лемме, не держит.\n\nНапример, языковая неточность L = {(a^n)(b^n): n ≥ 0} в алфавите Σ = {a, b} может быть отображена следующим образом. Пусть w, x, y, z, p и i такие, как указано в лемме выше. Пусть w в L задается формулой w = (a^p)(b^p). По лемме о накачке существует разбиение w = xyz, где |xy| ≤ p, |y| ≥ 1 такой, что x(y^i)z принадлежит L для всех i ≥ 0. Предполагая |xy|=p и |z|=p, тогда xy — это первая часть w, состоящая из p последовательных вхождений символа a. . Поскольку |у| ≥ 1, он содержит хотя бы один a, а x(y^2)z содержит больше a, чем b. Следовательно, x(y^2)z не принадлежит L (обратите внимание, что любое значение i, отличное от 1, приведет к противоречию). Мы пришли к противоречию, так как в этом случае слово pumped не принадлежит L. Следовательно, предположение о регулярности L неверно. Следовательно, L не является регулярным языком.\n\nДоказательство неправильности языка сбалансированных скобок следует той же идее. Учитывая p, существует строка сбалансированных скобок, начинающаяся с более чем p левых скобок, поэтому y будет содержать только левые скобки. Повторяя y, можно построить строку, содержащую разное количество левых и правых скобок, которую невозможно сбалансировать."
    },
    {
        "question": "3) Использование леммы о накачке для регулярных языков.",
        "answer": "____\nЛемма накачки часто используется для доказательства того, что язык не является регулярным: доказательство от противного (в предположении регулярности языка) может заключаться в нахождении слова (нужной длины) языка, для которого свойство в утверждении лемма не выполняется.\n\nНапример, языковая неточность L = {(a^n)(b^n): n ≥ 0} в алфавите Σ = {a, b} может быть отображена следующим образом. Пусть w, x, y, z, p и i следуют формулировке леммы выше. Пусть w из L задано формулой w = (a^p)(b^p). По лемме о накачке существует разбиение w = xyz, где |xy| ≤ p, |y| ≥ 1 такой, что x(y^i)z принадлежит L для всех i ≥ 0. Если предположить, что |xy|=p и |z|=p, то xy — это первая часть w, состоящая из p символов последовательных экземпляры один. Поскольку |у| ≥ 1, он содержит хотя бы один a, а x(y^2)z содержит больше a, чем b. Следовательно, x(y^2)z не принадлежит L (обратите внимание, что любое значение i, отличное от 1, приведет к противоречию). Получено противоречие, поскольку в этом случае завышенное слово не принадлежит языку L. Следовательно, гипотеза о регулярности L неверна. Следовательно, L не является регулярным языком.\n\nДоказательство неправильности языка скобок следует той же идее. Учитывая p, существует строка сбалансированных скобок, начинающаяся с более чем p левых скобок, поэтому y будет содержать только левые скобки. Повторяя y, можно построить строку, не содержащую одинаковое количество левых и правых скобок, которую невозможно сбалансировать."
    },
    {
        "question": "4) Доказательство леммы о накачке",
        "answer": "____\nПусть L — регулярный язык. Тогда по определению регулярности для языка L существует детерминированный конечный автомат (ДКА), который распознает этот язык. Пусть этот автомат имеет p состояний.\n\nТеперь рассмотрим любую строку w из языка L, длина которой |w| ≥ p. По принципу Дирихле (или \"принципу ящиков\"), если мы будем обрабатывать строку w на этом конечном автомате, то при обработке первых p символов строки автомат, проходя по состояниям, обязательно хотя бы одно состояние посетит дважды (поскольку всего состояний p, а символов в строке тоже p или больше).\n\nТаким образом, строку w можно представить в виде трёх частей:\nw = xyz, где:\n 1. x — часть строки, которая ведёт автомат от начального состояния до какого-то состояния;\n 2. y — часть строки, которая соответствует циклу в автомате (повторный визит в одно и то же состояние);\n 3. z — остаток строки после выхода из цикла.\nИз этого представления следует выполнение следующих условий:\n\n1. |y| ≥ 1, потому что y — это непустая часть строки, которая вызывает цикл, иначе повторного посещения одного и того же состояния не было бы.\n2. |xy| ≤ p, потому что цикл происходит в пределах первых p символов строки.\n3. Для всех i ≥ 0, строка вида x(y^i)z тоже принадлежит языку L. Это означает, что мы можем повторять или убирать часть y (которая соответствует циклу в автомате) произвольное количество раз, и полученная строка всё равно будет распознаваться автоматом, следовательно, принадлежать языку L.\nТаким образом, лемма о накачке утверждает, что для любой строки w длиной |w| ≥ p из регулярного языка можно найти разбиение w = xyz, которое удовлетворяет вышеуказанным условиям, что и завершает доказательство."
    },
    {
        "question": "4) Доказательство леммы о накачке",
        "answer": "____\nПусть L — регулярный язык. Тогда по определению регулярности существует детерминированный конечный автомат (ДКА) для L, распознающий этот язык. Пусть этот автомат имеет p состояний.\n\nТеперь рассмотрим любую строку w из L, длина которой |w| ≥ p. По принципу Дирихле (или «принципу кармана»), если мы обработаем строку w на этом автомате, то при обработке первых p символов строки автомат, проходя по состояниям, обязательно посетит хотя бы одно состояние дважды (так как всего состояний p, а символов в строке также p или более).\n\nТаким образом, строку w можно представить в виде трех частей:\nw = xyz, где:\n1. x — часть строки, которая переводит автомат из начального состояния в некоторое состояние;\n2. y — часть строки, которая соответствует циклу в автомате (повторному посещению одного и того же состояния);\n3. z — остаток строки после выхода из цикла.\nЭто представление подразумевает, что выполняются следующие условия:\n\n1. |y| ≥ 1, так как y — непустая часть строки, вызывающая цикл, в противном случае не было бы повторного посещения того же состояния.\n2. |xy| ≤ p, так как цикл происходит в пределах первых p символов строки.\n3. Для всех i ≥ 0 строка вида x(y^i)z также принадлежит языку L. Это означает, что мы можем повторить или удалить часть y (соответствующую циклу в автомате) произвольное количество раз, и полученная строка все равно будет распознана автоматом и, следовательно, будет принадлежать языку L.\nТаким образом, лемма о накачке утверждает, что для любой строки w длины |w| ≥ p в регулярном языке можно найти разбиение w = xyz, удовлетворяющее приведенным выше условиям, что завершает доказательство."
    },
    {
        "question": "4) Доказательство леммы о накачке",
        "answer": "____\nПусть L — регулярный язык. Тогда по определению регулярности существует детерминированный конечный автомат (ДКА) для L, распознающий этот язык. Пусть этот автомат имеет p состояний.\n\nТеперь рассмотрим любую строку w из L, длина которой |w| ≥п. Согласно принципу Дирихле (или «принципу кармана»), если на этом автомате обрабатывать строку w, то при обработке первых p символов строки автомат, проходя состояния, обязательно дважды посетит хотя бы одно состояние. (поскольку всего имеется p состояний, а также p или более символов строк).\n\nТаким образом, строку w можно представить в виде трех частей:\nw = xyz, где:\n1. х - часть цепи, переводящая автомат из исходного состояния в состояние;\n2. y — часть цепочки, соответствующая циклу работы машины (повторяющимся посещениям одного и того же состояния);\n3. z — остаток строки после выхода из цикла.\nДанное представление предполагает выполнение следующих условий:\n\n1. |у| ≥ 1, поскольку y — непустая часть строки, вызывающая цикл, иначе не было бы нового посещения того же состояния.\n2. |ху| ≤ p, поскольку цикл происходит в первых p символах строки.\n3. Для всех i ≥ 0 строка вида x(y^i)z также принадлежит языку L. Это означает, что мы можем повторить или удалить часть y (соответствующую циклу в автомате) произвольного числа количество раз, и полученная строка всегда будет распознана автоматом и, следовательно, будет принадлежать языку L.\nТаким образом, лемма о накачке утверждает, что для любой строки w длины |w| ≥ p в регулярном языке мы можем найти разбиение w = xyz, удовлетворяющее указанным выше условиям, что и завершает доказательство."
    },
    {
        "question": "4) Доказательство леммы о накачке",
        "answer": "____\nПусть L — регулярный язык. Тогда по определению регулярности для языка L существует детерминированный конечный автомат (ДКА), распознающий этот язык. Пусть этот автомат имеет p состояний.\n\nТеперь рассмотрим любую строку w языка L, длина которой |w| ≥п. Согласно принципу Дирихле (или «принципу ящика»), если на этом конечном автомате обрабатывать строку w, то при обработке первых p символов строки автомат, проходя состояния, обязательно посетит хотя бы одно состояние дважды (поскольку всего состояний p и символов p, в строке тоже p или больше).\n\nТаким образом, строку w можно представить в виде трех частей:\nw = xyz, где:\n 1. х - часть линии, переводящая машину из исходного состояния в состояние;\n 2. y — часть цепочки, соответствующая циклу работы машины (повторное посещение одного и того же состояния);\n 3. z — остаток строки после выхода из цикла.\nИз этого представления следует, что выполняются следующие условия:\n\n1. |у| ≥ 1, поскольку y — непустая часть строки, вызывающей цикл, иначе не было бы повторного посещения того же состояния.\n2. |ху| ≤ p, поскольку цикл происходит в первых p символах строки.\n3. Для всех i ≥ 0 строка вида x(y^i)z также принадлежит языку L. Это означает, что мы можем повторить или удалить часть y (которая соответствует циклу в машине) d ' произвольное число несколько раз, и результирующая строка всегда будет распознаваться автоматически и, следовательно, будет принадлежать языку L.\nТаким образом, лемма о накачке утверждает, что для любой строки w длины |w| ≥ p из регулярного языка, мы можем найти разбиение w = xyz, удовлетворяющее указанным выше условиям, что завершает доказательство."
    },
    {
        "question": "5) Обобщённая лемма о накачке для регулярных языков",
        "answer": "____\nЕсли язык L регулярен, то существует число p > 0 (длина накачки), такое что для любой строки uwv из L с |w| ≥ p справедливо представление uwv = uxyzv\nгде x, y и z — строки, такие что |xy| ≤ p, |y| > 0 и ux(y^i)zv принадлежит L для любого целого i ≥ 0.\nЭту версию можно использовать для доказательства нерегулярность ещё большего числа языков, так как она накладывает более строгие ограничения."
    },
    {
        "question": "5) Обобщенная лемма о накачке для регулярных языков",
        "answer": "____\nЕсли L — регулярный язык, то существует число p > 0 (длина накачки) такое, что для любой строки uwv в L с |w| ≥ p, представление uwv = uxyzv справедливо\nгде x, y и z — строки, такие что |xy| ≤ p, |y| > 0, и ux(y^i)zv принадлежит L для любого целого числа i ≥ 0.\nЭту версию можно использовать для доказательства нерегулярности даже большего количества языков, поскольку она накладывает более строгие ограничения."
    },
    {
        "question": "5) Обобщенная лемма о накачке для регулярных языков.",
        "answer": "____\nЕсли L — регулярный язык, то существует число p > 0 (длина насоса) такое, что для любой строки uwv в L с |w| ≥ p, справедливо представление uwv = uxyzv\nгде x, y и z — такие строки, что |xy| ≤ p, |y| > 0, и ux(y^i)zv принадлежит L для любого целого числа i ≥ 0.\nЭту версию можно использовать для доказательства нарушений еще на большем количестве языков, поскольку она налагает более строгие ограничения."
    },
    {
        "question": "5) Обобщенная лемма о накачке для регулярных языков.",
        "answer": "____\nЕсли язык L регулярен, то существует число p > 0 (длина насоса) такое, что для любой строки uwv языка L с |w| ≥ p справедливо представление uwv = uzyzv\nгде x, y и z — такие строки, что |xy| ≤ p, |y| > 0 и ux(y^i)zv принадлежит L для любого целого числа i ≥ 0.\nЭту версию можно использовать для доказательства неправильности еще большего количества языков, поскольку она накладывает более строгие ограничения."
    },
    {
        "question": "6) Недостаточность леммы о накачке для регулярных языков",
        "answer": "____\nЛемма о накачке для регулярных языков — это мощный инструмент для доказательства того, что язык не является регулярным. Однако она имеет ограничения: даже если язык нарушает условия леммы о накачке, это не всегда означает, что он нерегулярен. Лемма не всегда достаточна для доказательства регулярности или нерегулярности языка. Рассмотрим это на примере языка L:\nL={uvwxy:u,y∈{0,1,2,3}∗,vwx∈{0,1,2,3}∧(v=w∨v=x∨x=w)}∪{w:w∈{0,1,2,3}∗}\n\nРассмотрим структуру языка:\n1. Первая часть языка:\n   Это строки uvwxy, где:\n   \tu, y — произвольные строки из {0,1,2,3},\n\tvwx — строка длины 3 из {0,1,2,3},\n\tодно из условий выполняется: v = w, v = x или x = w (хотя бы два символа из vwx совпадают).\n2. Вторая часть языка:\nЭто все строки из {0,1,2,3}, то есть любой возможный набор символов.\n\nПопробуем применить лемму к языку L:\n1. Строки вида uvwxy имеют строгие ограничения на то, как символы v, w и x могут быть связаны между собой (они должны содержать хотя бы два одинаковых символа). Это может потребовать от конечного автомата \"памяти\", чтобы сравнить символы v, w и x, что может привести к нерегулярности языка.\n2. Однако из-за второй части языка (все строки из {0,1,2,3}) лемма о накачке будет бессильна. Любая строка из этой второй части удовлетворяет условиям леммы о накачке, так как она полностью регулярна (конечный автомат может распознать любые строки из {0,1,2,3}). Лемма просто не сможет доказать нерегулярность, потому что вторая часть языка охватывает все строки, которые можно \"накачать\", даже если первая часть не является регулярной.\n\nПочему лемма недостаточна для языка L:\n1. Если мы попытаемся применить лемму о накачке к языку L, она может \"провалиться\" на примерах из второй части языка (где любые строки регулярны). То есть лемма не сможет выявить нерегулярность первой части, так как регулярные строки из второй части будут удовлетворять условиям накачки.\n2. Лемма о накачке не может доказать нерегулярность языка, если в языке присутствуют регулярные составляющие, которые позволяют любым строкам \"успешно пройти\" проверку на условия леммы.\n\nВывод:Лемма о накачке недостаточна для доказательства нерегулярности языка L, поскольку вторая часть языка ({w : w ∈ {0,1,2,3}^*}) состоит из всех строк из {0,1,2,3}, которые всегда удовлетворяют условиям накачки. Это мешает применению леммы для доказательства нерегулярности первой части языка, связанной с условием совпадения символов в строке vwx."
    },
    {
        "question": "6) Недостаточность леммы о накачке для регулярных языков",
        "answer": "____\nЛемма о накачке для регулярных языков — мощный инструмент для доказательства того, что язык не является регулярным. Однако у нее есть ограничения: даже если язык нарушает условия леммы о накачке, это не всегда означает, что он нерегулярен. Леммы не всегда достаточно для доказательства регулярности или нерегулярности языка. Рассмотрим это на примере языка L:\nL={uvwxy:u,y∈{0,1,2,3}∗,vwx∈{0,1,2,3}∧(v=w∨v=x∨x=w)}∪{w:w∈{0,1,2,3}∗}\n\nРассмотрим структуру языка:\n1. Первая часть языка:\nЭто строки uvwxy, где:\nu, y — произвольные строки из {0,1,2,3},\nvwx — строка длины 3 из {0,1,2,3},\nвыполняется одно из условий: v = w, v = x или x = w (по крайней мере два символа из vwx совпадают).\n2. Вторая часть языка:\nЭто все строки из {0,1,2,3}, то есть любой возможный набор символов.\n\nДавайте попробуем применить лемму к языку L:\n1. Строки вида uvwxy имеют строгие ограничения на то, как символы v, w и x могут быть связаны друг с другом (они должны содержать по крайней мере два одинаковых символа). Это может потребовать от конечного автомата наличия «памяти» для сравнения символов v, w и x, что может привести к нерегулярности языка.\n2. Однако из-за второй части языка (все строки из {0,1,2,3}) лемма о накачке не будет работать. Любая строка из этой второй части удовлетворяет лемме о накачке, поскольку она полностью регулярна (конечный автомат может распознавать любые строки из {0,1,2,3}). Лемма просто не может доказать нерегулярность, потому что вторая часть языка охватывает все строки, которые можно «накачать», даже если первая часть не является регулярной.\n\nПочему леммы недостаточно для L:\n1. Если мы попытаемся применить лемму о накачке к L, она может «потерпеть неудачу» на примерах из второй части языка (где любые строки являются регулярными). То есть лемма не сможет выявить нерегулярность первой части, так как регулярные строки из второй части будут удовлетворять условиям накачки.\n2. Лемма о накачке не может доказать нерегулярность языка, если язык содержит регулярные компоненты, которые позволяют любым строкам «успешно проходить» тест на условия леммы.\n\nВывод: леммы о накачке недостаточно для доказательства нерегулярности L, так как вторая часть языка ({w : w ∈ {0,1,2,3}^*}) состоит из всех строк из {0,1,2,3}, которые всегда удовлетворяют условиям накачки. Это не позволяет применить лемму для доказательства неправильности первой части языка, связанной с условием совпадения символов в строке vwx."
    },
    {
        "question": "6) Недостаточность леммы о накачке для регулярных языков.",
        "answer": "____\nЛемма о накачке для регулярных языков — мощный инструмент доказательства того, что язык не является регулярным. Однако это имеет пределы: даже если язык нарушает условия леммы о накачке, это не всегда означает, что он нерегулярен. Леммы не всегда достаточно, чтобы доказать правильность или неправильность языка. Давайте посмотрим на это на примере языка L:\nL={uvwxy:u,yε{0,1,2,3}∗,vwxε{0,1,2,3}∧(v=w∨v=x∨x=w)}∪{w: wε{0,1,2,3}∗}\n\nДавайте посмотрим на структуру языка:\n1. Первая часть языка:\nЭто строки uvwxy, где:\nu, y — произвольные строки {0,1,2,3},\nvwx — строка длины 3 из {0,1,2,3},\nистинно одно из следующих условий: v = w, v = x или x = w (по крайней мере два символа vwx совпадают).\n2. Вторая часть языка:\nЭто все строки {0,1,2,3}, то есть любой возможный набор символов.\n\nПопробуем применить лемму к языку L:\n1. Строки вида uvwxy имеют строгие ограничения на то, как символы v, w и x могут быть связаны друг с другом (они должны содержать не менее двух одинаковых символов). Это может потребовать от конечного автомата наличия «памяти» для сравнения символов v, w и x, что может привести к нарушениям в языке.\n2. Однако из-за второй части языка (все строки в {0,1,2,3}) лемма о прокачке работать не будет. Любая строка во второй части удовлетворяет лемме о накачке, поскольку она полностью регулярна (конечный автомат может распознавать любую строку из {0,1,2,3}). Лемма просто не может доказать нерегулярность, поскольку вторая часть языка охватывает все строки, которые можно «накачать», даже если первая часть не является регулярной.\n\nПочему леммы недостаточно для L:\n1. Если мы попытаемся применить лемму о накачке к L, на примерах из второй части языка (где все строки регулярны) это может оказаться неудачным. Другими словами, лемма не сможет выявить нерегулярность первой части, поскольку правильные ряды второй части будут удовлетворять условиям накачки.\n2. Лемма о накачке не может доказать нерегулярность языка, если язык содержит регулярные компоненты, позволяющие любой строке «пройти» проверку условий леммы.\n\nВывод: леммы о накачке недостаточно для доказательства нерегулярности языка L, так как вторая часть языка ({w : w ∈ {0,1,2,3}^*}) состоит из всех строк {0,1 ,2,3}, которые всегда удовлетворяют условиям накачки. Это не позволяет применить лемму для доказательства неточности первой части языка, связанной с условием совпадения символов в строке vwx."
    },
    {
        "question": "6) Недостаточность леммы о накачке для регулярных языков.",
        "answer": "____\nЛемма о накачке для регулярных языков — мощный инструмент доказательства того, что язык не является регулярным. Однако это имеет пределы: даже если язык нарушает условия леммы о накачке, это не всегда означает, что он нерегулярен. Леммы не всегда достаточно, чтобы доказать правильность или неправильность языка. Давайте посмотрим на это на примере языка L:\nL={uvwxy:u,yε{0,1,2,3}∗,vwxε{0,1,2,3}∧(v=w∨v=x∨x=w)}∪{w: wε{0,1,2,3}∗}\n\nДавайте посмотрим на структуру языка:\n1. Первая часть языка:\n   Это строки uvwxy, где:\n   \tu, y — произвольные строки {0,1,2,3},\n\tvwx — строка длины 3 из {0,1,2,3},\n\tвыполнено одно из условий: v = w, v = x или x = w (соответствуют как минимум два символа vwx).\n2. Вторая часть языка:\nЭто все строки {0,1,2,3}, то есть любой возможный набор символов.\n\nПопробуем применить лемму к языку L:\n1. Строки вида uvwxy имеют строгие ограничения на то, как символы v, w и x могут быть связаны друг с другом (они должны содержать не менее двух одинаковых символов). Это может потребовать от конечного автомата «запомнить» сравнение символов v, w и x, что может привести к неправильному языку.\n2. Однако из-за второй части языка (все строки {0,1,2,3}) лемма о накачке будет бессильна. Любая строка во второй части удовлетворяет условиям леммы о накачке, поскольку она полностью регулярна (конечный автомат может распознавать любую строку из {0,1,2,3}). Лемма просто не может доказать нерегулярность, поскольку вторая часть языка охватывает все строки, которые можно «накачать», даже если первая часть не является регулярной.\n\nПочему леммы недостаточно для языка L:\n1. Если мы попытаемся применить лемму о накачке к языку L, она может оказаться неудачной на примерах из второй части языка (где все строки регулярны). Другими словами, лемма не сможет выявить нерегулярность первой части, поскольку правильные ряды второй части будут удовлетворять условиям накачки.\n2. Лемма о накачке не может доказать нерегулярность языка, если язык содержит регулярные компоненты, позволяющие любой строке «пройти» проверку условий леммы.\n\nВывод: леммы о накачке недостаточно для доказательства нерегулярности языка L, поскольку вторая часть языка ({w: w ∈ {0,1,2,3}^*}) состоит из всех цепей из {0,1,2,3}, которые всегда удовлетворяют условиям накачки. Это предотвращает использование леммы для доказательства нерегулярности первой части языка, связанной с условием совпадения символов в строке vwx."
    },
    {
        "question": "7) Делинеаризация регулярных выражений",
        "answer": "____\nДелинеаризация регулярных выражений — это процесс обратный линеаризации, который заключается в преобразовании регулярных выражений из линейной, упрощенной формы в более компактную или структурированную форму, обычно с использованием группировок и повторений для уменьшения объема кода и лучшего представления логики регулярного выражения. Делинеаризация помогает восстановить исходную структуру регулярного выражения, делая его более организованным и легко поддерживаемым."
    },
    {
        "question": "7) Делинеаризация регулярных выражений",
        "answer": "____\nДелинеаризация регулярных выражений — это обратный процесс линеаризации, который включает преобразование регулярных выражений из линейной, упрощенной формы в более компактную или структурированную форму, обычно с использованием группировки и повторения для уменьшения объема кода и лучшего представления логики регулярного выражения. Делинеаризация помогает восстановить исходную структуру регулярного выражения, делая его более организованным и простым в обслуживании."
    },
    {
        "question": "7) Делинеаризация регулярных выражений",
        "answer": "____\nДелинеаризация регулярных выражений — это обратный процесс линеаризации преобразования регулярных выражений из линейной, упрощенной формы в более компактную или структурированную форму, обычно с использованием группировки и повторения для уменьшения размера кода и лучшего представления логики регулярных выражений. Делинеаризация помогает восстановить исходную структуру регулярного выражения, делая его более организованным и простым в обслуживании."
    },
    {
        "question": "7) Делинеаризация регулярных выражений",
        "answer": "____\nДелинеаризация регулярных выражений — это процесс, обратный линеаризации, который включает преобразование регулярных выражений из линейной, упрощенной формы в более компактную или структурированную форму, обычно с использованием группировки и повторения для уменьшения размера кода и лучшего представления логики регулярного выражения. Делинеаризация помогает восстановить исходную структуру регулярного выражения, делая его более организованным и простым в обслуживании."
    },
    {
        "question": "8) Зачем нужна делинеаризация?",
        "answer": "____\n1. Компактность: Линейные регулярные выражения, особенно если они содержат много альтернатив или повторяющихся частей, могут стать громоздкими. Делинеаризация помогает сократить объем выражения и улучшить его читаемость.\n2. Повышение читаемости: Делинеаризация добавляет структуру регулярному выражению. Сгруппированные части могут помочь лучше понять логику выражения, особенно когда разные части разделены на логические компоненты.\n3. Поддерживаемость: Регулярное выражение, состоящее из множества линейных альтернатив, сложно поддерживать и модифицировать. Группировка общих частей и использование сокращений делает выражение проще для внесения изменений в будущем."
    },
    {
        "question": "8) Зачем нужна делинеаризация?",
        "answer": "____\n1. Компактность: линейные регулярные выражения, особенно если они содержат много альтернатив или повторяющихся частей, могут стать громоздкими. Делинеаризация помогает сократить длину выражения и улучшить его читаемость.\n2. Улучшенная читаемость: делинеаризация добавляет структуру регулярному выражению. Группировка частей может помочь сделать логику выражения более понятной, особенно когда разные части разделены на логические компоненты.\n3. Поддерживаемость: регулярное выражение, состоящее из множества линейных альтернатив, трудно поддерживать и изменять. Группировка общих частей и использование сокращений облегчают изменение выражения в будущем."
    },
    {
        "question": "8) Почему необходима делинеаризация?",
        "answer": "____\n1. Компактность. Линейные регулярные выражения, особенно если они содержат множество альтернатив или повторяющихся частей, могут стать громоздкими. Делинеаризация позволяет уменьшить длину выражения и улучшить его читаемость.\n2. Улучшенная читабельность: делинеаризация добавляет структуру регулярному выражению. Группирование частей может помочь сделать логику выражения более понятной, особенно когда разные части разделены на логические компоненты.\n3. Удобство сопровождения. Регулярное выражение, состоящее из множества линейных альтернатив, сложно поддерживать и изменять. Группировка общих областей и использование сокращений облегчают изменение выражения в будущем."
    },
    {
        "question": "8) Почему необходима делинеаризация?",
        "answer": "____\n1. Компактность. Линейные регулярные выражения, особенно если они содержат множество альтернатив или повторяющихся частей, могут стать громоздкими. Делинеаризация позволяет уменьшить длину выражения и улучшить его читаемость.\n2. Улучшенная читаемость: делинеаризация добавляет структуру регулярному выражению. Сгруппированные части могут помочь вам лучше понять логику выражения, особенно когда разные части разделены на логические компоненты.\n3. Удобство сопровождения. Регулярное выражение, состоящее из множества линейных альтернатив, сложно поддерживать и изменять. Группировка общих областей и использование сокращений облегчают изменение выражения в будущем."
    },
    {
        "question": "9) Этапы делинеаризации",
        "answer": "____\n1. Поиск общих элементов: Найдите части регулярного выражения, которые повторяются в альтернативных путях, и вынесите их за скобки. Например, в выражении abd|acd, можно вынести часть a и d, так как они повторяются в обеих альтернативных ветвях.\n2. Использование группировок: После нахождения общих элементов, сгруппируйте различающиеся части в выражении с помощью скобок. Это позволит вам сократить избыточные части выражения.\n3. Оптимизация повторений: Если в регулярном выражении присутствуют однотипные повторения символов или групп, используйте квантификаторы (*, +, {n} и другие), чтобы компактно выразить повторение."
    },
    {
        "question": "9) Этапы делинеаризации",
        "answer": "____\n1. Поиск общих элементов: найдите части регулярного выражения, которые повторяются в альтернативных путях, и вынесите их за скобки. Например, в выражении abd|acd можно вынести части a и d, так как они повторяются в обеих альтернативных ветвях.\n2. Использование группировок: после нахождения общих элементов сгруппируйте различные части выражения с помощью скобок. Это позволит вам сократить избыточные части выражения.\n3. Оптимизация повторений: если регулярное выражение содержит похожие повторения символов или групп, используйте квантификаторы (*, +, {n} и т. д.) для компактного выражения повторения."
    },
    {
        "question": "9) Этапы делинеаризации",
        "answer": "____\n1. Найдите общие элементы. Найдите части регулярного выражения, которые повторяются в альтернативных путях, и заключите их в круглые скобки. Например, в выражении abd|acd можно удалить части a и d, поскольку они повторяются в двух альтернативных ветвях.\n2. Использование группировок. Найдя общие элементы, сгруппируйте различные части выражения, используя круглые скобки. Это позволит вам удалить лишние части выражения.\n3. Оптимизация повторений. Если регулярное выражение содержит похожие повторения символов или групп, используйте квантификаторы (*, +, {n} и т. д.), чтобы уплотнить выражение повторения."
    },
    {
        "question": "9) Этапы делинеаризации",
        "answer": "____\n1. Найдите общие элементы. Найдите части регулярного выражения, которые повторяются в альтернативных путях, и заключите их в круглые скобки. Например, в выражении abd|acd можно удалить части a и d, поскольку они повторяются в двух альтернативных ветвях.\n2. Использование группировок. Найдя общие элементы, сгруппируйте различные части выражения, используя круглые скобки. Это позволит вам удалить лишние части выражения.\n3. Оптимизация повторений. Если регулярное выражение содержит похожие повторения символов или групп, используйте кванторы (*, +, {n} и другие), чтобы компактно выразить повторение."
    },
    {
        "question": "10) Преимущества делинеаризации",
        "answer": "____\n1. Улучшенная читаемость: Делинеаризованное выражение легче читать и понимать, так как оно отображает логику в более организованной форме.\n2. Меньший объем кода: После делинеаризации выражение часто становится короче, так как многие элементы можно вынести и сократить.\n3. Проще в модификации: Делинеаризованное регулярное выражение проще модифицировать и поддерживать, так как его структура лучше отражает логику проверки."
    },
    {
        "question": "10) Преимущества делинеаризации",
        "answer": "____\n1. Улучшенная читаемость: делинеаризованное выражение легче читать и понимать, поскольку оно отображает логику в более организованной форме.\n2. Меньший объем кода: после делинеаризации выражение часто становится короче, поскольку многие элементы можно вынести за скобки и сократить.\n3. Легче модифицировать: делинеаризованное регулярное выражение легче модифицировать и поддерживать, поскольку его структура лучше отражает логику проверки."
    },
    {
        "question": "10) Преимущества делинеаризации",
        "answer": "____\n1. Улучшенная читаемость. Делинеаризованное выражение легче читать и понимать, поскольку оно отображает логику в более организованной форме.\n2. Меньше кода. После делинеаризации выражение часто становится короче, поскольку многие элементы можно заключить в квадратные скобки и сократить.\n3. Легче модифицировать. Делинеаризованное регулярное выражение легче модифицировать и поддерживать, поскольку его структура лучше отражает логику проверки."
    },
    {
        "question": "10) Преимущества делинеаризации",
        "answer": "____\n1. Улучшенная читаемость. Делинеаризованное выражение легче читать и понимать, поскольку оно отображает логику в более организованной форме.\n2. Меньше кода. После делинеаризации выражение часто становится короче, поскольку многие элементы можно удалить и сократить.\n3. Легче модифицировать. Делинеаризованное регулярное выражение легче модифицировать и поддерживать, поскольку его структура лучше отражает логику проверки."
    },
    {
        "question": "11) Недостатки делинеаризации",
        "answer": "____\n1. Может усложнить понимание: В некоторых случаях слишком сложные группировки могут сделать регулярное выражение менее понятным, особенно для тех, кто не знаком с использованием квантификаторов и группировок.\n2. Не всегда применимо: Не каждое линейное выражение можно делинеаризовать эффективно. Если в выражении нет очевидных повторений или общих частей, попытка делинеаризации может не дать значительного улучшения."
    },
    {
        "question": "11) Недостатки делинеаризации",
        "answer": "____\n1. Может усложнить понимание: в некоторых случаях слишком сложные группировки могут сделать регулярное выражение менее понятным, особенно для тех, кто не знаком с использованием квантификаторов и группировок.\n2. Не всегда применимо: не каждое линейное выражение можно эффективно делинеаризировать. Если в выражении нет очевидных повторений или общих частей, попытка делинеаризации может не дать большого улучшения."
    },
    {
        "question": "11) Недостатки делинеаризации",
        "answer": "____\n1. Может затруднить понимание. В некоторых случаях слишком сложные группировки могут сделать регулярное выражение менее понятным, особенно для тех, кто не знаком с использованием кванторов и группировок.\n2. Не всегда применимо: не все линейные выражения можно эффективно делинеаризовать. Если в выражении нет явных повторов или общих частей, попытка делинеаризации может не дать большого улучшения."
    },
    {
        "question": "11) Недостатки делинеаризации",
        "answer": "____\n1. Может затруднить понимание. В некоторых случаях слишком сложные группировки могут сделать регулярное выражение менее понятным, особенно для тех, кто не знаком с использованием кванторов и группировок.\n2. Не всегда применимо: не все линейные выражения можно эффективно делинеаризовать. Если в выражении нет явных повторов или общих частей, попытка делинеаризации может не дать большого улучшения."
    },
    {
        "question": "12) Формальные языки",
        "answer": "____\nФормальный язык — это множество M слов над алфавитом Σ(обозначается M ⊆ Σ∗, здесь знак ∗ — итерация Клини). Обычно подразумевает наличие формальных правил, определяющих корректность формы (т.е. синтаксиса) слов из M."
    },
    {
        "question": "12) Формальные языки",
        "answer": "____\nФормальный язык — это множество M слов в алфавите Σ (обозначается M ⊆ Σ∗, где знак ∗ — итерация Клини). Обычно подразумевает наличие формальных правил, определяющих правильность формы (т. е. синтаксиса) слов из M."
    },
    {
        "question": "12) Формальные языки",
        "answer": "____\nФормальный язык — это множество M слов алфавита Σ (обозначается M ⊆ Σ∗, где знак ∗ — итерация Клини). Обычно предполагает наличие формальных правил, определяющих правильную форму (т.е. синтаксис) слов М."
    },
    {
        "question": "12) Формальные языки",
        "answer": "____\nФормальный язык — это множество M слов алфавита Σ (отмечено M ⊆ Σ∗, здесь знак ∗ — это итерация Клини). Обычно предполагает наличие формальных правил, определяющих правильную форму (т.е. синтаксис) слов М."
    },
    {
        "question": "13) Перечислимость и разрешимость формальных языков",
        "answer": "____\nЯзык M разрешимый ⇔ для любого слова w существует алгоритм проверки принадлежности w к M(всегда завершающийся и дающий точный, либо положительный, либо отрицательный ответ). \nЯзык M перечислимый ⇔ для любого слова w существует алгоритм, положительно отвечающий на вопрос принадлежности w к M за конечное время (но, возможно, зацикливающийся, если w /∈ M). \nПеречислимый, но не разрешимый: язык программ, завершающихся на входе 0 (на любом достаточно мощном ЯП). Далее разрешимые языки можно классифицировать по минимально необходимой сложности разрешающего алгоритма."
    },
    {
        "question": "13) Перечислимость и разрешимость формальных языков",
        "answer": "____\nЯзык M разрешим ⇔ для любого слова w существует алгоритм проверки принадлежности w к M (всегда завершающийся и дающий точный, положительный или отрицательный, ответ).\n\nЯзык M перечислим ⇔ для любого слова w существует алгоритм, который отвечает на вопрос принадлежности w к M положительно за конечное время (но может зацикливаться, если w /∈ M).\n\nПеречислимый, но не разрешимый: язык программ, завершающихся на входе 0 (в любом достаточно мощном ЯП). Кроме того, разрешимые языки можно классифицировать по минимально необходимой сложности алгоритма принятия решения."
    },
    {
        "question": "13) Перечислимость и разрешимость формальных языков.",
        "answer": "____\nЯзык M разрешим ⇔ для любого слова w существует алгоритм проверки принадлежности слова w к M (заканчивающийся и всегда дающий точный ответ, положительный или отрицательный).\n\nПеречислив язык M ⇔ для любого слова w, существует алгоритм, который отвечает на вопрос, принадлежит ли w положительному слову M за конечное время (но может зацикливаться, если w /ε M).\n\nПеречислимый, но неразрешимый: язык для программ, завершающихся на входе 0 (на любом достаточно мощном языке). Дополнительно разрешимые языки можно классифицировать по минимально необходимой сложности алгоритма принятия решений."
    },
    {
        "question": "13) Перечислимость и разрешимость формальных языков.",
        "answer": "____\nЯзык M разрешим ⇔ для любого слова w существует алгоритм проверки принадлежности слова w к M (всегда заканчивающийся и дающий точный ответ, положительный или отрицательный). \nЯзык M перечислим ⇔ для любого слова w существует алгоритм, который положительно отвечает на вопрос о том, принадлежит ли w M за конечное время (но, возможно, зацикливается, если w /ε M). \nПеречислимый, но неразрешимый: язык для программ, завершающихся на входе 0 (на любом достаточно мощном языке программирования). Дополнительно разрешимые языки можно классифицировать по минимально необходимой сложности алгоритма решения."
    },
    {
        "question": "14) Системы переписывания термов",
        "answer": "____\nСигнатура — множество пар ⟨f, n⟩ из имени конструктора f и его местности n.\nПусть V — множество переменных, F — множество конструкторов; множество термов T(F) над F определяется рекурсивно:\n1. все элементы V — термы;\n2. если ⟨f, n⟩ — конструктор и t_1,. . . , t_n — термы, то f(t_1, . . . , t_n) — терм;\n3. других термов нет.\n\nПусть V — множество переменных, F — множество конструкторов (сигнатура); T(F) — множество термов над множеством конструкторов F. TRS — набор правил переписывания вида Φ_i → Ψ_i, где Φ_i, Ψ_i — термы в T(F). Правило переписывания Φ_i → Ψ_i применимо к терму t, если t содержит подтерм, который можно сопоставить (унифицировать) с Φ_i.\n\nЕсли к терму t не применимо ни одно правило переписывания TRS, терм называется нормализованным. Имея правила переписывания вида f(g(x)) → g(g(f(x))) и g(g(x)) → f(x), каждое из них можно применить к терму f(g(g(f(g(f(g(g(g(Z))))))))) тремя разными способами."
    },
    {
        "question": "14) Системы переписывания терминов",
        "answer": "____\nСигнатура — это набор пар ⟨f, n⟩, состоящий из имени конструктора f и его округа n.\nПусть V — набор переменных, F — набор конструкторов; набор термов T(F) над F определяется рекурсивно:\n1. все элементы V являются термовами;\n2. если ⟨f, n⟩ — конструктор и t_1,. . . , t_n — термовы, то f(t_1, . . . , t_n) — термовы;\n3. других термов нет.\n\nПусть V — набор переменных, F — набор конструкторов (сигнатура); T(F) — набор термов над набором конструкторов F. TRS — это набор правил переписывания вида Φ_i → Ψ_i, где Φ_i, Ψ_i — термовы в T(F). Правило переписывания Φ_i → Ψ_i применяется к термину t, если t содержит подтерм, который может быть отображен (унифицирован) в Φ_i.\n\nЕсли ни одно правило переписывания TRS не применяется к термину t, термин называется нормализованным. Учитывая правила переписывания вида f(g(x)) → g(g(f(x))) и g(g(x)) → f(x), каждое из них может быть применено к термину f(g(g(f(g(f(g(g(g(Z))))))))) тремя различными способами."
    },
    {
        "question": "14) Системы переписывания терминов",
        "answer": "____\nПодпись — это набор пар ⟨f, n⟩, состоящий из имени конструктора f и его окрестности n.\nПусть V — набор переменных, F — набор конструкторов; множество термов T(F) на F определяется рекурсивно:\n1. все элементы V являются термами;\n2. если ⟨f, n⟩ — конструктор и t_1,. . . , t_n — термические, тогда f(t_1,..., t_n) — термические;\n3. других условий нет.\n\nПусть V — набор переменных, F — набор конструкторов (сигнатура); T(F) — набор термов на множестве конструкторов F. TRS — набор правил переписывания вида Φ_i → Ψ_i, где Φ_i, Ψ_i — термы из T(F). Правило переписывания Φ_i → Ψ_i применяется к терму t, если t содержит подтерм, который можно отобразить (унифицировать) в Φ_i.\n\nЕсли к термину t не применимо правило переписывания TRS, этот термин называется нормализованным. Учитывая правила переписывания вида f(g(x)) → g(g(f(x))) и g(g(x)) → f(x), каждое из них можно применить к терму f( g (g( f(g(f(g(g(Z)))))))) тремя разными способами."
    },
    {
        "question": "14) Системы переписывания терминов",
        "answer": "____\nСигнатура представляет собой набор пар ⟨f, n⟩ имени конструктора f и его местоположения n.\nПусть V — набор переменных, F — набор конструкторов; множество термов T(F) на F определяется рекурсивно:\n1. все элементы V являются термами;\n2. если ⟨f, n⟩ — конструктор и t_1,. . . , t_n — термины, тогда f(t_1,..., t_n) — термин;\n3. других условий нет.\n\nПусть V — набор переменных, F — набор конструкторов (сигнатура); T(F) — набор термов на множестве конструкторов F. TRS — набор правил перезаписи вида Φ_i → Ψ_i, где Φ_i, Ψ_i — термы из T(F). Правило переписывания Φ_i → Ψ_i применяется к терму t, если t содержит подтерм, который можно отобразить (унифицировать) в Φ_i.\n\nЕсли к термину t не применимо правило переписывания TRS, этот термин называется нормализованным. Имея правила переписывания вида f(g(x)) → g(g(f(x))) и g(g(x)) → f(x), каждое из них можно применить к терму f (g (g(f (g(f(g(g(g(Z))))))))) тремя разными способами."
    },
    {
        "question": "15) Конфлюэнтность",
        "answer": "____\nTRS называется конфлюэнтной, если для любых двух термов t, s, которые получаются переписыванием одного и того же терма u, существует терм v такой, что t, s оба переписываются в v.\nФормально:\n∀u, t, s(u →∗t & u →∗s ⇒ ∃v(t →∗ v & s →∗ v))\n\nКонфлюэнтные системы поддаются распараллеливанию и легко оптимизируются.\n→ — переписывание за 1 шаг;\n→∗ — переписывание за произвольное число шагов,\nначиная с 0."
    },
    {
        "question": "15) Слияние",
        "answer": "____\nTRS называется конфлюэнтной, если для любых двух терминов t, s, полученных путем переписывания одного и того же термина u, существует термин v такой, что t, s оба переписываются в v.\nФормально:\n∀u, t, s(u →∗t & u →∗s ⇒ ∃v(t →∗ v & s →∗ v))\n\nКонфлюэнтные системы параллелизуемы и легко оптимизируются.\n→ — переписывание за 1 шаг;\n→∗ — переписывание за произвольное количество шагов,\nначиная с 0."
    },
    {
        "question": "15) Слияние",
        "answer": "____\nTRS называется конфлюэнтным, если для любых двух термов t, s, полученных переписыванием одного и того же терма u, существует терм v такой, что оба t, s переписаны в v.\nОфициально:\n∀u, t, s(u →∗t & u →∗s ⇒ ∃v(t →∗ v & s →∗ v))\n\nКонфлюэнтные системы поддаются распараллеливанию и легко оптимизируются.\n→ — переписывание в 1 шаг;\n→∗ — перезапись за произвольное количество шагов,\nот 0."
    },
    {
        "question": "15) Слияние",
        "answer": "____\nTRS называется конфлюэнтным, если для любых двух термов t, s, полученных переписыванием одного и того же терма u, существует терм v такой, что оба t, s переписаны в v.\nОфициально:\n∀u, t, s(u →∗t & u →∗s ⇒ ∃v(t →∗ v & s →∗ v))\n\nКонфлюэнтные системы можно распараллеливать и легко оптимизировать.\n→ — переписывание в 1 шаг;\n→∗ — перезапись за произвольное количество шагов,\nот 0."
    },
    {
        "question": "16) Синтаксический моноид",
        "answer": "____\nМоноид — это алгебраическая структура, состоящая из множества MM с бинарной операцией ⋅ (умножение), которая:\n1. ассоциативна: (a⋅b)⋅c=a⋅(b⋅c) для любых a, b ,c ∈ M;\n2. имеет единичный элемент e ∈ M, такой что для любого a ∈ M выполнено e⋅a=a⋅e =a.\n\nФакторизация по отношению к языку: Чтобы построить синтаксический моноид для языка, сначала определим отношение факторизации по отношению к языку L⊆Σ∗ (где Σ∗ — множество всех строк над алфавитом Σ).\n\nДве строки u и v считаются эквивалентными по отношению к языку L, если для всех строк x,y ∈ Σ∗ выполнение условия xuy ∈ L эквивалентно xvy ∈ L. Это эквивалентное отношение называется синтаксической эквивалентностью и обозначается u ∼_L v.\n\nСвязь с конечными автоматами:\nСинтаксический моноид можно использовать для описания регулярных языков. Для любого регулярного языка его синтаксический моноид является конечным, а язык можно распознать с помощью конечного автомата, построенного на основе этого моноида. Это означает, что синтаксический моноид является мощным инструментом для анализа структуры регулярных языков и их поведения.\n\nТеорема Микана: Язык является регулярным тогда и только тогда, когда его синтаксический моноид является конечным.\n\nПрименение:\n1. Классификация регулярных языков: Синтаксический моноид позволяет описывать регулярные языки с точки зрения алгебраической структуры. Это особенно полезно при анализе и классификации языков.\n2. Определение сложности языков: Сложность синтаксического моноида (например, количество его элементов) может дать представление о сложности описания языка.\n3. Минимизация конечных автоматов: Используя синтаксические моноиды, можно строить минимальные конечные автоматы, которые эффективно распознают регулярные языки."
    },
    {
        "question": "16) Синтаксический моноид",
        "answer": "____\nМоноид — это алгебраическая структура, состоящая из множества MM с бинарной операцией ⋅ (умножение), которая:\n1. является ассоциативной: (a⋅b)⋅c=a⋅(b⋅c) для любых a, b ,c ∈ M;\n2. имеет единичный элемент e ∈ M такой, что для любого a ∈ M имеем e⋅a=a⋅e =a.\n\nФакторизация относительно языка: Чтобы построить синтаксический моноид для языка, мы сначала определяем отношение факторизации относительно языка L⊆Σ∗ (где Σ∗ — множество всех строк над алфавитом Σ).\n\nДве строки u и v называются эквивалентными относительно языка L, если для всех строк x,y ∈ Σ∗ условие xuy ∈ L эквивалентно xvy ∈ L. Это отношение эквивалентности называется синтаксической эквивалентностью и обозначается как u ∼_L v.\n\nОтношение к конечным автоматам:\nСинтаксический моноид может быть использован для описания регулярных языков. Для любого регулярного языка его синтаксический моноид конечен, и язык может быть распознан конечным автоматом, построенным поверх этого моноида. Это означает, что синтаксический моноид является мощным инструментом для анализа структуры регулярных языков и их поведения.\n\nТеорема Микана: Язык является регулярным тогда и только тогда, когда его синтаксический моноид конечен.\n\nПриложения:\n1. Классификация регулярных языков: синтаксический моноид позволяет нам описывать регулярные языки в терминах их алгебраической структуры. Это особенно полезно при анализе и классификации языков.\n2. Определение сложности языков: сложность синтаксического моноида (например, количество его элементов) может дать представление о сложности описания языка. 3. Минимизация конечных автоматов: используя синтаксические моноиды, можно построить минимальные конечные автоматы, которые эффективно распознают регулярные языки."
    },
    {
        "question": "16) Синтаксический моноид",
        "answer": "____\nМоноид – это алгебраическая структура, состоящая из множества ММ с бинарной операцией ⋅ (умножения), которая:\n1. ассоциативен: (a⋅b)⋅c=a⋅(b⋅c) для всех a, b, c ∈ M;\n2. имеет единичный элемент e ∈ M такой, что для всех a ∈ M имеем e⋅a=a⋅e =a.\n\nФакторизация относительно языка. Чтобы построить синтаксический моноид для языка, мы сначала определяем отношение факторизации относительно языка L⊆Σ∗ (где Σ∗ — множество всех строк в алфавите Σ).\n\nДве строки u и v называются эквивалентными относительно языка L, если для всех строк x,y ∈ Σ∗ условие xuy ∈ L эквивалентно условию xvy ∈ L. Это отношение эквивалентности называется синтаксической эквивалентностью и обозначается и ∼_L v.\n\nСвязь с конечными автоматами:\nСинтаксический моноид можно использовать для описания обычных языков. Для любого регулярного языка его синтаксический моноид конечен, и язык может быть распознан конечным автоматом, построенным на основе этого моноида. Это означает, что синтаксический моноид — мощный инструмент для анализа структуры обычных языков и их поведения.\n\nТеорема Микана: язык регулярен тогда и только тогда, когда его синтаксический моноид конечен.\n\nПриложения:\n1. Классификация регулярных языков. Синтаксический моноид позволяет описывать регулярные языки по их алгебраической структуре. Это особенно полезно для анализа и классификации языков.\n2. Определить сложность языков: Сложность синтаксического моноида (например, количество его элементов) может дать представление о сложности описания языка. 3. Минимизация конечных автоматов. Используя синтаксические моноиды, можно построить минимальные конечные автоматы, которые эффективно распознают регулярные языки."
    },
    {
        "question": "16) Синтаксический моноид",
        "answer": "____\nМоноид – это алгебраическая структура, состоящая из множества ММ с бинарной операцией ⋅ (умножения), которая:\n1. ассоциативный: (a⋅b)⋅c=a⋅(b⋅c) для всех a, b, c ∈ M;\n2. имеет единичный элемент e ∈ M такой, что для всех a ∈ M имеем e⋅a=a⋅e =a.\n\nФакторизация по отношению к языку. Чтобы построить синтаксический моноид для языка, мы сначала определяем отношение факторизации по отношению к языку L⊆Σ∗ (где Σ∗ — множество всех строк алфавита Σ).\n\nДве строки u и v считаются эквивалентными относительно языка L, если для всех строк x,y ∈ Σ∗ условие xuy ∈ L эквивалентно условию xvy ∈ L. Это эквивалентное отношение называется синтаксической эквивалентностью и обозначается u ∼ _Л в.\n\nСвязь с конечными автоматами:\nСинтаксический моноид можно использовать для описания обычных языков. Для любого регулярного языка его синтаксический моноид конечен, и язык можно распознать с помощью конечного автомата, построенного на основе этого моноида. Это означает, что синтаксический моноид — мощный инструмент для анализа структуры обычных языков и их поведения.\n\nТеорема Микана: язык регулярен тогда и только тогда, когда его синтаксический моноид конечен.\n\nПриложение:\n1. Классификация регулярных языков. Синтаксический моноид позволяет описать регулярные языки с точки зрения алгебраической структуры. Это особенно полезно для анализа и классификации языков.\n2. Определить сложность языков: Сложность синтаксического моноида (например, количество его элементов) может дать представление о сложности описания языка.\n3. Минимизация конечных автоматов. Используя синтаксические моноиды, можно построить минимальные конечные автоматы, которые эффективно распознают регулярные языки."
    },
    {
        "question": "17) Построение синтаксического моноида",
        "answer": "____\nСинтаксический моноид можно построить следующим образом:\n1. Множество классов эквивалентности: Рассмотрим множество всех классов эквивалентности строк по отношению к синтаксической эквивалентности. Каждый класс эквивалентности строк соответствует одному элементу синтаксического моноида.\n2. Операция на классах эквивалентности: Пусть [u][u] и [v][v] — классы эквивалентности строк uu и vv соответственно. Тогда операция в синтаксическом моноиде определяется как [u]⋅[v]=[uv], где uv — конкатенация строк u и v.\n3. Единичный элемент: Единичным элементом синтаксического моноида является класс эквивалентности пустой строки ϵ, который обычно обозначается как [ϵ].\n\nТаким образом, синтаксический моноид состоит из всех классов эквивалентности строк по отношению к синтаксической эквивалентности с операцией конкатенации строк."
    },
    {
        "question": "17) Построение синтаксического моноида",
        "answer": "____\nСинтаксический моноид может быть построен следующим образом:\n1. Набор классов эквивалентности: Рассмотрим набор всех классов эквивалентности строк относительно синтаксической эквивалентности. Каждый класс эквивалентности строк соответствует одному элементу синтаксического моноида.\n2. Операция над классами эквивалентности: Пусть [u][u] и [v][v] будут классами эквивалентности строк uu и vv соответственно. Тогда операция в синтаксическом моноиде определяется как [u]⋅[v]=[uv], где uv — это конкатенация строк u и v.\n3. Элемент идентичности: Элемент идентичности синтаксического моноида — это класс эквивалентности пустой строки ϵ, который обычно обозначается как [ϵ].\n\nТаким образом, синтаксический моноид состоит из всех классов эквивалентности строк относительно синтаксической эквивалентности с операцией конкатенации строк."
    },
    {
        "question": "17) Построение синтаксического моноида",
        "answer": "____\nСинтаксический моноид можно построить следующим образом:\n1. Набор классов эквивалентности. Рассмотрим набор всех классов строковой эквивалентности относительно синтаксической эквивалентности. Каждый класс строковой эквивалентности соответствует элементу синтаксического моноида.\n2. Операция над классами эквивалентности. Пусть [u][u] и [v][v] — классы эквивалентности цепей uu и vv соответственно. Тогда операция в синтаксическом моноиде определяется как [u]⋅[v]=[uv], где uv — объединение строк u и v.\n3. Элемент идентичности. Элементом идентичности синтаксического моноида является класс эквивалентности пустой строки ϵ, который обычно обозначается [ϵ].\n\nТаким образом, синтаксический моноид состоит из всех классов эквивалентности строк относительно синтаксической эквивалентности с операцией конкатенации строк."
    },
    {
        "question": "17) Построение синтаксического моноида",
        "answer": "____\nСинтаксический моноид можно построить следующим образом:\n1. Набор классов эквивалентности. Рассмотрим набор всех классов строковой эквивалентности относительно синтаксической эквивалентности. Каждый класс строковой эквивалентности соответствует элементу синтаксического моноида.\n2. Операция над классами эквивалентности. Пусть [u][u] и [v][v] — классы эквивалентности строк uu и vv соответственно. Тогда операция в синтаксическом моноиде определяется как [u]⋅[v]=[uv], где uv — объединение строк u и v.\n3. Элемент идентичности. Элементом идентичности синтаксического моноида является класс эквивалентности пустой строки ϵ, который обычно обозначается [ϵ].\n\nТаким образом, синтаксический моноид состоит из всех классов эквивалентности строк относительно синтаксической эквивалентности с операцией конкатенации строк."
    },
    {
        "question": "Грамматика в нормальной форме Хомского это",
        "answer": "____\nГрамматикой в нормальной форме Хомского (англ. Chomsky normal form) называется контекстно-свободная грамматика, в которой могут содержаться правила только следующего вида:\nA→BC,\nA→a,\nS→ε,\nгде:\na — терминал, \nA,B,C — нетерминалы, \nS — стартовая вершина,\nε — пустая строка, стартовая вершина не содержится в правых частях правил."
    },
    {
        "question": "Грамматика в нормальной форме Хомского:",
        "answer": "____\nГрамматика в нормальной форме Хомского — это контекстно-свободная грамматика, которая может содержать правила только следующего вида:\nA→BC,\nA→a,\nS→ε,\nгде:\na — терминал,\nA,B,C — нетерминалы,\nS — начальный узел,\nε — пустая строка, начальный узел не содержится в правых частях правил."
    },
    {
        "question": "Грамматика нормальной формы Хомского:",
        "answer": "____\nГрамматика нормальной формы Хомского — это контекстно-свободная грамматика, которая может содержать только правила следующей формы:\nА → БК,\nА → один,\nS → ε,\nИли:\nа - терминал,\nA, B, C — нетерминалы,\nS - стартовый узел,\nε — пустая строка, начальный узел не содержится в правых частях правил."
    },
    {
        "question": "Грамматика нормальной формы Хомского такова:",
        "answer": "____\nГрамматика нормальной формы Хомского — это контекстно-свободная грамматика, которая может содержать только правила следующей формы:\nА → БК,\nА → один,\nS → ε,\nИли:\nа - терминал, \nA, B, C — нетерминалы, \nS - начальная вершина,\nε — пустая строка, начальная вершина не содержится в правых частях правил."
    },
    {
        "question": "Докажи теорему: Любую контекстно-свободную грамматику можно привести к нормальной форме Хомского.",
        "answer": "____\nРассмотрим контекстно-свободную грамматику Γ. Для приведения ее к нормальной форме Хомского необходимо выполнить пять шагов. На каждом шаге мы строим новую Γi, которая допускает тот же язык, что и Γ.\n\nУберём длинные правила.\nВоспользуемся алгоритмом удаления длинных правил из грамматики. Получим грамматику Γ1, эквивалентную исходной, содержащую правила длины 0,1 и 2.\nУдаление ε - правил.\nВоспользуемся алгоритмом удаления ε - правил из грамматики. Получим грамматику Γ2, эквивалентную исходной, но в которой нет ε - правил.\nУдаление цепных правил.\nВоспользуемся алгоритмом удаления цепных правил из грамматики. Алгоритм работает таким образом, что новые ε - правила не образуются. Получим грамматику Γ3, эквивалентную Γ.\nУдалим бесполезные символы.\nВоспользуемся алгоритмом удаления бесполезных символов из грамматики. Так как Γ3\nэквивалентна Γ, то бесполезные символы не могли перестать быть бесполезными. Более того, мы только удаляем правила, новые ε-правила и цепные правила не могли появиться.\nУберём ситуации, когда в правиле встречаются несколько терминалов.\nДля всех правил вида A→u1u2\n(где ui — терминал или нетерминал) заменим все терминалы ui на новые нетерминалы Ui и добавим правила Ui→ui. \nТеперь правила содержат либо одиночный терминал, либо строку из двух нетерминалов.\nТаким образом, мы получили грамматику в нормальной форме Хомского, которая допускает тот же язык, что и Γ.\n\nСтоит заметить, что порядок выполнения операций важен. Первое правило должно быть выполнено перед вторым, иначе время нормализации ухудшится до O(2|Γ|). Третье правило идет после второго, потому что после удаления ε-правил, могут образоваться новые цепные правила. Также четвертое правило должно быть выполнено позже третьего и второго, так как они могут порождать бесполезные символы.\n\nПри таком порядке действий размеры грамматики возрастают полиномиально.\n\nПосле удалении длинных правил из каждого правила длины k⩾3 могло появиться k−1 новых правил, причем их длина не превышает двух. На этом шаге размер грамматики возрастает не более, чем вдвое.\n\nПри удалении ε-правил из грамматики, содержащей правила длины 0,1 и 2, размеры грамматики могли вырасти не больше, чем в 3 раза.\n\nВсего цепных правил в грамматике не больше, чем n2, где n — число нетерминалов. При удалении цепных правил мы берем каждую из цепных пар и производим добавление нецепных правил, выводимых из второго нетерминала в паре. Если максимальная суммарная длина всех правил, выводимых из какого-либо нетерминала, равна k, то размер грамматики возрастет не больше, чем на k⋅n2.\n\nНаконец, на последнем шаге может произойти добавление не более, чем |Σ|(Σ— алфавит грамматики) новых правил, причем все они будут длины 1."
    },
    {
        "question": "Докажите теорему: Любую контекстно-свободную грамматику можно привести к нормальной форме Хомского.",
        "answer": "____\nРассмотрим контекстно-свободную грамматику Γ. Чтобы привести ее к нормальной форме Хомского, нам нужно выполнить пять шагов. На каждом шаге мы строим новую Γi, которая допускает тот же язык, что и Γ.\n\nУдалим длинные правила.\nИспользуем алгоритм удаления длинных правил из грамматики. Получаем грамматику Γ1, эквивалентную исходной, содержащую правила длины 0,1 и 2.\nУдалим ε - правила.\nИспользуем алгоритм удаления ε - правил из грамматики. Получаем грамматику Γ2, эквивалентную исходной, но не содержащую ε - правил.\nУдалим цепочные правила.\nИспользуем алгоритм удаления цепочных правил из грамматики. Алгоритм работает таким образом, что новые ε - правила не образуются. Получаем грамматику Γ3, эквивалентную Γ.\nУдалим бесполезные символы.\nИспользуем алгоритм удаления бесполезных символов из грамматики. Так как Γ3\nэквивалентно Γ, бесполезные символы не могли перестать быть бесполезными. Более того, мы только удаляем правила, новые ε-правила и цепочечные правила не могли появиться.\nУдалим ситуации, когда правило содержит несколько терминалов.\nДля всех правил вида A→u1u2\n(где ui — терминал или нетерминал) заменим все терминалы ui на новые нетерминалы Ui и добавим правила Ui→ui.\nТеперь правила содержат либо один терминал, либо строку из двух нетерминалов.\nТаким образом, мы получили грамматику в нормальной форме Хомского, которая допускает тот же язык, что и Γ.\n\nСтоит отметить, что порядок операций важен. Первое правило должно быть выполнено перед вторым, иначе время нормализации сократится до O(2|Γ|). Третье правило следует за вторым, так как после удаления ε-правил могут образоваться новые цепочечные правила. Также четвертое правило должно выполняться после третьего и второго, так как они могут генерировать бесполезные символы.\n\nПри таком порядке действий размер грамматики увеличивается полиномиально.\n\nПосле удаления длинных правил из каждого правила длины k⩾3 может появиться k−1 новых правил, а их длина не превышает двух. На этом шаге размер грамматики увеличится не более чем в два раза.\n\nПри удалении ε-правил из грамматики, содержащей правила длины 0,1 и 2, размер грамматики может вырасти не более чем в 3 раза.\n\nВсего в грамматике не более n2 цепочных правил, где n — количество нетерминалов. При удалении цепочных правил мы берем каждую из пар цепочек и добавляем нецепочные правила, полученные из второго нетерминала в паре. Если максимальная суммарная длина всех правил, полученных из некоторого нетерминала, равна k, то размер грамматики увеличится не более чем на k⋅n2.\n\nНаконец, на последнем шаге может быть добавлено не более |Σ|(Σ — алфавит грамматики) новых правил, и все они будут иметь длину 1."
    },
    {
        "question": "Докажите теорему: любую контекстно-свободную грамматику можно привести к нормальной форме Хомского.",
        "answer": "____\nРассмотрим контекстно-свободную грамматику Γ. Чтобы привести его к нормальной хомской форме, нам необходимо выполнить пять шагов. На каждом шаге мы строим новый Γi, допускающий тот же язык, что и Γ.\n\nДавайте удалим длинные правила.\nМы используем алгоритм для удаления длинных правил из грамматики. Мы получаем грамматику Γ1, эквивалентную оригиналу, содержащую правила длины 0, 1 и 2.\nУдалим ε-правила.\nМы используем алгоритм для удаления ε правил из грамматики. Мы получаем грамматику Γ2, эквивалентную исходной, но не содержащую ε - правил.\nДавайте удалим правила цепочки.\nМы используем алгоритм для удаления строковых правил из грамматики. Алгоритм работает таким образом, что никаких новых ε-правил не образуется. Мы получаем грамматику Γ3, эквивалентную Γ.\nДавайте удалим ненужные символы.\nМы используем алгоритм удаления ненужных символов из грамматики. Поскольку Γ3\nэквивалентные Γ, бесполезные символы не могли перестать быть бесполезными. Кроме того, мы удаляем только правила; новые ε-правила и правила цепочки появиться не могут.\nУдалим ситуации, когда правило содержит несколько терминалов.\nДля всех правил вида A→u1u2\n(где ui — терминал или нетерминал) замените все терминалы ui новыми нетерминалами Ui и добавьте правила Ui→ui.\nПравила теперь содержат либо терминал, либо цепочку из двух нетерминалов.\nТаким образом, мы имеем грамматику с нормальной формой Хомского, допускающую тот же язык, что и Γ.\n\nСледует отметить, что порядок действий важен. Первое правило должно выполняться раньше второго, иначе время нормализации сократится до O(2|Γ|). Третье правило следует за вторым, поскольку после удаления правил ε могут быть сформированы новые правила цепочки. Кроме того, четвертое правило следует выполнять после третьего и второго, так как они могут генерировать ненужные символы.\n\nПри этой процедуре размер грамматики увеличивается полиномиально.\n\nПосле удаления длинных правил из каждого правила длины k⩾3 может появиться k−1 новых правил, длина которых не превышает двух. На этом этапе размер грамматики увеличится не более чем в два раза.\n\nПри удалении ε правил из грамматики, содержащей правила длины 0, 1 и 2, размер грамматики не может увеличиться более чем в 3 раза.\n\nВсего в грамматике не более n2 цепных правил, где n — количество нетерминалов. При удалении связанных правил мы берем каждую из цепных пар и добавляем несвязанные правила, полученные из второго нетерминала пары. Если максимальная суммарная длина всех правил, полученных из нетерминала, равна k, то размер грамматики не увеличится более чем на k⋅n2.\n\nНаконец, на последнем шаге можно добавить не более |Σ|(Σ — грамматический алфавит) новых правил, и все они будут иметь длину 1."
    },
    {
        "question": "Докажите теорему: любую контекстно-свободную грамматику можно привести к нормальной форме Хомского.",
        "answer": "____\nРассмотрим контекстно-свободную грамматику Γ. Чтобы привести его к нормальной форме Хомского, необходимо выполнить пять шагов. На каждом шаге мы строим новый Γi, допускающий тот же язык, что и Γ.\n\nДавайте избавимся от длительных периодов.\nДавайте воспользуемся алгоритмом для удаления длинных правил из грамматики. Мы получаем грамматику Γ1, эквивалентную оригиналу, содержащую правила длины 0, 1 и 2.\nУдаление ε правил.\nДавайте воспользуемся алгоритмом для удаления ε правил из грамматики. Мы получим грамматику Г2, эквивалентную исходной, но в которой нет правил е-.\nУдалены правила канала.\nДавайте воспользуемся алгоритмом для удаления строковых правил из грамматики. Алгоритм работает таким образом, что никаких новых ε-правил не образуется. Мы получаем грамматику Γ3, эквивалентную Γ.\nДавайте удалим ненужные символы.\nДавайте воспользуемся алгоритмом для удаления ненужных символов из грамматики. Поскольку Γ3\nэквивалентно Γ, то бесполезные символы не могут перестать быть бесполезными. Кроме того, мы удаляем только правила; новые ε-правила и правила цепочки появиться не могут.\nДавайте удалим ситуации, когда правило содержит несколько конечных точек.\nДля всех правил вида A→u1u2\n(где ui — терминал или нетерминал) замените все терминалы ui новыми нетерминалами Ui и добавьте правила Ui→ui. \nПравила теперь содержат либо один терминал, либо цепочку из двух нетерминалов.\nТаким образом, мы имеем грамматику с нормальной формой Хомского, допускающую тот же язык, что и Γ.\n\nСледует отметить, что важен порядок выполнения операций. Первое правило должно быть выполнено раньше второго, иначе время нормализации ухудшится до O(2|Γ|). Третье правило следует за вторым, потому что после удаления правил ε могут быть сформированы новые правила цепочки. Кроме того, четвертое правило следует выполнять позже третьего и второго, так как они могут генерировать ненужные символы.\n\nПри этой процедуре размер грамматики увеличивается полиномиально.\n\nПосле удаления длинных правил из каждого правила длины k⩾3 может появиться k−1 новых правил, длина которых не превышает двух. На этом этапе размер грамматики увеличивается не более чем в два раза.\n\nПри удалении ε правил из грамматики, содержащей правила длины 0, 1 и 2, размер грамматики не мог увеличиться более чем в 3 раза.\n\nЦепных правил в грамматике не больше, чем n2, где n — количество нетерминалов. При удалении связанных правил мы берем каждую из связанных пар и добавляем несвязанные правила, полученные из второго нетерминала пары. Если максимальная суммарная длина всех правил, полученных из любого нетерминала, равна k, то размер грамматики не увеличится более чем на k⋅n2.\n\nНаконец, на последнем шаге можно добавить не более |Σ|(Σ — грамматический алфавит) новых правил, все из которых будут иметь длину 1."
    },
    {
        "question": "Грамматика в ослабленной нормальной форме Грейбах",
        "answer": "____\nГрамматикой в ослабленной нормальной форме Грейбах (англ. Greibach weak normal form) называется контекстно-свободная грамматика, в которой могут содержаться только правила одного из следующих типов:\nA→aγ\nS→ε\nгде a — терминал, A — нетерминал (возможно, стартовый), S — стартовый нетерминал (причём он не должен встречаться в правых частях правил), ε — пустая строка, γ — строка из произвольного числа терминалов и нетерминал"
    },
    {
        "question": "Грамматика в ослабленной нормальной форме Грейбах",
        "answer": "____\nГрамматика в слабой нормальной форме Грейбаха — это контекстно-свободная грамматика, которая может содержать только правила одного из следующих типов:\nA→aγ\nS→ε\nгде a — терминал, A — нетерминал (возможно, начальный), S — начальный нетерминал (и он не должен появляться в правых частях правил), ε — пустая строка, γ — строка из произвольного числа терминалов, а нетерминал"
    },
    {
        "question": "Ослабленная грамматика нормальной формы Грейбаха",
        "answer": "____\nГрамматика слабой нормальной формы Грейбаха — это контекстно-свободная грамматика, которая может содержать правила только одного из следующих типов:\nА→аγ\nС → ε\nгде a — терминал, A — нетерминал (возможно, первый), S — начальный нетерминал (и он не должен появляться справа от правил), ε — пустая строка, γ — строка произвольное количество терминалов, а нетерминал"
    },
    {
        "question": "Ослабленная грамматика нормальной формы Грейбаха",
        "answer": "____\nГрамматика слабой нормальной формы Грейбаха — это контекстно-свободная грамматика, которая может содержать правила только одного из следующих типов:\nА→аγ\nС → ε\nгде a — терминал, A — нетерминал (возможно, ведущий), S — нетерминальный ведущий (и он не должен появляться в правой части правил), ε — пустая строка, γ — строка d 'произвольное количество терминалов и один нетерминал"
    },
    {
        "question": "Докажи лемму об удалении терминалов:",
        "answer": "____\nКаждому терминалу a поставим в соотвествие новый символ a′, которого нет в N∪Σ, такой что a′≠b′ для разных терминалов a и b.\n\nПусть N′=N∪{a′∣a∈Σ}\n\nПусть α=x1x2…xn — часть правила, тогда α′=y1y2…yn, где yi={xix′i; xi∈N; xi∈Σ для 1⩽i⩽n.\n\nПостроим грамматику G′=⟨Σ,N′,S,P′⟩, где P′={α′→β′∣α→β∈P}∪{a′→a∣a∈Σ}\n\nПокажем, что L(Γ′)=L(Γ)\n\nПусть w∈L(Γ)\n Тогда в Γ существует вывод S=w0⇒w1⇒…⇒wn⇒w\n\nСогласно конструкции P′, в Γ′ существует вывод S=w′0⇒w′1⇒w′2⇒…⇒w′n=v0⇒v1⇒v2⇒…⇒vm=w\n\nДля 0⩽i⩽n−1 в переходах w′i⇒w′i+1 используем правило α′→β′, так как правило α→β было использовано при выводе wi⇒wi+1\n\nДля 0⩽j⩽m−1 в переходах vj⇒vj+1 используем правила вида a′→a\n\nЗаменяем разрешенные в w′ символы на новые и получаем, что w∈L(Γ′)\nТогда L(Γ)⊆L(Γ′)\n\n\nПусть x∈L(Γ′). Тогда в Γ′ существует вывод S⇒∗x\nМы можем поменять порядок применения правил в этом выводе: сначала применяем только правила вида α′→β′, а потом только правила вида a′→a.\n\nИз построения: после применения правила вида a′→a полученное a не может быть использовано при применении правил из P′\n\nИзменение порядка вывода не меняет язык, то есть в Γ′ существует вывод: S=x′0⇒x′1⇒…⇒x′r⇒x′⇒y1⇒y2⇒…⇒ys=x, где для 0⩽i⩽r−1 x′i+1∈(N′)∗ и в переходе x′i→x′i+1 было использовано правило вывода α′→β′ и для 1⩽j⩽s было использовано правило a′→a, чтобы получить yj→yj+1\n\nПолучаем вывод в Γ: S=x0⇒x1⇒…⇒xn=x\n\nТогда L(Γ′)⊆L(Γ)\n\nТаким образом, L(Γ′)=L(Γ)\n\nОчевидно, что если грамматика была неукорочивающейся, то она такой и останется."
    },
    {
        "question": "Докажите лемму о терминальном удалении:",
        "answer": "____\nНазначьте каждому терминалу a новый символ a′, который не входит в N∪Σ, такой, что a′≠b′ для различных терминалов a и b.\n\nПусть N′=N∪{a′∣a∈Σ}\n\nПусть α=x1x2…xn будет частью правила, тогда α′=y1y2…yn, где yi={xix′i; xi∈N; xi∈Σ для 1⩽i⩽n.\n\nПостроим грамматику G′=⟨Σ,N′,S,P′⟩, где P′={α′→β′∣α→β∈P}∪{a′→a∣a∈Σ}\n\nПокажем, что L(Γ′)=L(Γ)\n\nПусть w∈L(Γ)\nТогда в Γ существует вывод S=w0⇒w1⇒…⇒wn⇒w\n\nПо построению P′, в Γ′ существует вывод S=w′0⇒w′1⇒w′2⇒…⇒w′n=v0⇒v1⇒v2⇒…⇒vm=w\n\nДля 0⩽i⩽n−1 в переходах w′i⇒w′i+1 мы используем правило α′→β′, так как правило α→β использовалось при выводе wi⇒wi+1\n\nДля 0⩽j⩽m−1 в переходах vj⇒vj+1 мы используем правила вида a′→a\n\nЗаменяем символы, разрешенные в w′, на новые и получаем, что w∈L(Γ′)\nТогда L(Γ)⊆L(Γ′)\n\nПусть x∈L(Γ′). Тогда в Γ′ есть вывод S⇒∗x\nМы можем изменить порядок применения правил в этом выводе: сначала мы применяем только правила вида α′→β′, а затем только правила вида a′→a.\n\nИз конструкции: после применения правила вида a′→a полученное a не может быть использовано при применении правил из P′\n\nИзменение порядка вывода не меняет язык, то есть в Γ′ есть вывод: S=x′0⇒x′1⇒…⇒x′r⇒x′⇒y1⇒y2⇒…⇒ys=x, где для 0⩽i⩽r−1 x′i+1∈(N′)∗ и при переходе x′i→x′i+1 использовалось правило вывода α′→β′, а для 1⩽j⩽s использовалось правило a′→a для получения yj→yj+1\n\nМы получаем вывод в Γ: S=x0⇒x1⇒…⇒xn=x\n\nТогда L(Γ′)⊆L(Γ)\n\nТаким образом, L(Γ′)=L(Γ)\n\nОчевидно, что если грамматика была несокращенной, то она таковой и останется."
    },
    {
        "question": "Докажите лемму об удалении терминала:",
        "answer": "____\nНазначьте каждому терминалу a новый символ a', которого нет в N∪Σ, такой, что a'≠b' для разных терминалов a и b.\n\nПусть N′=N∪{a′∣aεΣ}\n\nПусть α=x1x2…xn — часть правила, тогда α′=y1y2…yn, где yi={xix′i; ксиеN; xiεΣ для 1⩽i⩽n.\n\nПостроим грамматику G′=⟨Σ,N′,S,P′⟩, где P′={α′→β′∣α→βاP}∪{a′→a∣aاΣ}\n\nПокажем, что L(Γ′)=L(Γ)\n\nПусть wεL(Γ)\nТогда в Γ имеется вывод S=w0⇒w1⇒…⇒wn⇒w\n\nПо построению P′ в Γ′ имеется вывод S=w′0⇒w′1⇒w′2⇒…⇒w′n=v0⇒v1⇒v2⇒…⇒vm=w\n\nДля 0⩽i⩽n−1 в переходах w′i⇒w′i+1 используем правило α′→β′, так как правило α→β использовалось при выводе wi⇒wi+1\n\nПри 0⩽j⩽m−1 при переходах vj⇒vj+1 используем правила вида a′→a\n\nЗаменим разрешенные символы в w′ новыми и получим, что wεL(Γ′)\nТогда L(Γ)⊆L(Γ′)\n\nПусть xεL(Γ′). Тогда в Γ′ существует заключение S⇒∗x\nМожно изменить порядок применения правил в этом выводе: сначала применяем только правила вида α′→β′, затем только правила вида a′→a.\n\nИз конструкции: после применения правила вида a′→a полученное a нельзя использовать при применении правил P′\n\nИзменение порядка вывода не меняет язык, то есть в Γ′ имеется вывод: S=x′0⇒x′1⇒…⇒x′r⇒x′⇒y1⇒ y2⇒…⇒ys=x , где для 0⩽i⩽ r−1 x′i+1ε(N′)∗ и при переходе x′i→x′i+1 использовалось правило вывода α′→β ′, а для 1⩽j ⩽s правило a′→a использовалось для получения yj→yj+1\n\nПолучаем заключение в Γ: S=x0⇒x1⇒…⇒xn=x\n\nТогда L(Γ′)⊆L(Γ)\n\nТаким образом, L(Γ′)=L(Γ)\n\nОчевидно, если бы грамматика была целостной, она бы таковой и осталась."
    },
    {
        "question": "Докажите лемму об удалении клемм:",
        "answer": "____\nКаждому терминалу a мы присваиваем новый символ a', которого нет в N∪Σ, такой, что a'≠b' для разных терминалов a и b.\n\nПусть N′=N∪{a′∣aεΣ}\n\nПусть α=x1x2…xn — часть правила, тогда α′=y1y2…yn, где yi={xix′i; ксиеN; xiεΣ для 1⩽i⩽n.\n\nПостроим грамматику G′=⟨Σ,N′,S,P′⟩, где P′={α′→β′∣α→βاP}∪{a′→a∣aاΣ}\n\nПокажем, что L(Γ′)=L(Γ)\n\nПусть wεL(Γ)\n Тогда в Γ имеется вывод S=w0⇒w1⇒…⇒wn⇒w\n\nСогласно построению P′, в Γ′ имеется вывод S=w′0⇒w′1⇒w′2⇒…⇒w′n=v0⇒v1⇒v2⇒…⇒vm=w\n\nДля 0⩽i⩽n−1 в переходах w′i⇒w′i+1 используем правило α′→β′, так как правило α→β использовалось при выводе wi⇒wi+1\n\nПри 0⩽j⩽m−1 при переходах vj⇒vj+1 используем правила вида a′→a\n\nЗаменим разрешенные символы в w′ новыми и получим, что wεL(Γ′)\nТогда L(Γ)⊆L(Γ′)\n\n\nПусть xεL(Γ′). Тогда в Γ′ существует заключение S⇒∗x\nМожно изменить порядок применения правил в этом выводе: сначала применяем только правила вида α′→β′, затем только правила вида a′→a.\n\nИз конструкции: после применения правила вида a′→a полученное a нельзя использовать при применении правил P′\n\nИзменение порядка вывода не меняет язык, то есть в Γ′ имеется вывод: S=x′0⇒x′1⇒…⇒x′r⇒x′⇒y1⇒ y2⇒…⇒ys=x , где для 0⩽i⩽ r−1 x′i+1ε(N′)∗ и при переходе x′i→x′i+1 использовалось правило вывода α′→β ′, а для 1⩽j⩽ s использовалось правило a′→a, чтобы получить yj→yj+1\n\nПолучаем заключение в Γ: S=x0⇒x1⇒…⇒xn=x\n\nТогда L(Γ′)⊆L(Γ)\n\nТаким образом, L(Γ′)=L(Γ)\n\nОчевидно, что если грамматика не была сокращена, то она таковой и останется."
    },
    {
        "question": "Лемма (об удалении коротких правил) доказательство",
        "answer": "____\nСначала по Γ построим грамматику Γ′′=⟨Σ,N′′,S,P′′⟩, как в доказательстве леммы 1. По Γ′′ построим грамматику Γ′, в которой:\n\nN′=N′′∪{D}, где D — новый символ, P′ получаем из P′′ заменой всех правил вида α→β∈P′′, где |α|>|β|, на правила вида α→βD|α|−|β|, и добавлением правила D→ε.\nТеперь все правила в P′ имеет требуемую форму.\n\nПокажем, что L(Γ′)=L(Γ)\n\nЗаметим, что замена правила α→β на α→βD|α|−|β| не меняет язык грамматики, потому что D переходит только в ε, а других правил для D нет.\n\nТогда получаем, что L(Γ)⊆L(Γ′), аналогично обратные изменения не меняют язык, то есть L(Γ′)⊆L(Γ)."
    },
    {
        "question": "Доказательство леммы (об удалении коротких правил)",
        "answer": "____\nСначала, для данной Γ мы строим грамматику Γ′′=⟨Σ,N′′,S,P′′⟩, как в доказательстве леммы 1. Для данной Γ′′ мы строим грамматику Γ′, в которой:\n\nN′=N′′∪{D}, где D — новый символ, P′ получается из P′′ заменой всех правил вида α→β∈P′′, где |α|>|β|, на правила вида α→βD|α|−|β|, и добавлением правила D→ε.\nТеперь все правила в P′ имеют требуемый вид.\n\nПокажем, что L(Γ′)=L(Γ)\n\nОбратите внимание, что замена правила α→β на α→βD|α|−|β| не меняет язык грамматики, поскольку D отображается только на ε, и других правил для D нет.\n\nТогда получаем, что L(Γ)⊆L(Γ′), аналогично, обратные замены не меняют язык, то есть L(Γ′)⊆L(Γ)."
    },
    {
        "question": "Доказательство леммы (об удалении коротких правил)",
        "answer": "____\nСначала для данного Γ построим грамматику Γ''=⟨Σ,N'',S,P''⟩, как и в доказательстве леммы 1. Для данного Γ'' построим грамматику Γ', в которой :\n\nN′=N′′∪{D}, где D – новый символ, P′ получается из P′′ заменой всех правил вида α→βاP′′, где |α|>β| , с правилами вида α→ βD|α|−|β| и добавлением правила D→ε.\nТеперь все правила P' имеют требуемый вид.\n\nПокажем, что L(Γ′)=L(Γ)\n\nЗаметим, что замена правила α→β на правило α→βD|α|−|β| не меняет язык грамматики, поскольку D соответствует только ε и для D нет других правил.\n\nТогда получаем, что L(Γ)⊆L(Γ′), аналогично обратные замены не меняют язык, т. е. L(Γ′)⊆L(Γ)."
    },
    {
        "question": "Доказательство леммы (об удалении коротких правил)",
        "answer": "____\nСначала по Γ построим грамматику Γ''=⟨Σ,N'',S,P''⟩, как и в доказательстве леммы 1. По Γ'' построим грамматику Γ', в которой:\n\nN′=N′′∪{D}, где D – новый символ, P′ получается из P′′ заменой всех правил вида α→βاP′′, где |α|>β| , с правилами вида α→ βD|α|−|β| и добавлением правила D→ε.\nТеперь все правила P' имеют требуемый вид.\n\nПокажем, что L(Γ′)=L(Γ)\n\nЗаметим, что замена правила α→β на правило α→βD|α|−|β| не меняет язык грамматики, потому что D переходит только в ε, и для D нет других правил.\n\nТогда получаем, что L(Γ)⊆L(Γ′), а также обратные замены не меняют язык, т. е. L(Γ′)⊆L(Γ)."
    },
    {
        "question": "Порядок грамматики",
        "answer": "____\nДля любой грамматики Γ=⟨Σ,N,S,P⟩ порядка n⩾3, такой что: любое правило из P′ имеет вид α→β, где α∈(N′)+ и β∈(N′)+ и |α|⩽|β| или A→a или A→ε, где A∈N′ и a∈T может быть построена грамматика Γ′=⟨Σ,N′,S,P′⟩ порядка n−1 такая, что L(Γ′)=L(Γ)"
    },
    {
        "question": "Грамматический порядок",
        "answer": "____\nДля любой грамматики Γ=⟨Σ,N,S,P⟩ порядка n⩾3 такой, что: любое правило из P′ имеет вид α→β, где α∈(N′)+ и β∈(N′)+ и |α|⩽|β| или A→a или A→ε, где A∈N′ и a∈T, грамматика Γ′=⟨Σ,N′,S,P′⟩ порядка n−1 может быть построена так, что L(Γ′)=L(Γ)"
    },
    {
        "question": "Грамматический порядок",
        "answer": "____\nДля любой грамматики Γ=⟨Σ,N,S,P⟩ порядка n⩾3 такой, что: каждое правило P′ имеет вид α→β, где αε(N′)+ и βε(N′) + и |α|⩽|β| или A→a или A→ε, где AεN′ и aεT, можно построить грамматику Γ′=⟨Σ,N′,S,P′⟩ порядка n−1 такую, что L(Γ′ ) = L(Г)"
    },
    {
        "question": "Грамматический порядок",
        "answer": "____\nДля любой грамматики Γ=⟨Σ,N,S,P⟩ порядка n⩾3, такой, что: каждое правило P′ имеет вид α→β, где αε(N′)+ и βε(N′ ) + и |α|⩽|β| или A→a или A→ε, где AεN′ и aεT, можно построить грамматику Γ′=⟨Σ,N′,S,P′⟩ порядка n−1 такую, что L(Γ′) = Л(Г)"
    },
    {
        "question": "Мгновенное описание",
        "answer": "____\nМгновенное описание (англ. instantaneous descriptions) — это набор ⟨q,α,γ⟩, где q — текущее состояние, α — остаток строки, γ — содержимое стека."
    },
    {
        "question": "Мгновенное описание",
        "answer": "____\nМгновенное описание — это набор ⟨q,α,γ⟩, где q — текущее состояние, α — остаток строки, а γ — содержимое стека."
    },
    {
        "question": "Мгновенное описание",
        "answer": "____\nОписание снимка — это набор ⟨q,α,γ⟩, где q — текущее состояние, α — остаток строки, а γ — содержимое стека."
    },
    {
        "question": "Мгновенное описание",
        "answer": "____\nМгновенное описание — это набор ⟨q,α,γ⟩, где q — текущее состояние, α — оставшаяся часть строки, γ — содержимое стека."
    },
    {
        "question": "Детерминированный автомат с магазинной памятью",
        "answer": "____\nДетерминированным автоматом с магазинной памятью (англ. deterministic pushdown automaton) называется автомат с магазинной памятью, для которого выполнены следующие условия:\n8q∈Q,a∈Σ∪{ε},X∈Γ⇒δ(q,a,X) имеет не более одного элемента — δ:Q×Σ∪{ε}×Γ→Q×Γ∗\nЕсли δ(q,a,X) непусто для некоторого a∈Σ, то δ(q,ε,X) должно быть пустым."
    },
    {
        "question": "Детерминированный магазинный автомат",
        "answer": "____\nДетерминированный магазинный автомат — это магазинный автомат, для которого выполняются следующие условия:\n8q∈Q,a∈Σ∪{ε},X∈Γ⇒δ(q,a,X) имеет не более одного элемента — δ:Q×Σ∪{ε}×Γ→Q×Γ∗\nЕсли δ(q,a,X) непусто для некоторого a∈Σ, то δ(q,ε,X) должно быть пустым."
    },
    {
        "question": "Детерминированный автоматический магазин",
        "answer": "____\nДетерминированный магазинный автомат – это магазинный автомат, для которого выполняются следующие условия:\n8qεQ,aεΣ∪{ε},XεΓ⇒δ(q,a,X) имеет не более одного элемента - δ:Q×Σ∪{ε}×Γ→Q×Γ∗\nЕсли δ(q,a,X) не пусто для некоторого aεΣ, то δ(q,ε,X) должно быть пустым."
    },
    {
        "question": "Детерминированный автомат с запоминающим устройством",
        "answer": "____\nДетерминированный автомат с магазинной памятью — это автомат с запоминающим устройством, для которого выполняются следующие условия:\n8qεQ,aεΣ∪{ε},XεΓ⇒δ(q,a,X) имеет не более одного элемента - δ:Q×Σ∪{ε}×Γ→Q×Γ∗\nЕсли δ(q,a,X) не пусто для некоторого aεΣ, то δ(q,ε,X) должно быть пустым."
    },
    {
        "question": "Детерминированный автомат с магазинной памятью, допуск по пустому стеку",
        "answer": "____\nОпределим детерминированный автомат с магазинной памятью, допускающий по пустому стеку (англ. PDA accepting by empty stack), как детерминированный автомат с магазинной памятью, у которого нет множества T допускающих состояний. Автомат заканчивает свою работу как только стек становится пустым.\nОпределим для него множество допускающих слов N={ω∣(q0,a0,Z0)⊢∗(p,ϵ,ϵ)}, где p — произвольное состояние."
    },
    {
        "question": "Детерминированный магазинный автомат, допуск пустого стека",
        "answer": "____\nМы определяем детерминированный магазинный автомат, принимающий пустой стек (PDA, принимающий пустой стек) как детерминированный магазинный автомат, не имеющий множества T принимающих состояний. Автомат завершает свою работу, как только стек становится пустым.\nМы определяем для него множество принимающих слов N={ω∣(q0,a0,Z0)⊢∗(p,ϵ,ϵ)}, где p — произвольное состояние."
    },
    {
        "question": "Детерминированная автоматизация склада, устойчивость к разряженной батарее",
        "answer": "____\nМы определяем детерминированный автомат, принимающий стек (PDA, принимающий стек), как детерминированный автомат, принимающий стек, который не имеет множества T состояний акцептора. Машина прекращает свою работу, как только батарея разряжается.\nДля этого определим набор слов-приемников N={ω∣(q0,a0,Z0)⊢∗(p,ϵ,ϵ)}, где p — произвольное состояние."
    },
    {
        "question": "Детерминированный автомат с памятью, допуск на пустой стек",
        "answer": "____\nОпределим детерминированный автомат с памятью, принимающей пустой стек, как детерминированный автомат с памятью, не имеющей множества T состояний приемки. Машина завершает свою работу, как только аккумулятор разрядится.\nДля этого определим множество пропускных слов N={ω∣(q0,a0,Z0)⊢∗(p,ϵ,ϵ)}, где p — произвольное состояние."
    },
    {
        "question": "Правый контекст это",
        "answer": "____\nПравым контекстом (англ. right context) C_R_L(y) слова y в языке L называется множество {z∣yz∈L}"
    },
    {
        "question": "Правильный контекст:",
        "answer": "____\nПравильный контекст C_R_L(y) слова y в языке L — это множество {z∣yz∈L}"
    },
    {
        "question": "Правильный контекст:",
        "answer": "____\nПравильный контекст C_R_L(y) слова y в языке L — это набор {z∣yzاL}"
    },
    {
        "question": "Правильный контекст",
        "answer": "____\nПравильный контекст C_R_L(y) слова y в языке L — это набор {z∣yzاL}"
    },
    {
        "question": "Левый контекст это",
        "answer": "____\nЛевым контекстом (англ. left context) C_L_L(y) слова y в языке L называется множество {z∣zy∈L}"
    },
    {
        "question": "Левый контекст",
        "answer": "____\nЛевый контекст C_L_L(y) слова y в языке L — это множество {z∣zy∈L}"
    },
    {
        "question": "Контекст слева",
        "answer": "____\nЛевый контекст C_L_L(y) слова y в языке L — это множество {z∣zyاL}"
    },
    {
        "question": "Левый контекст",
        "answer": "____\nЛевый контекст C_L_L(y) слова y в языке L — это множество {z∣zyاL}"
    },
    {
        "question": "Двухсторонний контекст это",
        "answer": "____\nДвухсторонним контекстом (англ. two-sided context) C_L(y) слова y в языке L называется множество {⟨x,z⟩∣xyz∈L}"
    },
    {
        "question": "Двусторонний контекст",
        "answer": "____\nДвусторонний контекст C_L(y) слова y в языке L — это множество {⟨x,z⟩∣xyz∈L}"
    },
    {
        "question": "Двунаправленный контекст",
        "answer": "____\nДвунаправленный контекст C_L(y) слова y в языке L — это множество {⟨x,z⟩∣xyzاL}"
    },
    {
        "question": "Двунаправленный контекст",
        "answer": "____\nДвусторонний контекст C_L(y) слова y в языке L — это множество {⟨x,z⟩∣xyzاL}"
    },
    {
        "question": "4. Конструкция автомата Глушкова.",
        "answer": "____\nАлгоритм построения Glushkov(r)\n1. Строим линеаризованную версию r: r(Lin) = Linearize(r).\n2. Ищем First(r(Lin)), Last(r(Lin)) и Follow(r(Lin))(c) для всех\nc принадлежащих (Сумма(r(Lin))) .\n3. Все состояния автомата, кроме начального (назовём его S),\nсоответствуют буквам c принадлежит (Сумма(r(Lin))) .\n4. Из начального состояния строим переходы в те состояния,\nдля которых c принадлежит First(r(Lin)). Переходы имеют вид S -> c по с.\n5. Переходы из состояния c соответствуют элементам d\nмножества Follow(r(Lin))(c) и имеют вид c -> d по d.\n6. Конечные состояния — такие, что c принадлежит Last(r(Lin)), а также S,\nесли эпсилон принадлежит L(R).\n7. Теперь стираем разметку, построенную линеаризацией, на\nпереходах автомата. Конструкция завершена."
    },
    {
        "question": "4. Конструкция пулемета Глушкова.",
        "answer": "____\nАлгоритм построения Глушкова(r)\n1. Строим линеаризованную версию r: r(Lin) = Linearize(r).\n2. Находим First(r(Lin)), Last(r(Lin)) и Follow(r(Lin))(c) для всех\nc, принадлежащих (Sum(r(Lin))) .\n3. Все состояния автомата, кроме начального (назовем его S),\nсоответствуют буквам c принадлежит (Sum(r(Lin))) .\n4. Из начального состояния строим переходы в те состояния,\nдля которых c принадлежит First(r(Lin)). Переходы имеют вид S -> c по c.\n5. Переходы из состояния c соответствуют элементам d\nмножества Follow(r(Lin))(c) и имеют вид c -> d по d.\n6. Конечные состояния таковы, что c принадлежит Last(r(Lin)), а также S,\nесли epsilon принадлежит L(R).\n7. Теперь стираем маркировки, построенные линеаризацией на\nпереходах автомата. Построение завершено."
    },
    {
        "question": "4. Конструкция пулемета Глушкова.",
        "answer": "____\nАлгоритм построения Глушкова(р)\n1. Построить линеаризованную версию r: r(Lin) = Linearize(r).\n2. Найдите First(r(Lin)), Last(r(Lin)) и Follow(r(Lin))(c) для всех\nc принадлежит (Sum(r(Lin))) .\n3. Все состояния автомата, кроме начального (назовем его S),\nсоответствуют буквам, которым принадлежит c (Sum(r(Lin))) .\n4. Из начального состояния строим переходы в эти состояния\nдля которого c принадлежит First(r(Lin)). Переходы имеют вид S -> c к c.\n5. Переходы из состояния c соответствуют элементам d\nопределяет Follow(r(Lin))(c) и имеет форму c -> d на d.\n6. Конечные состояния таковы, что c принадлежит Last(r(Lin)), так же как и S,\nесли эпсилон принадлежит L(R).\n7. Теперь стираем разметку, построенную линеаризацией на\nмашинные переходы. Строительство завершено."
    },
    {
        "question": "4. Конструкция автомата Глушкова.",
        "answer": "____\nАлгоритм построения Глушкова(р)\n1. Построить линеаризованную версию r: r(Lin) = Linearize(r).\n2. Мы ищем First(r(Lin)), Last(r(Lin)) и Follow(r(Lin))(c) для всех\nc принадлежит (Sum(r(Lin))) .\n3. Все состояния автомата, кроме начального (назовем его S),\nсоответствуют буквам, которым принадлежит c (Sum(r(Lin))) .\n4. Из начального состояния строим переходы в эти состояния\nдля которого c принадлежит First(r(Lin)). Переходы имеют вид S -> c к c.\n5. Переходы из состояния c соответствуют элементам d\nопределяет Follow(r(Lin))(c) и имеет форму c -> d на d.\n6. Финальные состояния – такие, что c принадлежит Last(r(Lin)), как и S,\nесли эпсилон принадлежит L(R).\n7. Теперь стираем разметку, построенную линеаризацией на\nмашинные переходы. Строительство завершено."
    }
]